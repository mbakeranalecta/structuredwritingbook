<?xml version="1.0" encoding="UTF-8"?>
<chapter name ="chapter.heavyweight">
<title>Heavyweight markup languages</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conformance algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conformance</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conformant</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conforming</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conforms</annotation></phrase> <phrase><annotation type="algorithm">content management algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content management algorithm">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<p>I use the term <phrase><annotation type="italic">heavyweight</annotation></phrase> here as a contrast to the commonly used term <phrase><annotation type="italic">lightweight</annotation></phrase>, even though heavyweight is not used commonly for markup languages. Nonetheless, it fits. Both the abstract language <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> and concrete languages such as <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> and <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> are heavyweights in the sense that they provide a lot of capability at the expense of a large footprint.</p>
<p>Having said that, there is an important distinction between the heavyweight syntax of XML and the heavyweight semantics of a <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> or <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase>. You can represent the semantics of DITA or DocBook using a more lightweight syntax. And you can certainly create simple markup languages with lightweight semantics using the heavyweight syntax of XML. Despite this, there is a definite connection between heavyweight syntax and heavyweight semantics, perhaps because languages with more heavyweight semantics have a greater need for the heavyweight capabilities of XML and the processing tools that go with it.</p>
<p>This chapter contains a brief survey of some heavyweight languages. Heavyweight languages often contain structures from more than one domain. Their core is usually in the document domain, but they typically contain some <phrase><annotation type="concept">media-domain</annotation></phrase> structures for things such as tables that are hard to abstract from the <phrase><annotation type="concept">media domain</annotation></phrase> in a generic way. They also typically contain some subject-domain structures, typically related to technology, since many heavyweight languages originated for documenting technical products. Finally, most contain some management-domain structures, particularly for capabilities such as conditional text.</p>
<p>Why is the structured writing landscape dominated by a few large and loosely constrained markup languages? Here are a few reasons:</p>
<ul>
<li>
<p>Big, loosely constrained document-domain markup languages are the smallest step into the document domain from word processors and desktop publishing applications. Thus, they represent a relatively small conceptual change for writers. However, this also means that they do relatively little to partition and redirect complexity away from writers. They exchange some formatting complexity for structural complexity, which may or may not be an overall win, but they do nothing to enhance rhetorical repeatability or drive information architecture.</p>
</li>
<li>
<p>The adoption of structured writing is rarely motivated by a desire to lessen the amount of complexity that goes unhandled in the content system. Instead, adoption is typically driven by a desire to improve some aspect of content management, particularly content reuse. While you can do these things without resorting to structured writing, structured writing formats make it easier to integrate individual pieces of content and help ensure that your content doesn’t get locked into a vendor’s system.</p>
</li>
<li>
<p>Constraints are onerous if you don’t get them right, and the benefits of getting them right are often under-appreciated, especially in content management applications where the consequences of a lack of constraints how up years down the road, when it becomes all too easy to blame any problems on human failure rather than poor system design.</p>
</li>
</ul>
<p>For all these reasons, it is worthwhile to look at where the big public languages fit in the structured writing picture.</p>
<p>This chapter is not a buyer’s guide; large systems like DocBook, DITA, and S1000D would take too much space in this book to do them full justice. Rather, this chapter, and the book as a whole, attempt to provide a framework that allows you to understand your structured writing requirements independently from any system and to evaluate, compare, and contrast systems in more or less neutral terms.</p>
<section>
<title>DITA</title>
<p>There are two ways of looking at <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>. You can look at it as a complete structured writing system that can be used more or less out of the box.<citation type = "idref" value = "fn.pkg"/> Alternatively, you can look at DITA as its name proclaims: an information typing architecture. The acronym DITA stand for Darwin Information Typing Architecture, with the word “Darwin” representing DITA’s approach to the <phrase><annotation type="concept">extensibility</annotation></phrase> of markup: <phrase><annotation type="concept">specialization</annotation></phrase>.</p>
<footnote id ="fn.pkg">
<p>I say “more or less” because even packaged applications such as Word or FrameMaker are not used completely out of the box for serious content creation: you need to customize styles and output formats to some extent, and the same is true of DITA.</p>
</footnote>
<p>Out of the box, the DITA specification gives you a fixed set of topic types. The DITA information typing architecture gives you the capability to create a unbounded number of information types. I discuss DITA as an information typing architecture in <citation type = "nameref" value = "chapter.extensible"/>. Here I look at out-of-the-box DITA and processing options.</p>
<p>Processing options for out-of-the-box DITA come in two main forms:</p>
<ol>
<li>
<p><phrase><annotation type="bold">The DITA Open Toolkit:</annotation></phrase> You can download the open-source <phrase><annotation type="tool">DITA Open Toolkit</annotation></phrase> for free and use it to produce content. The <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> stylesheets that come with the toolkit are basic, but they can be customized, which you will likely want to do.</p>
</li>
<li>
<p><phrase><annotation type="bold">Packaged DITA tools:</annotation></phrase> There are a variety of tools that package DITA. Some are XML editors that include support for editing and processing DITA. Others are content management systems of one degree of sophistication or another. These tools may add capabilities beyond what is supplied by the DITA Open Toolkit and also may hide the underlying DITA structures. Evaluating these tools is beyond the scope of this book.</p>
</li>
</ol>
<p>If you are evaluating how well DITA fits your needs, the key features of out-of-the-box DITA to consider are its topic model and its focus on the <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase>. The description of the <phrase><annotation type="concept">document-domain</annotation></phrase>/<phrase><annotation type="concept">management-domain</annotation></phrase> approach to reuse in <citation type = "nameref" value = "chapter.reuse"/> is based on the DITA model, which provides comprehensive support in those domains.</p>
<p>As described in <citation type = "nameref" value = "chapter.blocks"/>, the DITA topic model is based on the idea that you can break down <phrase>information</phrase> into different abstract types and that there is value in separating the different types. One of the problems with this theory, and consequently with the application of DITA’s topic model, is that it is not clear how big an information type is and whether an information type constitutes a rhetorical block or just a semantic block. Specializing DITA allows you to be more specific on this point, but with out-of-the-box DITA, you are probably using three topic types: concept, task, and reference.<citation type = "idref" value = "fn.oobdita"/> These topic types do not unambiguously constitute semantic blocks or rhetorical blocks; in practice they are used both ways.</p>
<footnote id ="fn.oobdita">
<p>Out-of-the-box DITA also includes other topic types, including machine-industry and troubleshooting tasks, which provide additional document-domain structures. However, the existence of these types does not alter my point.</p>
</footnote>
<p>The principal thing that sets out-of-the-box DITA apart from other approaches to structured writing is its map and topic architecture. In most other systems, the unit that the writer writes and the unit that the reader reads are the same. For long works, you may choose a mechanism for breaking up and assembling pieces, but the content is still described by a single schema. For instance, in <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase>, you can write a book using a <code>book</code> document type in which you can include various <code>chapter</code> document types to create a complete book out of multiple files. In other words, a DocBook book is a single document structure that just happens to be made up of individual files. In this model, a chapter is a rhetorical block, though it may also be an element of a larger rhetorical block which is the whole book.</p>
<p>But DITA partitions this document assembly function into a separate file type, the map. A DITA map file is an independent structure. It does not create a single logical document structure. It does not usually contain any actual content, and you can’t write an entire book in a single map file. Instead, a map file is an instruction to a publishing tool chain about how to assemble a larger work out of component pieces.</p>
<p>This distinction is critical. In the DocBook model, there is a continuity of constraint between the book and its chapters. In DITA, the constraints on the map and the constraints on the topics in the map are completely separate. This means that in DITA, the topic is the largest unit of content to which content constraints can be applied (at least in the conventional way). This represents a partitioning of the conformance, quality, and composition algorithms that leaves responsibility for larger units entirely with the writer.</p>
<p>Maps are structured like a tree, so you can construct arbitrarily deep hierarchies. This means you can choose which parts of your structure you create using a map and which parts you create inside a topic. If you have a list of four items, each of which needs two or three paragraphs of description, you can create one topic with the list of four items in it, or you can create one topic for each item and then tie them together using a map. Since the topic is the largest unit of content constraint in DITA, if we break content down to this level, we lose the ability to apply constraints to the content as a whole. On the other hand, we can <phrase><annotation type="algorithm">reuse</annotation></phrase> each item separately.</p>
<p>This presents a dilemma. In <citation type = "nameref" value = "chapter.blocks"/> we characterized structured writing as dividing content into blocks, and we made a distinction between semantic blocks and rhetorical blocks. In the design of a markup language, we build rhetorical blocks from semantic blocks, which may be made up of smaller semantic or structural blocks. This works fine for developing the structure of a rhetorical block, which is the work that will be presented to the reader. In that scenario, writers write rhetorical blocks. The semantic blocks are just elements of the model.</p>
<p>But things become more difficult when you attempt to do fine-grained reuse of content. In that case, you may need to write independent semantic blocks and combine them to produce rhetorical blocks. DITA lets you do this in two ways. The first (which is frequently discouraged) is to nest one topic inside another. The second is to combine topics using a map, with the map representing the rhetorical block. However, DITA does not provide a high-level way to constrain the structure of a rhetorical block built this way.</p>
<p>If you want a constrained rhetorical block, you have to model it as a single DITA topic type. You can certainly do this by specializing from the base <code>topic</code> topic type. However, in doing so you probably need to move away from the information-typing idea of separating different types of information, because a full rhetorical topic, such as our recipe example, often requires different types of information.</p>
<p>This leads to the confusion about whether a DITA topic is a <phrase><annotation type="structure">semantic block</annotation></phrase> or a <phrase><annotation type="structure">rhetorical block</annotation></phrase>. For people who use out-of-the-box DITA this can be a problem because, by default, the DITA Open Toolkit creates a separate Web page for each topic. This is not an appropriate presentation if your individual DITA topics are not <phrase><annotation type="structure">rhetorical blocks</annotation></phrase>. If your rhetorical block is made up of multiple DITA topics strung together by a map, and you want that rhetorical block to appear on a single page, you need to use a procedure called <phrase><annotation type="italic">chunking</annotation></phrase>, which is not as straightforward as it should be.<citation type = "idref" value = "fn.ditachunking"/></p>
<footnote id ="fn.ditachunking">
<p>Chunking is on the agenda to be fixed in DITA 2.0.<citation type = "citation" value = "http://docs.oasis-open.org/dita/dita-1.3-why-three-editions/v1.0/cn01/dita-1.3-why-three-editions-v1.0-cn01.html#future-of-dita"/></p>
</footnote>
<p>The idea that blocks are reusable is attractive, but you need to think through exactly what the reusable unit of content is. It is one thing to reuse complete <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> (perhaps with some variations in the text). It is quite a different thing to reuse <phrase><annotation type="structure">semantic blocks</annotation></phrase> below the level of the <phrase><annotation type="structure">rhetorical block</annotation></phrase>, particularly if you need to constrain the <phrase><annotation type="structure">rhetorical block</annotation></phrase> or apply any of the other structured writing algorithms at the level of the <phrase><annotation type="structure">rhetorical block</annotation></phrase>.</p>
<p>Quality should be a serious concern with this model. If you assemble <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> out of smaller reusable units without paying attention to the rhetorical integrity, completeness, and consistency of the result, quality can be seriously affected. It is difficult to maintain quality if authors no longer see, think, or work in the context of the <phrase><annotation type="structure">rhetorical block</annotation></phrase> and if the structure of the <phrase><annotation type="structure">rhetorical block</annotation></phrase> is not constrained. Because such a reuse solution does not consider where the rhetorical complexity of <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> goes, complexity gets dumped on readers.</p>
<p>DITA, as a technology, does not prevent you from working in whole <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> or from constraining your blocks in any way you want – DITA’s information typing capabilities make this possible. However, the block-and-map model, whether implemented by DITA or any other system, creates an inherent tension between creating smaller <phrase><annotation type="structure">semantic blocks</annotation></phrase> to optimize for reuse and creating constrainable <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> to optimize for content quality. And because it provides no facilities for imposing constraints above the topic level, DITA makes it difficult to partition and redirect this complexity away from the writer. !!!(RLH) I’m not sure what you mean when you say “either kind of constraint” in the paragraph below. What are the two kinds you’re talking about?</p>
<p>However, you do not require either kind of constraint to reuse content blocks. When used correctly, constraints may improve quality and reliability, but you don’t need them to compose larger blocks out of smaller blocks. This has led many organizations to select DITA for its reuse capabilities without taking advantage of its constraint capabilities or its information typing roots. People taking this approach will sometimes write their content in the base <code>topic</code> topic type rather than a more constrained specialization. Quite simply, they don’t find DITA’s information typing to be useful, so they ignore it. Of course, this means that the responsibility for composability falls on the writers, but if DITA’s information typing does not not fit the material, this does not necessarily make things worse.</p>
<p>The growing popularity of this approach to reuse has led to the development of alternatives to DITA that provide the same reuse-management capabilities but remove the constraint mechanisms. One example of this trend is <phrase><annotation type="tool">Paligo</annotation></phrase>, a reuse-focused component content management system that uses <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> as its underlying content format, specifically for the purpose of minimizing constraints on the content.<citation type = "citation" value = "http://idratherbewriting.com/2016/08/01/paligo-the-story-xml-ccms-in-the-cloud/"/> Such systems can reduce the up-front complexity of component-based <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase>, though possibly at the expense of costs down the road if the failure to apply constraints up front results in more unhandled complexity falling through to readers.</p>
</section>
<section>
<title>DocBook</title>
<p><phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> is an extensive, largely document-domain language with a long history and an extensive body of processing tools and support. As we have noted, <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> is not a tightly constrained language. Instead it provides broad capabilities for describing document structures. In other words, it is mainly concerned with partitioning the document domain from the media domain in as comprehensive manner as possible. It does not constrain the rhetoric of content in any way and, therefore, makes no attempt to partition and distribute any part of the creative aspects of the content system.</p>
<p>Unlike <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>, <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> was not created to support any particular information typing theory. It does not reflect any methodology for writing or organizing content. DocBook supports the structure of books but does not constrain the <phrase><annotation type="structure">rhetorical structure</annotation></phrase> of a work; in fact, the developers of docbook made every attempt to avoid constraining rhetorical structure, leaving that task to the writer. The downside of this hands-off approach is that DocBook is a complex system, and the writer must deal with this complexity without the benefit of having other aspects of their task, such as information typing, partitioned and directed away.</p>
<p>Of course, this is not to say that using DocBook is any more complex than using a publishing tool such as FrameMaker. It may well be less so. Nonetheless, DocBook and its tool chain can be challenging to learn and use. Because of this, writers often use simplified subsets of DocBook. (Where DITA is sometimes customized by the addition of elements, DocBook is often customized by their subtraction.) However, DocBook remains popular with many for its lack of constraints combined with its rich feature set.</p>
<p>Because of its lack of constraints, <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> does not fit well with the idea of structured writing as a means to partition and redirect complexity. However, it can play a useful role in a structured writing tool chain as a language for the <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase>. This is exactly how it was used in the production of this book. The book was written in a small, constrained language based on <phrase><annotation type="language">SAM</annotation></phrase> and transformed by the presentation algorithm into DocBook, which then feeds the publisher’s standard publishing tools.  The DocBook created by this method matches the publisher’s specifications.</p>
<p>In using this approach, I partitioned the complexity of meeting the Publisher’s DocBook requirements from my task of writing the book and gave myself a much simpler authoring interface, both syntactically and semantically. Of course, I transferred that complexity to myself in another role (<phrase><annotation type="role">information architect</annotation></phrase> or <phrase><annotation type="role">content engineer</annotation></phrase>), since I had to write the algorithm that transformed my SAM source into the publisher’s preferred form of DocBook. But this was a big win for me, because writing that algorithm was a separate activity that did not impinge on my attention when I was writing. Another benefit was that because my little book-writing language is highly constrained, maintaining conformance was much easier and the DocBook produced by my algorithm was more consistent and conformed more closely to the publisher’s requirements than if I had written in DocBook directly.</p>
<p>I wrote my previous book <phrase><annotation type="citetitle">Every Page is Page One</annotation></phrase> directly in DocBook (an experience that contributed to my decision to develop SAM), but it took a lot of revision to get my DocBook content into the form that the publication process required. The publishing process has a set of constraints that are not enforced by DocBook itself. Instead, they have to be imposed by the author while writing. But in the SAM-based markup language I used for the book, all those constraints were factored out, which enabled me to translate content reliably into a DocBook instance that met the publisher’s requirements. In addition, I didn’t need to remember any of those constraints.</p>
</section>
<section>
<title>S1000D</title>
<p><phrase><annotation type="standard">S1000D</annotation></phrase> is a specification developed in the aviation and defense industries specifically for the complex documentation tasks of those industries. It supports the development of the Interactive Electronic Technical Manuals (IETMs) that are typically required in that industry. Although S1000D has <phrase><annotation type="concept">subject-domain</annotation></phrase> structures, it also has media-domain structures targeted at the production of IETMs and extensive management-domain structures designed to support the common source database (CSDB), the content management architecture that is part of the S1000D specification. S1000D is much more than a structured writing format. It specifies a complete document production system for a specific industrial sector. In other words, S1000D represents a particular partitioning of the content system designed for a particular industry.</p>
</section>
<section>
<title>HTML</title>
<p><phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> is widely used as an authoring format for content. For the most part, HTML is used in the <phrase><annotation type="concept">media domain</annotation></phrase>: people writing for the web in its native format, often using a WYSIWYG HTML editor.</p>
<p>But HTML is still a document-domain language, and efforts have been made over the years to factor out the media-domain aspects of HTML and leave the formatting to CSS stylesheets. This makes HTML a legitimate <phrase><annotation type="concept">document-domain</annotation></phrase> markup language. In particular, people interested in using HTML this way often use XHTML, a version of HTML that follows the constraints of XML. Being an instance of XML is important because it means you can write XHTML in an XML editor and process it with XML processing tools. This means that you can potentially publish content written in XHTML by processing it into other formats or by modifying its structure for use in different HTML-based media such as the Web and ebooks.</p>
</section>
<section>
<title>Subject domain languages</title>
<p>There are hundreds of public subject domain languages written in XML. Most of these are more data oriented than content oriented, but you might be able to derive content from some of them using the <phrase>extract and merge</phrase> algorithms. Wikipedia maintains an extensive list at <phrase><annotation type="url">https://en.wikipedia.org/wiki/List_of_markup_languages</annotation></phrase>. However, most subject domain languages used for content are developed in house to suit a particular subject matter and reader base.</p>
<remark attribution ="RLH">
<p>I think an example would be useful here, even if that example just names a few prominent languages.</p>
</remark>
</section>
</chapter>
