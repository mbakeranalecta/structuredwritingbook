<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.content-management">
<title>Content Management</title>

<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="process">conformance</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforming</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> <phrase><annotation type="process">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<index>
<record>
<type>process</type>
<term>content management</term>
</record>
</index>
<p>Managing content assets is fundamental to managing your content process. Any large collection of content needs to be managed, and when you manage the work of many contributors to produce an integrated <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase>, managing content assets becomes key.</p>
<p>To make content management decisions, you must be able to locate and examine the content. These functions can be performed by algorithms if you attach sufficient and accurate metadata to your content. Attaching metadata to content to allow algorithms to make decisions is, of course, precisely what you do in all forms of structured writing. Therefore, content management is a structured writing process. In this section, I add a set of management algorithms to the content manipulation algorithms described in <citation nameref="part.algorithms"/>. Like the other structured writing algorithms, these algorithms work differently depending on which domain your content is written in.</p>
<p>But what if your content does not contain sufficient metadata to allow management tasks to be performed by algorithm – or even by hand? In that case you can use a content management system (CMS) to attach additional metadata to the content as external labels. Most commercial CMSs support this capability.</p>
<p>Of course, you can choose to manage your content by hand. This means that everyone who has a role in managing content – that is, everyone on your content team – must have the knowledge, skills, and time needed to perform the management tasks. Because these conditions are hard to meet with perfect consistency, content management complexity can fall through the cracks, resulting, as unmanaged content complexity always does, in inferior rhetoric and inefficient processes. But managing content by hand does avoid introducing a lot of complex tools into your system. Introducing tools is never neutral. New tools always bring complexity and unless they provide or enable a better partitioning of complexity, they can cause more problems than they solve.</p>
<p>Some content management systems attempt to be all encompassing – to be the only tool anyone in the organization ever uses to create and deliver content. Others are designed to work in concert with other tools. Some are more <phrase><annotation type="concept">frameworks</annotation></phrase> than tools – platforms on which you can construct your own content management functionality. All of them implement some form of structured writing for at least some functions in the media and document domains, with some from the <phrase><annotation type="concept">management domain</annotation></phrase> mixed in. Some work with or, at least, support certain management functions for the <phrase><annotation type="concept">subject domain</annotation></phrase>. Some content management systems attempt to manage the entire content creation process, from design and authoring to workflow and publishing. Others focus on more limited aspects of the process. Some focus on a single media platform (usually the web), while others support multiple media.</p>
<p>A CMS does exactly what I describe throughout this book: it partitions and distributes the tasks of the content process. Different CMSs partitions tasks differently, and there is, of course, no guarantee that a particular system’s partitioning is the best fit for your organization or that it will direct all complexity to people or processes that have the skills, knowledge, and resources to handle it. And if not, unhandled process complexity will result in poor rhetorical quality.</p>
<p>As tempting as it may be to simply go shopping for a content management system, buying a CMS means buying a complete process and partitioning, which may or may not be the best fit for your organization. A better approach is to design the partitioning of your system first and then look for tools that fit the process you have designed. Depending on how you partition your processes and how and where you direct complexity, you may not need a conventional CMS at all.</p>
<p>Many of the decisions you have to make in a large content system involve examining large volumes of content. Thus the main interface to many content management systems is a file system or database view of the content repository. Whatever specific tasks the system is performing, the essence of its interface is that it allows you to view and apply metadata to large volumes of content. However, if your content already contains the metadata needed to make these decisions, the need for such an interface diminishes (thought the need for the algorithms themselves remains).</p>
<p>Structured writing and content management systems both work to make <phrase><annotation type="concept">metadata</annotation></phrase> available to algorithms. But the algorithms work differently – and require a different class of metadata – in each structured writing domain. Content management systems tend to supply <phrase><annotation type="concept">subject-domain</annotation></phrase> and <phrase><annotation type="concept">management-domain</annotation></phrase> metadata for algorithms that process document-domain and media-domain content. But subject-domain content supplies the subject-domain metadata itself, and, as we have seen, you can often factor out the need for management-domain metadata by moving content to the subject domain. Just as a single set of subject-domain structures can often serve the needs of multiple content manipulation algorithms, the same set can often also serve the needs of multiple management algorithms.</p>
<p>This does not mean that if your content is in the subject domain you will never need a CMS, but it does mean that you may not need one or that you may require a less elaborate system. Certainly it means that if you do need a CMS, you should choose one that partitions tasks in a manner that supports the subject domain.</p>
<p>If your content does not contain the metadata necessary for management, the <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> must gather and store it separately. This adds complexity to the CMS interface, which can be a major source of pain for users. For CMSs that are designed to be the only tool you use, this generally means that the structured writing format is baked in and can only be changed in limited ways, if at all. Transferring metadata from the CMS to the structures of your content would require a major reconfiguration of the CMS. If you buy this kind of system, you need to look at the total picture – how the CMS partitions and redistributes all of the complexity of the content systems and what complexity, if any, it neglects and lets fall through. There will likely be little you can do to change the partitioning or distribution after the fact, so make sure it is what you want going in.</p>
<p>Most off-the-shelf <phrase><annotation type="tool">content management systems</annotation></phrase> are designed for <phrase><annotation type="concept">media-domain</annotation></phrase> or basic <phrase><annotation type="concept">document-domain</annotation></phrase> content. This makes sense from a commercial point of view because it allows CMS vendors to develop their own <phrase><annotation type="concept">metadata</annotation></phrase> scheme and <phrase>management</phrase> algorithms independent of the content that will be stored. This means a vendor can sell its CMS to a wider variety of clients and advertise that it has simple editors or works with the editors that people already have.</p>
<p>The problem with this model – in terms of developing a comprehensive solution for managing complexity across the content system – is that it draws a hard line between the <phrase>management</phrase> tasks and constraints supported by the CMS and any <phrase>management</phrase> tasks or constraints associated with the rhetoric of your content. This means that algorithms that depend on the consistency of content or its relationships with other content are largely unsupported by the CMS, and there is no integration between those algorithms and the algorithms provided by the CMS. Due to this lack of integration, complexity gets dropped, with the usual consequences for rhetoric and for the reader.</p>
<p>Other CMSs are built for more complex <phrase><annotation type="concept">document-domain</annotation></phrase> languages. These CMSs typically support <phrase><annotation type="concept">management-domain</annotation></phrase> features specifically for those languages and are sold as such: a DITA CMS or an <phrase><annotation type="standard">S1000D</annotation></phrase> CMS. The most common systems of this type today are based on <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>.</p>
<p>You might expect that a CMS would primarily record <phrase><annotation type="concept">management-domain</annotation></phrase> metadata. After all, the management domain is an intrusion into the structured writing world, since it does not actually describe the structure of content. The reason for the intrusion of the <phrase><annotation type="concept">management domain</annotation></phrase> into content is to allow for the management of the content below the level of whatever file or chunk size you store in the CMS.<citation idref="XMLDatabase"/></p>
<footnote id="XMLDatabase">
<p>In some CMSs, this distinction between the chunk stored in the <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> and the structures expressed inside that chunk is moot. A CMS based on a native <phrase><annotation type="tool">XML database</annotation></phrase>, for instance, makes no distinction between the chunk and the structure of the chunk, but treats the entire <phrase><annotation type="tool">repository</annotation></phrase> as a single XML resource that it can query and manage down to any level of granularity. Even with such a system, however, this distinction remains for writers, who have to deal with the structure of whatever sized chunks of content they are asked to write.</p>
</footnote>
<p>But while you will rarely find much <phrase><annotation type="concept">media-domain</annotation></phrase> or <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> stored at the <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> level, CMSs often contain a great deal of <phrase><annotation type="concept">subject-domain</annotation></phrase> metadata. If you manage a large volume of content, you will need some way to find content on a particular subject. If you are doing <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase>, for example, writers will constantly be asking if content already exists on the subject they are preparing to write about. If your CMS is managing the delivery of content dynamically to the Web, it will need to respond to queries based on subject matter. And if you are optimizing your content for <phrase><annotation type="concept">search</annotation></phrase> you will need to provide the search engine with subject <phrase><annotation type="concept">metadata</annotation></phrase> in the form of keywords or <phrase><annotation type="structure">microformats</annotation></phrase>. All of this depends on <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase>. Subject domain metadata is therefore central to CMS operations. This is also why the use of <phrase><annotation type="concept">subject domain</annotation></phrase> structures in your content can lessen your reliance on content management systems.</p>
<p>To figure out what type of content management system you may need, if any, it helps to understand how content management systems work with metadata and where the metadata in question resides in your content. Essentially structured writing and content management systems both work to make metadata available to algorithms, so structured writing and content management systems are both working towards the same goal, and depending on your process you may want to assign more of that task to one or to the other.</p>
<section>
<title>The location of metadata</title>

<p><phrase><annotation type="tool">Content management system</annotation></phrase> do their job largely through the collection and management of <phrase><annotation type="concept">metadata</annotation></phrase>. Partitioning and redirecting complexity requires a method to pass information between partitions in a reliable way, and that is what structure and metadata do. Metadata provides a record of the identity and status of content. Management actions are actions on metadata: either creating and updating metadata or performing actions (running algorithms) based on metadata.</p>
<p>The location of the <phrase><annotation type="concept">metadata</annotation></phrase> that records the identity and status of the content and the constraints it obeys differs from one structured writing domain to another. The <phrase><annotation type="concept">media domain</annotation></phrase> captures virtually no <phrase><annotation type="concept">metadata</annotation></phrase> that is useful for <phrase><annotation type="process">content management</annotation></phrase>, the <phrase><annotation type="concept">document domain</annotation></phrase> captures some, but not enough, and the <phrase><annotation type="concept">subject domain</annotation></phrase> often captures almost everything you need except, perhaps, for <phrase><annotation type="tool">workflow</annotation></phrase> information.<citation idref="fn.workflow-info"/></p>
<footnote id="fn.workflow-info">
<p>Workflow information is <phrase><annotation type="concept">management-domain</annotation></phrase> data, and there is nothing to prevent you from adding workflow information to <phrase><annotation type="concept">document-domain</annotation></phrase> or <phrase><annotation type="concept">subject-domain</annotation></phrase> content if you want to.</p>
</footnote>
<p>It is a very common pattern for a <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> to store <phrase><annotation type="concept">document domain</annotation></phrase> or <phrase><annotation type="concept">media domain</annotation></phrase> content and attach <phrase><annotation type="concept">subject-domain</annotation></phrase> metadata to it as an external label. For instance, a CMS might store recipes written in <phrase><annotation type="language">Markdown</annotation></phrase> and attach separate <phrase><annotation type="concept">metadata</annotation></phrase> records to each recipe listing the key recipe metadata needed for retrieval and sorting of recipes. One of the things that writers often complain about with CMS systems is that they are not allowed to submit content to the system without filling out complicated metadata records.</p>
<p>An alternative is to write recipes in a <phrase><annotation type="concept">subject-domain</annotation></phrase> format in which all the recipe <phrase><annotation type="concept">metadata</annotation></phrase> is included in the content from the beginning. The <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> then requires no external metadata labels, though it does require a way to access and query the embedded metadata. (CMSs based on <phrase><annotation type="tool">XML databases</annotation></phrase> often have this capability as a natural consequence of the XML database architecture.)</p>
<p>Which approach is preferable? The conventional CMS approach arises because most CMSs are based on relational databases, which are good at storing metadata records and attaching them to blobs of text but are not good at storing or querying the <phrase><annotation type="concept">hierarchical structure</annotation></phrase> of structured content. The conventional approach has several disadvantages, all of which introduce complexity that is often not handled well. The disadvantages of this approach include the following:</p>
<ol>
<li>
<p>It can only record the characteristics of a chunk of content as a whole. It cannot look down into the content to find more fine-grained <phrase><annotation type="concept">metadata</annotation></phrase>. One of the advantages of writing a recipe is the <phrase><annotation type="concept">subject domain</annotation></phrase> is that it allows you to do things like querying the collection of recipes for all those with a calorie count below 100. But unless the metadata record for the recipe includes that level of detail, the <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> cannot respond to that <phrase><annotation type="tool">query</annotation></phrase>. And if the CMS does store that level of detail, it is effectively asking the writer to write the entire content twice, once in the <phrase><annotation type="concept">document domain</annotation></phrase> document and once in the <phrase><annotation type="concept">subject domain</annotation></phrase> metadata label. Not only is this more work, it is quite likely that the two versions will fall out of sync with each other.</p>
</li>
<li>
<p>It provides no support for <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> of the content, which means it does nothing to help improve content quality. Requiring <phrase><annotation type="concept">document-domain</annotation></phrase> content as the storage format precludes the use of the <phrase><annotation type="concept">subject domain</annotation></phrase> for writing and cuts writers off from all the advantages the subject domain provides.</p>
</li>
<li>
<p>The system has no way of telling if the content <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> to its constraints. It records the content constraints in a separate record without ever validating that the content meets them.</p>
</li>
<li>
<p>It separates the <phrase><annotation type="concept">metadata</annotation></phrase> from the content it describes. This allows for drift between the content and the metadata.</p>
</li>
</ol>
<p>Storing <phrase><annotation type="concept">metadata</annotation></phrase> in the content presents challenges, too. Having each piece of content stored in the <phrase><annotation type="concept">subject domain</annotation></phrase> makes sense from a rhetorical point of view and makes it easy to submit content, since writers don’t need to fill out additional metadata forms. The problem is how to retrieve the metadata.</p>
<p>A CMS is essentially a database, and the way you retrieve information from a database is to write a <phrase><annotation type="tool">query</annotation></phrase>. A query is different from a <phrase><annotation type="concept">search</annotation></phrase>. A search is fuzzy. A <phrase><annotation type="tool">search engine</annotation></phrase> takes a plain text question or search phrase and tries to figure out which documents are the best match. Search engines may be powerful and sophisticated, but their results are a sophisticated, mechanical guess, and sometimes they get it wrong. Ask a search engine for a list of recipes with less than 100 calories, and it will give you a bunch of guesses based mostly on the plain text of those documents. Chances are it will catch some, miss others, and give you some false hits.</p>
<figure id="fig.search-query">
<title>Search results vs query results</title>

<insert item="../graphics/search-query.xml" type="image"/>
</figure>
<p>A <phrase><annotation type="tool">query</annotation></phrase>, on the other hand, is a request for items whose <phrase><annotation type="concept">metadata</annotation></phrase> precisely matches specified criteria. A query to return recipes for which the field <code>recipe/nutrition/calories</code> has a value less than 100 returns all the results, misses none, and gives you no false hits. However, it works only for content that contains this field, and to write this query, you need to know exactly how the system stores recipes (<citation idref="fig.search-query"/> illustrates the difference between a search and a query).</p>
<p>If you have many different content structures in your repository, you need to know how each of them is structured in order to create <phrase><annotation type="tool">queries</annotation></phrase> that return the correct results. Although this is a complicating factor, it is not the end of the world. <phrase><annotation type="role">Information architects</annotation></phrase> and <phrase><annotation type="role">content engineers</annotation></phrase> can create and save queries that writers can run as needed, saving them from having to remember the details of every structure.</p>
<p>In the end there is no way around this. Accurate and reliable <phrase><annotation type="tool">queries</annotation></phrase> depend on precise and consistent <phrase><annotation type="concept">metadata</annotation></phrase> that is specific to the object it belongs to. There is no such thing as a generic metadata record. They are always specific to the things they describe. Subject-domain metadata is specific to its subject. If you want to be able to find all recipes with calorie counts less than 100, you need recipe-specific metadata that records the number of calories in the recipe. If you want to find a used car listing for a blue convertible, you need metadata that specifically records the car color and body style. There is no generic metadata format that supports both of these queries. The inherent variability of content means you cannot create a generic query system. The trick is to find the right balance and make your content as easy to query as possible.</p>
</section>
<section>
<title>Hybrid approaches</title>

<p>There is an alternative to the two approaches described above, which is a hybrid of document and database. In the <phrase><annotation type="concept">subject domain</annotation></phrase>, you can create fielded data that an algorithm can use to create content. The relational database on which most CMSs are based is great at managing fielded data, and this allows you to create a hybrid system in which the fielded data parts of a subject-domain document type are stored as database fields and the narrative content is stored in text fields, using document-domain markup such as markdown or HTML. Hybrid systems are common in custom web CMS solutions, where they are not looked on as hybrids so much as logical extensions of the database model.</p>
<p>The advantage of this model is that writers no longer need to add metadata after the fact, because it is part of their normal authoring environment, which is essentially a database form. This is a perfectly legitimate implementation of subject-domain structured writing, since there is no requirement that structures have to be expressed and captured as markup. Nonetheless, many <phrase><annotation type="role">content strategists</annotation></phrase> have come to realize the limitations of this model, which lacks any constraints on the content of the narrative fields, thus making it hard to create the consistent rhetoric that <phrase><annotation type="concept">content strategy</annotation></phrase> tries to foster.</p>
</section>
<section>
<title>Alternate repositories</title>

<p>At the heart of any content management solution is a repository: a place to put the content assets you are managing. The simplest form of repository is a file system, either local or shared on a network. The amount of metadata you can associate with content on a file system is limited. Some people use a separate metadata store, such as a spreadsheet, but there are limits to how far such a system can scale, and it is hard to apply content management algorithms in such an environment.</p>
<p>Virtually every full-fledged CMS comes with and is built around a repository that is set up to capture the metadata used for content management. Having the repository baked into the CMS provides obvious integration benefits for the CMS itself. However, this means that access to your content by any algorithm not provided by the CMS itself comes only by permission of the CMS. Many systems do not make access to their content easy for outside processes. This is in part because vendors want to present their systems as providing everything you need, but also in part to preserve the integrity of the repository, which could be corrupted by a poorly written algorithm.</p>
<p>Even you don’t need the services of a full-fledged CMS, or you simply can’t find one that supports the partitioning you want for your content system, you may still need two content management features for your content repository: access control and version control. Both of these services can be provided by the <phrase><annotation type="tool">version control system</annotation></phrase>s used by software developers.</p>
<p>Access control gives you the ability to permit or deny access to resources on an individual or group basis. This improves the security of your system by helping to prevent deliberate or unintentional damage to your content by unauthorized individuals.</p>
<p>A version control system (VCS) stores all of the changes writers make to content, allowing them to find and restore previous versions. Most version control systems allow you to maintain content in an ordinary file system, which means that tools and algorithms do not have to know anything about the VCS in order to work on the content. The VCS stores all changes that are made to files under its control, storing each iteration along with labels and commentary that allow you to find any version you might want to go back to.</p>
<p>VCSs also allow you to back up content, along with its version metadata, to a central server that can be accessed by many different contributors. Each contributor maintains a local copy of the files and has the ability to upload files to the central server, where they can be pulled down to the workstations of other contributors, thus ensuring that everyone has access to the latest content.</p>
<p>VCSs have various mechanisms for preventing people from accidentally overwriting each other’s work, including the ability to create a branch of the repository where you can make changes independent of other contributors and merge those changes into the mainline of the repository when they are ready for release.</p>
<p>A VCS cannot match the complex facilities of a typical CMS, but they are used successfully for very large software projects involving hundreds of developers. How it possible to support collaboration on this scale with such simple repository features? The key is that code is by its nature highly structured text to which all of the same algorithms I have described for structured writing can be applied.</p>
<p>Software code can be strongly partitioned to minimize the collaborative overhead, and a rich set of tools is available to ensure <phrase><annotation type="process">conformance</annotation></phrase> and to perform <phrase>audits</phrase> to make sure that code is complete and conforms to its constraints. In short, software projects do not need the kind of services provided by a typical CMS on the content side, because the code itself contains the metadata necessary to perform these same functions with external algorithms and because developers enforce the right kind of discipline among contributors. The open nature of a VCS is ideal for software development because it does not impose any barriers to implementing new processes or new algorithms to manage the content.</p>
<p>There is a movement within the documentation community called Docs as Code<citation value="http://www.writethedocs.org/guide/docs-as-code/"/>, which advocates using the same management processes and tools for content as developers use for code, including VCSs and scripted content builds, rather than conventional CMS solutions.</p>
</section>
<section>
<title>Making content manageable</title>

<p>If you want to manage your content, you need to make your content easy to manage. The danger is that if you start with the principal aim of making your content manageable, you may find your <phrase>management</phrase> goals at odds with your <phrase><annotation type="concept">rhetorical</annotation></phrase> goals. It is easier to manage content (or anything else) if its structure is uniform. The constraints you impose to make content more manageable make it more uniform. Thus a system, such as <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>, which starts by proposing just three types of content (concept, task, and reference), has an obvious appeal from a management point of view. However, remember that it is your <phrase><annotation type="concept">rhetorical</annotation></phrase> goals that serve your readers. Your management goals should be subservient to your rhetorical goals.</p>
<p>The constraints that you impose to improve content quality are those which make sure that a piece of content does just the job it is supposed to to. Such constraints ensure that a recipe contains everything a recipe needs and is presented in the way a recipe should be presented. They are specific to the subject matter and the audience. Three generic content types cannot provide all the constraints you need to effectively manage content <phrase><annotation type="algorithm">quality</annotation></phrase>. Indeed, some of the constraints that are designed to facilitate content management may be positively damaging to content quality.</p>
<p>If improved content <phrase><annotation type="algorithm">quality</annotation></phrase> was not one of your business goals, you might naturally choose uniformity in implementing a CMS. However, I would argue that a system based on <phrase><annotation type="concept">subject-domain</annotation></phrase> content can lead to better content management in the long run.</p>
<p>In any system that relies on constraints, on data that is known to meet certain constraints, you need to make sure that the constraints are actually being met. As we have seen, it is often easier to provide effective <phrase><annotation type="concept">guidance</annotation></phrase> and perform effective <phrase><annotation type="algorithm">validation</annotation></phrase> in the <phrase><annotation type="concept">subject domain</annotation></phrase>. Also, the subject domain allows you to factor out many constraints, which is the most effective way of making sure they are obeyed. The <phrase><annotation type="concept">document domain</annotation></phrase> provides far fewer opportunities for factoring out constraints and providing effective guidance. In addition, it is much more difficult to <phrase><annotation type="algorithm">audit</annotation></phrase> constraints correctly in the document domain.</p>
<p>Thus, while a simple <phrase><annotation type="concept">document-domain</annotation></phrase> system of concept, task, and reference <phrase><annotation type="structure">topics</annotation></phrase> meets the content manager’s desire for uniformity, it provides little opportunity for ensuring that the full range of constraints necessary to make content management and reuse work are actually followed. The result can be a deterioration in the quality of the content set over time, a process that tends to be self-perpetuating because disorder in current content makes it harder to impose order on new content, just as you cannot put things away neatly in a messy drawer.</p>
<p>The variety of constraints and formats found in a <phrase><annotation type="concept">subject-domain</annotation></phrase> system may present a greater <phrase><annotation type="process">content management</annotation></phrase> challenge initially, but it can go a long way toward ensuring that the necessary constraints are met. And, as we have seen, you can often use <phrase><annotation type="concept">subject-domain</annotation></phrase> structures to factor out <phrase><annotation type="concept">management-domain</annotation></phrase> concerns (see <citation nameref="chapter.management-domain"/>), which can go a long way toward removing the conflict between <phrase><annotation type="concept">rhetorical</annotation></phrase> structures and <phrase>management</phrase> structures in content. This not only leads to more effective management, but also to a simpler writing experience.</p>
<p>The key to <phrase><annotation type="process">conformance</annotation></phrase> is to create structures that are easy to conform to. The <phrase>content management algorithm</phrase> relies heavily on conformance to constraints and structures. To manage content successfully, you must know exactly what assets you are managing. The more you know about each asset, and the more you can rely on what you know, the more confidently you can manage those assets and the less likely it is that your management system will descend into chaos.</p>
<p>This means that the content management algorithm depends on content that is easy to manage. It may seem like generic units of content would be the easiest to manage, but the problem with such generic units is that you know very little about them, and what you do know is often unreliable. Generic units may be easy to create and easy to store, but they are not easy to manage. It may require more initial thought and planning to manage highly specific, well-constrained content units, but such units will be the easiest to manage over time, especially as your content set grows.</p>
<section>
<title>Managing structured writing assets</title>

<p>Finally, consider that structured writing requires you to record content in <phrase><annotation type="concept">media-domain</annotation></phrase>, <phrase><annotation type="concept">document-domain</annotation></phrase>, or <phrase><annotation type="concept">subject-domain</annotation></phrase> structures, factor out invariants into separate files, express constraints, and create algorithms that translate the content to the <phrase><annotation type="concept">media domain</annotation></phrase> for <phrase><annotation type="algorithm">publishing</annotation></phrase>. All of this creates artifacts that you need to track and requires processes both for keeping track of artifacts and for running the structured authoring and publishing <phrase><annotation type="tool">tool chain</annotation></phrase>.</p>
<p>Thus, you need to manage both the artifacts and the process. Don’t fall into the trap of assuming that these are generic processes. Every artifact results from the partitioning of your content system, and how  they should be managed is determined by how the partitions communicate with each other. This is specific to the overall partitioning strategy of your particular content system. You need to find a tool that fits your partitioning strategy.</p>
<p>One class of tool commonly used for document- and management-domain structured writing systems, particularly <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>, is a specialized type of content management system called a <phrase>component content management system</phrase> or <phrase>CCMS</phrase>. A CCMS is designed for managing small fragments of content, rather than whole documents, and <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> is the primary design objective. Most DITA tools are build around a CCMS.</p>
<p>However, if your content is in the <phrase><annotation type="concept">subject domain</annotation></phrase>, you may not need all the services of a CCMS and may be able to do just fine with a relatively simple <phrase><annotation type="tool">version control system</annotation></phrase>.</p>
</section>
</section>
</chapter>
