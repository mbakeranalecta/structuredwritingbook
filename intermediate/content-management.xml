<?xml version="1.0" encoding="UTF-8"?>
<chapter name ="chapter.content-management">
<title>Content Management</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conformance algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conformance</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conformant</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conforming</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conforms</annotation></phrase> <phrase><annotation type="algorithm">content management algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content management algorithm">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
<p><phrase><annotation type="language">XSL-FO</annotation></phrase></p>
</annotations>
<index>
<record>
<type>concept</type>
<term>content management</term>
</record>
</index>
<p>Structured writing is an instrument we use to help us partition and redirect the complexity of content creation and delivery. In other words, it is an instrument of content management. There are, of course, many tools available to help you manage content. Collectively, they are called <phrase><annotation type="tool">content management systems</annotation></phrase>. They are quite varied in their concept and operation because they partition and redirect different parts of the complexity of content creation and delivery, and/or they partition and redirect complexity in different ways. Some systems attempt to be all encompassing – to be the only tool anyone in the organization ever uses to create and deliver content. Others are designed to work in concert with other tools. Some are more <phrase><annotation type="concept">frameworks</annotation></phrase> than tools, platforms on which you can construct your own content management functionality. All of them implement some form of structured writing for at least some of their functions, some in the media domain, some in the document domain with more or less of the management domain mixed in. Some work with, or at least support certain management functions for, the <phrase><annotation type="concept">subject domain</annotation></phrase>.</p>
<p>If you use a <phrase><annotation type="tool">content management system</annotation></phrase>, it is important to understand how the partitioning and redistribution of complexity that the CMS is designed to do fits with the partitioning and redistribution that you are planning to do in your content system. If the two are not a good match, additional complexity will be created, and some of the complexity you are seeking to manage will be dropped and fall down to the reader.</p>
<p>While content management, which is the partitioning and redirection of complexity in the content system, is actually concerned with the whole of the content problem, when we speak of content management systems specifically we are mainly talking about two problems:</p>
<ul>
<li>
<p>Orchestrating content for the <phrase><annotation type="algorithm">publishing</annotation></phrase> process. That is, making sure all the right bits get into the right documents at the right time. In many cases, there is a <phrase><annotation type="tool">workflow</annotation></phrase> aspect to this, making sure that every piece of content is seen, acted on, and or approved by every interested party in the organization prior to release. It may also include <phrase><annotation type="tool">rights management</annotation></phrase> issues, if there are different people with a financial stake in the content who may be entitled to compensation based on its use. These functions are well covered by other works, and I don’t intend to discuss them in any detail here.</p>
</li>
<li>
<p>Orchestrating content for writers during the writing process. For instance, if you are practicing <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase>, writers need to find content to reuse, and a content management system can help. <phrase><annotation type="algorithm">Change management</annotation></phrase> is also a huge part of content management: when a change happens in subject matter or in business requirements, how to you make sure all the necessary content changes are made, and made efficiently?</p>
</li>
</ul>
<section>
<title>Metadata is the foundation of management</title>
<p><phrase><annotation type="tool">Content management system</annotation></phrase> do their job largely through the collection and management of <phrase><annotation type="concept">metadata</annotation></phrase>. Partitioning and redirecting complexity requires a method to pass information between partitions in a reliable way, and that is what structure and metadata do. Metadata provides a record of the identity and status of content. Management actions are actions on metadata: either creating and updating metadata or performing actions (running algorithms) based on metadata. (More on metadata in <citation type = "nameref" value = "chapter.metadata"/>.)</p>
<p>I defined structured writing as writing that not only obeys constraints, but also records the constraints that it follows. The record of those constraints is metadata. In fact, most of the metadata that a content management system manages is simply the record of the constraints that content obeys. This includes much of the metadata related to <phrase><annotation type="tool">workflow</annotation></phrase>, since the workflow requirements of a system are also constraints on the content.</p>
<p>The location of the <phrase><annotation type="concept">metadata</annotation></phrase> that records the identity and status of the content and the constraints it obeys, differs from one structured writing domain to another. The <phrase><annotation type="concept">media domain</annotation></phrase> captures virtually no <phrase><annotation type="concept">metadata</annotation></phrase> that is useful for <phrase><annotation type="algorithm" specifically="content management algorithm">content management</annotation></phrase>, the <phrase><annotation type="concept">document domain</annotation></phrase> captures some, but not enough, and the <phrase><annotation type="concept">subject domain</annotation></phrase> often captures almost everything your may need, except perhaps for <phrase><annotation type="tool">workflow</annotation></phrase> information. (Though workflow information is <phrase><annotation type="concept">management domain</annotation></phrase> data and there is nothing to prevent you from adding those structures to your <phrase><annotation type="concept">document domain</annotation></phrase> or <phrase><annotation type="concept">subject domain</annotation></phrase> content if you want to.)</p>
<p>Where the content does not contain the metadata necessary for management, the <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> has to gather and store it separately. This naturally adds complexity to the CMS interface, a complexity that is a major source of pain for many users. This also illustrates that the kind of CMS you need for content in different domains can vary significantly. In the case of CMSs that are designed to be the only tool you use, this generally means that the structured writing format is baked in and can only be changed in limited ways, if at all. A transfer of metadata from the CMS to the structures of the content would involve a major reconfiguration of the entire CMS. If you buy this kind of system, therefore, you need to look at the total picture – how it partitions and redistributes all of the complexity of the content systems, and what complexity, if any, it neglects and lets fall through. There will likely be little you can do to change the partitioning or distribution after the fact, so you better make sure it is what you want going in.</p>
<p>Most off-the-shelf <phrase><annotation type="tool">content management systems</annotation></phrase> are designed for <phrase><annotation type="concept">media domain</annotation></phrase> or basic <phrase><annotation type="concept">document domain</annotation></phrase> content. This makes sense from a commercial point of view because it allows them to develop their own <phrase><annotation type="concept">metadata</annotation></phrase> scheme and associated <phrase>management</phrase> algorithms independent of the content that will be stored. This means they can be sold to a wider variety of clients and also that they can advertise that they have simple editors or work with the editors that people already have. The problem with this model, in terms of developing a comprehensive solution for managing complexity across the content system, is that it draws a hard line between the <phrase>management</phrase> going on in the CMS and any type of <phrase>management</phrase> or constraint you may wish to impose on the <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> process. This means that algorithms that depend on the consistency of content or its relationships with other content are largely unsupported by the CMS, and there is no integration between those algorithms and the algorithms preformed by the CMS. The result is often that a lot of complexity gets dropped due to this lack of integration and falls through to the reader.</p>
<p>Other CMSs are built for more complex <phrase>document </phrase>domain languages, which typically means that they are built to support the specific <phrase><annotation type="concept">management domain</annotation></phrase> features of those languages. By far the most common instances of such systems today are based on <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>. Typically, such systems are specific to the one language they support and are sold as such: a DITA CMS or an <phrase>S1000D</phrase> CMS.</p>
<p>You might expect that the principal type of metadata contained in a CMS would be <phrase><annotation type="concept">management domain</annotation></phrase> metadata. After all, we described the management domain as an intrusion into the structured writing world, since it does not actually describe the structure of content. The reason for the intrusion of the <phrase><annotation type="concept">management domain</annotation></phrase> into content is to allow for the management of the content below the level of whatever file or chunk size you store in the CMS.<citation type = "idref" value = "XMLDatabase"/></p>
<footnote id ="XMLDatabase">
<p>In some CMSs, this distinction between the chunk stored in the <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> and the structures expressed inside that chunk is moot. A CMS based on a native <phrase><annotation type="tool">XML database</annotation></phrase>, for instance, makes no distinction between the chunk and the structure of the chunk, but treats the entire <phrase><annotation type="tool">repository</annotation></phrase> as a single XML resource that it can query and manage down to any level of granularity. Even with such a system, however, this distinction remains for the writer, who has to deal with the structure of whatever sized chunk of content they are being asked to write.</p>
</footnote>
<p>But while you will rarely find much in the way of <phrase><annotation type="concept">media domain</annotation></phrase> or <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> stored at the <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> level, CMSs often contain a great deal of <phrase><annotation type="concept">subject domain</annotation></phrase> metadata. If you are managing a large volume of content, you will need some way to find content on a particular subject. If you are doing <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase>, for example, you will constantly be asking if content already exists on the subject you are preparing to write about. If your CMS is managing the delivery of content dynamically to the Web, it will need to respond to queries based on subject matter. And if you are optimizing your content for <phrase><annotation type="concept">search</annotation></phrase> you will need to provide the search engine with subject <phrase><annotation type="concept">metadata</annotation></phrase> in the form of keywords or <phrase><annotation type="structure">microformats</annotation></phrase>. All of this depends on <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase>. Subject domain metadata is therefore central to CMS operations.</p>
</section>
<section>
<title>The location of metadata</title>
<p>It is a very common pattern for a <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> to store <phrase><annotation type="concept">document domain</annotation></phrase> or <phrase><annotation type="concept">media domain</annotation></phrase> content and attach <phrase><annotation type="concept">subject domain</annotation></phrase> metadata to it as an external label. For instance, a CMS might store recipes written in <phrase><annotation type="language">MarkDown</annotation></phrase> and attach separate <phrase><annotation type="concept">metadata</annotation></phrase> records to each recipe listing the key recipe metadata needed for retrieval and sorting of recipes. One of the things that writers often complain about with CMS systems is that they are not allowed to submit content to the system without filling out complicated metadata records.</p>
<p>An alternative approach would be to write recipes in a <phrase><annotation type="concept">subject domain</annotation></phrase> format in which all the recipe <phrase><annotation type="concept">metadata</annotation></phrase> is included in the content from the beginning. The <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> then requires no external metadata label, though it does obviously require a way to access and query the metadata embedded in the content. (CMSs based on <phrase><annotation type="tool">XML databases</annotation></phrase> often have this capability as a natural consequence of the XML database architecture.)</p>
<p>Which approach is preferable? The conventional CMS approach arises because most CMS’s are based on relational databases, which are good at storing metadata records and attaching them to blobs of text, but are not good at storing or querying the <phrase><annotation type="concept">hierarchical structure</annotation></phrase> of structured content. It has several disadvantages, all of which introduce complexity which is often not well handled.</p>
<ol>
<li>
<p>It can only record the characteristics of a chunk of content as a whole. It cannot look down into the content to find more fine grained <phrase><annotation type="concept">metadata</annotation></phrase>. One of the advantages of writing a recipe is the <phrase><annotation type="concept">subject domain</annotation></phrase> is that it allows you to do things like querying the collection of recipes for all those with a calorie count below 100. But unless the metadata record for the recipe includes that level of detail, the <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> cannot respond to that <phrase><annotation type="tool">query</annotation></phrase>. And if the CMS does store that level of detail, it is effectively asking the writer to write the entire content twice, once in the <phrase><annotation type="concept">document domain</annotation></phrase> and once in the <phrase><annotation type="concept">subject domain</annotation></phrase>. Not only is this more work, it is quite likely that the two versions will fall out of sync with each other.</p>
</li>
<li>
<p>It gives no support for <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> of the content. It does nothing to help improve content quality. By requiring <phrase><annotation type="concept">document-domain</annotation></phrase> content as the storage format, it precludes the use of the <phrase><annotation type="concept">subject domain</annotation></phrase> for writing and cuts you off from all the advantages it provides.</p>
</li>
<li>
<p>The system has no way of telling if the content <phrase><annotation type="algorithm" specifically="conformance algorithm">conforms</annotation></phrase> to its constraints. It records the content constraints in a separate record without ever validating that the content meets them.</p>
</li>
<li>
<p>It separates the <phrase><annotation type="concept">metadata</annotation></phrase> from the content is describes. This allows for drift between the content and the metadata.</p>
</li>
</ol>
<p>But storing <phrase><annotation type="concept">metadata</annotation></phrase> in the content presents some challenges as well. Having each piece of content stored in the subject domain makes a lot of sense from a semantic point of view and makes it easy to submit content, since no additional metadata forms have to be filled out. The problem is how to retrieve it. A CMS is essentially a database, and the way you retrieve information from a database is to write a <phrase><annotation type="tool">query</annotation></phrase>. A query is different from a <phrase><annotation type="concept">search</annotation></phrase>. A search is fuzzy. A <phrase><annotation type="tool">search engine</annotation></phrase> takes a plain text question or search phrase and tries to figure out which documents are the best match. Search engines may be powerful and sophisticated, but their results are essentially a sophisticated mechanical guess, and sometimes they get it wrong. Ask a search engine for a list of recipes with less than 100 calories, and it will give you a bunch of guesses based mostly on the plain text of those documents. Chances are it will catch some, miss others, and give you some false hits.</p>
<insert item ="../graphics/search.xml" type ="image"/>
<p>A <phrase><annotation type="tool">query</annotation></phrase>, on the other hand, is a precise request for items whose <phrase><annotation type="concept">metadata</annotation></phrase> precisely matches specified criteria. If you write a query to return recipes for which the value of the field <code>recipe/nutrition/calories</code> is less than 100, it will return all the results, miss none, and give you no false hits. However, it will work only for content that is stored that way. To write that query, you will need to know exactly how recipes are stored in the system.</p>
<insert item ="../graphics/query.xml" type ="image"/>
<p>If you have many different content structures in your repository, you will need to know how each of them is structured in order to create the <phrase><annotation type="tool">queries</annotation></phrase> to return them. This is not the end of the world. <phrase><annotation type="role">Information architects</annotation></phrase> and <phrase><annotation type="role">content engineers</annotation></phrase> can save writers from having to remember how to do all of the queries by creating saved queries that they can run at any time. But is is still a complicating factor.</p>
<p>In the end there is no way around this. Accurate reliable <phrase><annotation type="tool">queries</annotation></phrase> depend on precise consistent <phrase><annotation type="concept">metadata</annotation></phrase>. Precise consistent metadata is specific to the object it belongs to. There is no such thing as a generic metadata record. They are always specific to the things they describe. Subject domain metadata is specific to its subject. If you want to be able to find all recipes with calorie counts less than 100, you need recipe-specific metadata that specifically records the number of calories in the recipe. If you want to find a used car listing for a blue convertible, you need metadata that specifically records the car color and body style. There is no generic metadata format that supports both these queries. The inherent variability of content means no generic query system is possible. The trick is to find the right balance and to make you content as queryable as possible.</p>
</section>
<section>
<title>Managing the process</title>
<p>When we create an individual piece of content for one-time publication in a single media, there is really not much of a role for management in the process. <phrase><annotation type="algorithm" specifically="content management algorithm">Content management</annotation></phrase> becomes a concern when you want to manage the production and <phrase><annotation type="algorithm">publishing</annotation></phrase> of many pieces of content, to manage the relationship between them, ensure consistency and quality, or to publish them many times in different ways.</p>
<p>Of course, many of the reasons we have looked at for moving content from the <phrase><annotation type="concept">media domain</annotation></phrase> to the <phrase><annotation type="concept">document domain</annotation></phrase> or the <phrase><annotation type="concept">subject domain</annotation></phrase> have to do with managing the production and publishing process. But managing a body of content and the processes and tools that create and process that content, requires a whole set of <phrase><annotation type="concept">metadata</annotation></phrase> of its own.</p>
<p>Structured writing is about imposing constraints on content. Content management is about imposing constraints on the content process. But it is also about managing the constraints we impose on content.</p>
<p>Doing structured writing requires recording content in <phrase><annotation type="concept">media domain</annotation></phrase>, <phrase><annotation type="concept">document domain</annotation></phrase> or <phrase><annotation type="concept">subject domain</annotation></phrase> structures, factoring out invariants into separate files, expressing constraints, and creating algorithms to translate the content to the <phrase><annotation type="concept">media domain</annotation></phrase> for <phrase><annotation type="algorithm">publishing</annotation></phrase>. All of this creates a lot of artifacts to keep track of, and requires a process both for keeping track of them and for running the structured authoring and publishing <phrase><annotation type="tool">tool chain</annotation></phrase>. Thus there is a need to manage both the artifacts and the process. But don’t fall into the trap of assuming that this is a generic processes. All these artifacts that require managing are the result of partitioning your content system, and how they should be managed is determined by how the partitions communicate with each other. This is specific to the overall partitioning strategy of your particular content system. You need to find a tool that fits that partitioning strategy.</p>
<p>A common mistake is to focus on some <phrase>management</phrase> problem and simply push out the related complexity to some other function. For instance, the heavy use of <phrase><annotation type="concept">management domain</annotation></phrase> markup can solve a bunch of management problems, but it pushes a lot of management complexity onto the writer, which they may not be able to handle without compromising <phrase><annotation type="algorithm">quality</annotation></phrase>. Nowhere is it more important to take an holistic approach than in the selection of your approach to content management and the tools you choose to implement it.</p>
</section>
<section>
<title>Conflicting constraints</title>
<p>The constraints you use to partition the content management problem may not always be the same as those you would implement to improve content quality. You may find your <phrase>management</phrase> goals at odds with your <phrase><annotation type="concept">rhetorical</annotation></phrase> goals. It is easier to manage content (or anything else) if it is more uniform. The constraints that you will naturally wish to impose to make content more manageable are those that make it more uniform. Thus a system like <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> which, as a starting point, proposes that there are just three types of content (concept, task, and reference) has an obvious appeal from a management point of view. Remember though, that it is the accomplishment of your <phrase><annotation type="concept">rhetorical</annotation></phrase> goals that serves your readers. Your management goals should logically be subservient to your rhetorical goals.</p>
<p>The constraints that you impose to improve content quality are those which make sure that a piece of content does just the job it is supposed to to. They are the kind of constraints that make sure that a recipe contains everything a recipe needs and is presented in the way a recipe should be presented. They are highly specific to the subject matter and to the audience. Three generic content types are not going to provide all the constraints we need to effectively manage content <phrase><annotation type="algorithm">quality</annotation></phrase>. Indeed, some of the constraints that are designed to facilitate content management may be positively damaging to content quality.</p>
<p>But while uniformity might be the approach you would naturally choose if you merely set out to implement a content management system – if improved content <phrase><annotation type="algorithm">quality</annotation></phrase> were not one of your business goals – I would argue that managing <phrase><annotation type="concept">subject domain</annotation></phrase> content may actually lead to better content management in the long run.</p>
<p>In any system that relies on constraints, on data that is known to meet certain constraints, it is necessary to make sure that the constraints are actually being met. This is the role of the <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> and the <phrase><annotation type="algorithm">conformance algorithm</annotation></phrase>. And as we have seen it is often much easier to provide effective <phrase><annotation type="concept">guidance</annotation></phrase> and perform effective <phrase><annotation type="algorithm">validation</annotation></phrase> in the <phrase><annotation type="concept">subject domain</annotation></phrase>. Also, the subject domain allows you to factor out many constraints, which is the most effective way of making sure they are obeyed. The document domain provides far fewer opportunities for factoring out constraints and providing effective guidance and is much more difficult to <phrase><annotation type="algorithm">audit</annotation></phrase> correctly.</p>
<p>Thus while a simple <phrase><annotation type="concept">document domain</annotation></phrase> system of concept, task, and reference <phrase><annotation type="structure">topics</annotation></phrase> meets the content management algorithm’s desire for uniformity, it provides little opportunity for ensuring that the full range of constraints necessary to make content management and reuse work are actually followed. The result can be deterioration of the quality of the content set over time, a process that tends to be self perpetuating, as disorder in current content makes it harder to impose order on new content. (Just as you cannot put things away neatly in a messy drawer.)</p>
<p>The variety of constraints and formats found in a <phrase><annotation type="concept">subject-domain</annotation></phrase> system may present a greater <phrase><annotation type="algorithm" specifically="content management algorithm">content management</annotation></phrase> challenge initially, but it can go a very long way to ensuring that the necessary constraints are met. And, as we have seen, you can often use <phrase><annotation type="concept">subject domain</annotation></phrase> structures to factor out <phrase><annotation type="concept">management domain</annotation></phrase> concerns}<citation type = "nameref" value = "chapter.management-domain"/>, which can go along way to removing the conflict between <phrase><annotation type="algorithm">quality</annotation></phrase> structures and <phrase>management</phrase> structures in content. This not only leads to more effective management, but also to a simpler writing experience.</p>
</section>
<section>
<title>Creating manageable content</title>
<p>We saw with the <phrase><annotation type="algorithm">conformance algorithm</annotation></phrase> that the key to conformance was to create structures that are easy to conform to. The <phrase><annotation type="algorithm">content management algorithm</annotation></phrase> relies heavily on the conformance algorithm. Successful management of content depends on knowing exactly what assets you are managing. The more you know about each asset, and the more reliable what you know about that asset is, the more confidently you can manage it, and the less likely the management system is to slowly descend into chaos.</p>
<p>What this means is that the content management algorithm depends on content that is easy to manage. It may seem like simple generic units of content would be the easiest to manage, but the problem with such generic units is that you know very little about them and what you do know is often unreliable. Generic units may be easy to create and easy to store, but they are not easy to manage. It may require more initial though and effort to plan for the management of highly specific well constrained content units, but such units will in fact prove to be the easiest to manage over time, especially as your content set grows.</p>
</section>
</chapter>
