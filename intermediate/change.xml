<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.change">
<title>Change management</title>

<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="process">conformance</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforming</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> <phrase><annotation type="process">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<index>
<record>
<type>concept</type>
<term>change</term>
</record>
<record>
<type>algorithm</type>
<term>change management</term>
</record>
</index>
<p>The subjects you write about change all the time. Keeping content in sync with changing subject matter and changing requirements is a major process challenge for all content organizations. Structured writing can do a lot to partition and redirect change and the consequences of change.</p>
<p>Content changes for many reasons. For our purposes it is useful to consider the following sources of change:</p>
<ll>
<li>
<label>Subject matter changes</label>

<p>Content has to change when the subject matter – the real world stuff that it describes – changes.</p>
</li>
<li>
<label>Rhetorical changes</label>

<p>Content may also change because you decide to express ideas differently. For instance, you may discover way to present a certain class of content that works better for readers and decide to change all existing instances of that class to fit the new structure. And, as we have seen, outputting to new media requires new rhetoric.</p>
</li>
<li>
<label>Formatting changes</label>

<p>Content may change because you want to format it differently, either to support new media or to re-brand.</p>
</li>
<li>
<label>Externally-driven changes</label>

<p>Content may change because of changes external to itself, its style, and its subject matter. For instance, if an item links to another item and that item is removed and replaced with something different, you have to change every item that links to the changed item, even if the subject matter and style of those items has not changed at all.</p>
</li>
</ll>
<p>One important motivation for adopting structured writing is what is often called <phrase><annotation type="concept">future proofing</annotation></phrase>. <phrase><annotation type="concept">Future proofing</annotation></phrase> means building a system or product with a view to making it able to survive future changes in environments or requirements. Future proofing is difficult because you cannot know with certainty what changes will occur, how likely they are, or what they will cost.</p>
<p>Building a future-proof platform can increase up-front costs, delaying time to market and possibly causing you to miss a window of opportunity. And you cannot be sure that your investment will ever pay off, since the future you prepared for may not be the future you get.</p>
<p>But if you do not build a future-proof platform, you may not be able to keep up with market developments, causing you to lose an early lead. And you may be forced to make massive and expensive changes when future events render your current system obsolete. Both problems happened frequently when traditional publication systems were confronted by the rapid rise of the <phrase><annotation type="media">web</annotation></phrase>.</p>
<p>The safest approach to future proofing is not to try to anticipate the particular way in which the future will develop. Instead, create content structures that will be of value no matter what happens in the future. Creating content in the <phrase><annotation type="concept">subject domain</annotation></phrase> is the best way to practice this kind of future proofing, because writing in the subject domain creates <phrase><annotation type="concept">metadata</annotation></phrase> that contains only true statements about the subject matter itself. Those statements will remain true as long as the subject matter remains unchanged. That is as future proof as you can make your content.</p>
<p>For example, suppose you write your ingredient list in <phrase><annotation type="language">reStructuredText</annotation></phrase> as a <phrase><annotation type="structure">table</annotation></phrase>:</p>
<codeblock language="reStructuredText">
======  ========
Item    Quantity
======  ========
eggs    12
water   2qt
======  ========
</codeblock>
<p>Later, if you decide to present ingredients as a <phrase><annotation type="structure">list</annotation></phrase>, you will have to go back to your content and change the markup. Doing this across a whole collection of recipes will be expensive.</p>
<p>Suppose, instead, that you use <phrase><annotation type="concept">subject-domain</annotation></phrase> markup:</p>
<codeblock language="sam">
ingredients:: ingredient, quantity
    eggs, 12
    water, 2qt
</codeblock>
<p>Now, you don’t have to change the content to change the <phrase><annotation type="algorithm">presentation</annotation></phrase>. You just change the <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> to turn an ingredients record set into a list instead of a table. Thus the <phrase><annotation type="concept">subject-domain</annotation></phrase> markup has future proofed your content against this change of presentation. The <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> specified a <phrase><annotation type="structure">table</annotation></phrase>, which is not a truth about the subject matter; it’s a decision about presentation. That decision can change independent of the subject matter. The <phrase><annotation type="concept">subject-domain</annotation></phrase> markup simply specifies that “eggs” is an ingredient and “12” is a quantity. These are truths about the subject matter that will not change. Thus, they are invulnerable to future changes outside of the subject matter itself.</p>
<p>Moving your content from the <phrase><annotation type="concept">media domain</annotation></phrase> to the <phrase><annotation type="concept">document domain</annotation></phrase> provides a degree of future proofing. By factoring out the formatting details, it protects your content against changes in <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> rules such as what font to use for headings. Moving your content from the document domain to the <phrase><annotation type="concept">subject domain</annotation></phrase> provides additional future proofing. By factoring out the content and organization of documents, it allows you to target different publications and create different document designs for different media. For example, it lets you output different beverage suggestions to <phrase><annotation type="italic">Teetotaler's Trumpet</annotation></phrase> and <phrase><annotation type="italic">Wine Weenie</annotation></phrase> without making any changes to your source file.</p>
<p>Throughout this book I have described complexity in terms of decisions. Future proofing content is about making it possible to change decisions with the least cost. The best way to reduce the cost of changing a decision is to factor it out of the content and assign it to an algorithm. You can then change the decision by changing the algorithm. By contrast, changing a decision that has been encoded in the content requires you to find and change every piece of content that is affected.</p>
<p>Structured writing imposes specific structures on content for specific purposes. It does not make content magically immune to change nor does it guarantee that you will not have to rewrite your content or change its structure to accommodate changes in subject matter or business requirements. You can, however, design content structures that help you manage specific, foreseeable changes. If you are lucky, the structures you create may also allow you to adapt content for unforeseen circumstances, particularly if your content is stored in the <phrase><annotation type="concept">subject domain</annotation></phrase>. But this is a bonus. You cannot guarantee any content or structure will work for things you have not foreseen. However, different domains, by their very nature, provide different degrees of future proofing:</p>
<ul>
<li>
<p>Content in the <phrase><annotation type="concept">media domain</annotation></phrase> encodes all, or nearly all, of your content decisions in the content itself. Few if any decisions are factored out into algorithms, and, therefore, the cost of changing these decisions is high.</p>
</li>
<li>
<p>The <phrase><annotation type="concept">document domain</annotation></phrase> factors out most formatting decisions from the content, reducing the cost of changing formatting decisions. But it still encodes all, or nearly all, presentation and rhetorical decisions, meaning changes in those areas are still expensive.</p>
</li>
<li>
<p>The <phrase><annotation type="concept">management domain</annotation></phrase> is a mixed bag. In some cases, it can be used to factor content or data into separate files, which can make that content easier to locate and change. On the other hand, management-domain structures often encode management decisions in the content, meaning you may have to find and change many instances for certain management decision changes. However, management-domain structures at least make the decisions explicit, making them easy to locate.</p>
</li>
<li>
<p>The <phrase><annotation type="concept">subject domain</annotation></phrase> factors out most presentation decisions and many rhetorical and management decisions while isolating and labeling other rhetorical decisions, making it much easier to locate the instances that need to be updated when a change occurs.</p>
</li>
</ul>
<p>Changes in content happen all the time. Many of them are entirely predictable, and you can use structured writing to help manage those changes. For instance, companies re-brand from time to time, which often requires formatting changes for all publications. If your content is in media-domain structures, the effort to change to a new appearance could be significant. However, if your content is in the <phrase><annotation type="concept">document domain</annotation></phrase>, changing to a new appearance is simply a matter of changing the <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase>.</p>
<p>It should be noted, though, that while changing the <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> is less work than changing the formatting of a large body of content, it is also more complex work. It requires a skill set that is not as widely available as the ability to change fonts in a word processor. It also cannot be done incrementally. Once the new algorithm is complete, you can convert all of your content to the new look almost instantly. But until it is complete, no content can be converted. A structured writing system is not something you can set up once and walk away from. If designed properly, it transfers complexity (and therefore decisions) from writers to <phrase><annotation type="role">information architects</annotation></phrase> and <phrase><annotation type="role">content engineers</annotation></phrase>, and, therefore, you need to maintain the availability of those skills to your team. Hiring someone to write a bunch of algorithms and expecting that those algorithms will never need to change ignores where complexity is being directed in your new system.</p>
<p>Moving complexity to algorithms is the heart of the productivity and quality gains that you get from structured writing, but transferring complexity to an algorithm means transferring it to the people who write and maintain your algorithms – your <phrase><annotation type="role">information architects</annotation></phrase> and <phrase><annotation type="role">content engineers</annotation></phrase>. In many cases, your <phrase><annotation type="algorithm">change management</annotation></phrase> strategy will depend on your ability to handle certain kinds of change by updating an algorithm rather than updating thousands of pieces of content. If you have a fixed and invariant tool set, you essentially cut yourself off from the possibility of partitioning complexity, particularly the complexity of change, by updating your tools. This will greatly limit the extent to which you can bring your currently unhandled complexity under management, which in turn limits your ability to improve your rhetoric.</p>
<p>Moving to the <phrase><annotation type="concept">document domain</annotation></phrase> or the <phrase><annotation type="concept">subject domain</annotation></phrase> (or even to a disciplined use of styles in a word processor) will allow you to handle font and layout changes. But what if the re-branding goes further? Suppose it involves changing the names of products or even the company. Should your structured writing approach explicitly support that change? Some organization like to mandate that writers insert a variable rather than the actual name for the company name and all product names. That way, when a product name or the company names changes all you have to do is redefine the variables.</p>
<codeblock language="sam">
We here at &gt;($company-name) do not recommend using 
our product to catch roadrunners. 
</codeblock>
<p>I am skeptical of the value of this practice. Writers must remember to use the variable every time, which interrupts their chain of thought, slows down their writing, and uses up some of their precious attention, thus affecting content quality. And it is virtually impossible to ensure <phrase><annotation type="algorithm">compliance</annotation></phrase>. Writers can forget and write the names out normally, which means that when a change occurs, you have to search for those instances anyway. Then there are issues with historical usage of the names (where you don’t want the change to happen), inflections (if the new or old names end in ‘s'), and articles (if the initial letter changes from consonant to vowel or vice versa).<citation idref="fn.inflection"/></p>
<footnote id="fn.inflection">
<p>These problems occur in English; other languages may have different problems.</p>
</footnote>
<p>Company and product names are distinct strings that are easy to search for when you need to make a change. The overhead of creating and maintaining variables is greater than the overhead of doing a search and replace through the content. Using variables, in other words, creates more complexity than it partitions and transfers. And doing a search and replace allows you to make intelligent choices about historical usage, inflections, and articles. If your content is in text form in a repository that allows you to do a search and replace across multiple files, search and replace is probably easier and more reliable than using variables. And you will need to do search and replace, anyway, if there is a name change that you did not anticipate and, therefore, did not encode in a variable.</p>
<p>However, you may still need some markup for company and product names. You may want to format them differently or link from them to more information about the product or company. Rather than use a variable, I prefer to use an annotation like this:</p>
<codeblock language="sam">
We here at {Acme Corporation}(company) do not recommend 
using our product to catch roadrunners.
</codeblock>
<p>This second approach identifies the words “Acme Corporation” as a company name. Creating this markup requires no extra thought from writers. They do not have to remember what the appropriate variable name is. (They do have to remember <code>company</code> as an annotation type, but that is a type, not an individual name, and if your markup is well designed, your annotation types should be few and memorable.) And the same markup can be used to format the company name and to generate links to information about the company.</p>
<p>This does not guarantee that writers will always remember to add the annotation, or that they will always spell the company name correctly. There is no way to guarantee that writers will always remember a free-floating annotation; the best you can do is make annotations easy to create. However, as discussed in <citation nameref="chapter.audit"/>, you can use the <code>company</code> annotation to find all the phrases marked as company name, sort them, and look for variants. This allows you to go back and fix incorrect spellings. And it allows you to identify the ways in which writers misspell the company name and search your content for those misspellings. This improves your success rate, catching both misspellings and failures to annotate. You should perform this kind of <phrase>content hygiene</phrase> operation regularly. <phrase><annotation type="concept">Subject-domain</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> removes a distraction for writers and makes this operation easier to do. (For more on this, see <citation nameref="chapter.taxonomy"/>.)</p>
<p>At another level, re-branding may require a change in tone or voice. You may decide to go from professional and reserved to friendly and jocular. There is no way, of course, for any structured writing process to recast content from formal to funny. You can’t future proof your content against every kind of change.</p>
<section>
<title>Out with the old, in with the new</title>

<p>One easily overlooked source of change is the ongoing creation of new content and the editing of old content. This is a particular concern with web-based content, because you can add, edit, or delete content at any time. You don’t have to wait for a major publication release to roll out changes. Each can roll out when it is ready.</p>
<p>However, each time you roll out a change, you affect the <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> of the entire content set. Adding, editing, or deleting just one topic can have a widespread impact:</p>
<ul>
<li>
<p>There may be topics that link to the deleted topic.</p>
</li>
<li>
<p>There may be topics that should link to a newly added or changed topic.</p>
</li>
<li>
<p>There may be topics that should no longer link to a changed topic.</p>
</li>
<li>
<p>Topics in a category may now have a new neighbor or may have lost one.</p>
</li>
<li>
<p>Any <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> navigation tools need to be updated for the topic changes.</p>
</li>
<li>
<p>Deleted topics may leave holes in the information set that need to be filled.</p>
</li>
<li>
<p>New topics or edited topics may mention subjects that are not adequately covered by existing topics, revealing the need for yet more topics.</p>
</li>
<li>
<p>Deleted or edited topics may leave other topics orphaned, needing to be removed or edited to serve a current purpose.</p>
</li>
<li>
<p>Events in the world can change the status of a whole set of topics; for instance, an upcoming event becomes a previous event the moment it has taken place.</p>
</li>
</ul>
<p>When adding, editing, or deleting a topic can have ripple effects through the whole content set, and when these additions, deletions, and edits happen on a daily basis, it is vital to have algorithmic support for change management. Managing all the effects by hand is doomed to failure.</p>
<p><phrase><annotation type="tool">Content management systems</annotation></phrase> often have change management features that can be helpful. For instance, many of them will inform you if changing or deleting an existing <phrase><annotation type="structure">topic</annotation></phrase> will break existing <phrase><annotation type="structure">links</annotation></phrase>. They will also help you find topics on related subjects or manage the membership of <phrase><annotation type="concept">categories</annotation></phrase> and the navigation aids that are based on them.</p>
<p>What they won’t do is tell you things such as which pieces of existing content should be linking to the new content you just added. The only way to discover that is if the existing content contains subject-domain annotations that relate to the subject for the new topic. With these in place, a linking algorithm (as described in <citation nameref="chapter.linking"/>) can discover these relationships automatically.</p>
<p>As should be coming clear by this point, change management is an aspect of all the structured writing algorithms. For any algorithm to keep working over time, and as content changes, the structures that support those algorithms have to stay <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase>. Therefore, as you design structures, you should be thinking seriously about what it will take to maintain them in a conformant state when changes happen.</p>
<p>Change management, therefore, relies heavily on <phrase><annotation type="process">conformance</annotation></phrase> to constraints and to the structures that express those constraints. This is a reciprocal relationship. To ensure that your content remains conformant, you must manage change successfully. But to manage change successfully, you need content to be conformant, so you can reliably identify required changes and, as far as possible, execute them algorithmically.</p>
<p>For example, consider a movie review site that contains movie reviews as well as biographies of actors and directors. Suppose you have a review of <phrase><annotation type="italic">Rio Bravo</annotation></phrase> marked up like <citation idref="fig.review-bio"/>.</p>
<figure id="fig.review-bio">
<title>Movie review for <phrase><annotation type="italic">Rio Bravo</annotation></phrase></title>

<codeblock language="sam">
movie-review:
    movie-title: Rio Bravo
    review-text:
        In {Rio Bravo}(movie), {the Duke}(actor "John Wayne") 
        plays an ex-Union colonel.
</codeblock>
</figure>
<pagination-tweak>
<min-space>2in</min-space>
</pagination-tweak>
<p>At first, you do not have a biography for John Wayne on your site, so none of the reviews that mention John Wayne have a link to a biography. Then, you add a John Wayne biography to your collection (see <citation idref="fig.wayne-bio"/>):</p>
<figure id="fig.wayne-bio">
<title>Markup for a biography of John Wayne</title>

<codeblock language="sam">
topic: 
    title: Biography of John Wayne
    index:
        type: actor
        value: John Wayne
    body:
    
        John Wayne was an American actor known for westerns.
</codeblock>
</figure>
<p>Now, every movie review that mentions John Wayne in the text or lists him as a star should <phrase>link</phrase> to this biography. That might be fifty pages of your site that now should link to the topic you just added. That is a lot of change to process just because of one added page. However, if you used the <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> technique described in <citation nameref="chapter.linking"/>, which is based on <phrase><annotation type="structure">subject annotations</annotation></phrase>, then all you have to do is rebuild your content set, and those links will be created automatically. There is no separate change management step required to create those links. That step has been entirely factored out.</p>
<p>As I noted in <citation nameref="chapter.conformance"/>, the heart of <phrase><annotation type="process">conformance</annotation></phrase> is designing structures that are easy to conform to. Change management is not something you can tack on as an afterthought, but nor is it something that necessarily requires a separate set of structures. Content that is highly <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> and highly <phrase><annotation type="algorithm">auditable</annotation></phrase> is easy to change consistently, which in turn helps maintain conformance. The heart of the problem lies in designing content for conformance.</p>
</section>
</chapter>
