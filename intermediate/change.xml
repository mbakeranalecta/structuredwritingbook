<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.change">
<title>Change management</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="process">conformance</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforming</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> <phrase><annotation type="process">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<index>
<record>
<type>concept</type>
<term>change</term>
</record>
<record>
<type>algorithm</type>
<term>change management</term>
</record>
</index>
<p>The things we write about change all the time. Keeping content in sync with changing subject matter and changing requirements is a major process challenge for all content organizations. Structured writing can do a lot to partition and redirect change and the consequences of change.</p>
<p>Content changes for many reasons. For our purposes it is useful to consider the following sources of change:</p>
<ll>
<li>
<label>Subject matter changes</label>
<p>Content has to change when the subject matter – the real world stuff that it describes – changes.</p>
</li>
<li>
<label>Rhetorical changes</label>
<p>Content may also change because we decide to express ideas differently. For instance, we may discover a better way to present a certain class of content so that it works better for the reader, and then decide to change all existing instance of that class to fit the new structure.</p>
</li>
<li>
<label>Formatting changes</label>
<p>Content may change because you want to format it differently, either to support a new media or to respond to a rebranding.</p>
</li>
<li>
<label>Externally-driven changes</label>
<p>Content may change because of changes external to itself, its style, and its subject matter. For instance, if a item contains a link to another item and that item is removed and replaced with something new and different, you have to change the link in every item that links to it, though the subject matter and style of those items has not changed at all.</p>
</li>
</ll>
<p>One important motivation for structured writing is what is often called “future proofing”. <phrase><annotation type="concept">Future proofing</annotation></phrase> means building a system or product with a view to making it able to survive future changes in environments or requirements. Future proofing is difficult because you cannot know with certainty what changes will occur, how likely they are, or what they will cost.</p>
<p>Building a future proof platform can increase up-front costs, delaying the time it takes to get to market and possible missing a window of opportunity. Nor can you be sure that your investment will every pay off, since the future you prepared for may not be the future you get.</p>
<p>But not building a future proof platform can result in your not being able to keep up with developments in a market and losing your early lead. It may require massive and expensive changes when future events render your current system obsolete. Instances of both problems abounded when traditional publication systems were confronted with the rapid rise of the <phrase><annotation type="media">Web</annotation></phrase>.</p>
<p>The safest approach to future proofing is not to try to anticipate the particular way in which the future will develop, but to create content structures that will be of value no matter what happens in the future. Creating content in the <phrase><annotation type="concept">subject domain</annotation></phrase> is the best way to practice this kind of future proofing, because writing in the subject domain creates <phrase><annotation type="concept">metadata</annotation></phrase> that contains only true statements about the subject matter itself. Those statements are going to remain true as long as the subject matter itself remains unchanged. That is as future proof as you can make your content.</p>
<p>For example, suppose you write your ingredient list in <phrase><annotation type="language">reStructuredText</annotation></phrase> as a <phrase><annotation type="structure">table</annotation></phrase>:</p>
<codeblock language="reStructuredText">

======  ========
Item    Quantity
======  ========
eggs    12
water   2qt
======  ========
</codeblock>
<p>Later you decide that you want to present ingredients as a <phrase><annotation type="structure">list</annotation></phrase> instead. To do this, you will have to go back to your content and change the markup. Doing this across a whole collection of recipes will be expensive.</p>
<p>Suppose instead that you use <phrase><annotation type="concept">subject domain</annotation></phrase> markup:</p>
<codeblock language="sam">

ingredients:: ingredient, quantity
    eggs, 12
    water, 2qt
</codeblock>
<p>Now you don’t have to change the content to make the change in <phrase><annotation type="algorithm">presentation</annotation></phrase>. You just change the <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> to turn an ingredients record set into a list instead of a table. Thus the <phrase><annotation type="concept">subject domain</annotation></phrase> markup has future proofed your content against this change of presentation. The <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> specified the use of a <phrase><annotation type="structure">table</annotation></phrase>, which is not a truth about the subject matter but a decision about presentation that can change independent of the subject matter. The <phrase><annotation type="concept">subject domain</annotation></phrase> markup simply specifies that “eggs” is an ingredient and “12” is a quantity. These are truths about the subject matter that will not change. Thus they are invulnerable to future changes outside of the subject matter itself.</p>
<p>Moving your content from the <phrase><annotation type="concept">media domain</annotation></phrase> to the <phrase><annotation type="concept">document domain</annotation></phrase> provides a degree of future proofing. By factoring out the formatting details, it protects your content against changes in <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> rules such as the font to use for headings. Moving your content from the document domain to the <phrase><annotation type="concept">subject domain</annotation></phrase> provides additional future proofing. By factoring out the content and organization of documents, it allows you to target different publications and to create different document designs for different media. For example, it lets you output different beverage suggestions to <phrase><annotation type="italic">Teetotaler's Trumpet</annotation></phrase> and <phrase><annotation type="italic">Wine Weenie</annotation></phrase> without making any changes to your source file.</p>
<p>Throughout this book I have described complexity in terms of decisions. Future proofing content in essentially about making it possible to change the decisions you have made with the least cost. The best way to reduce the cost of changing a decision is to factor it out of the content and assign it to an algorithm. You can then change the decision by changing the algorithm. By contrast, changing a decision that has been encoded in the content requires finding every piece of content that is affected and changing it individually.</p>
<p>Structured writing imposes specific structures on content for specific purposes. It does not make content magically immune to change nor does it guarantee you will not have to rewrite the content or change the structure to accommodate future changes in your subject matter or your business requirements. You can, however, design your content structures to help you manage specific and foreseeable changes. If you are lucky, the structures you create may also allow you to adapt content for unforeseen circumstances, particularly if your content is stored in the <phrase><annotation type="concept">subject domain</annotation></phrase>. But this is a bonus. You cannot guarantee any content or structure will work for things you have not foreseen. However, different domain, by their very nature, provide different degrees of future proofing:</p>
<ul>
<li>
<p>Content in the <phrase><annotation type="concept">media domain</annotation></phrase> encode all, or nearly all, of your content decision in the content itself. Few if any decisions are factored out into algorithms, and the cost of changing these decisions is therefore high.</p>
</li>
<li>
<p>The <phrase><annotation type="concept">document domain</annotation></phrase> factors out most formatting decisions from the content, reducing the cost of changing formatting decisions. But it still encodes all or nearly all presentation and rhetorical decisions, meaning changes in those areas are still expensive.</p>
</li>
<li>
<p>The <phrase><annotation type="concept">management domain</annotation></phrase> is a mixed bag. In some cases it can be used to factor content or data into separate files which makes that content easier to locate and change. On the other hand, management domain structures often encode management decisions in the content, meaning you may have to find an change many instances for certain management decision changes. (Though at least they make the decisions explicit, making them easy to locate.)</p>
</li>
<li>
<p>The <phrase><annotation type="concept">subject domain</annotation></phrase> factors out most presentation decisions and many rhetorical and management decisions, while isolating and labeling other rhetorical decisions, making it much easier to locate the instances that need to change when a change occurs.</p>
</li>
</ul>
<p>Changes in content happen all the time. Many of them are entirely predictable and you can use structured writing to support the management of those changes. For instance, companies re-brand from time to time, often requiring a change of formatting for all publications. If the content is in media domain structures, the effort to change to a new appearance could be significant. If the content is in the <phrase><annotation type="concept">document domain</annotation></phrase>, however, changing how it is formatted is simply a matter of changing the <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> to produce different-looking output.</p>
<p>It is worth noting, though, that while changing the <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> is less work than changing the formatting of a large body of content, it is also more complex work. It requires a skill set that is not as widely available as the skill of changing fonts in a word processor, for instance. It also cannot be done incrementally. Once the entire new algorithm is written, all the content can be converted to the new look almost instantly. But until it is finished, none of the content can be converted. A structured writing system is not the kind of thing you can set up once and walk away from. If designed properly, it transfers complexity (and therefore decisions) from writers to <phrase><annotation type="role">information architects</annotation></phrase> and <phrase><annotation type="role">content engineers</annotation></phrase> and so you need to maintain the availability of those skill sets to your team. Hiring someone to come in an write a bunch of algorithms for you as if they will never need to change is to ignore where complexity is being directed in your new system.</p>
<p>Moving complexity to algorithms is the heart of the productivity and quality gains that you get from structured writing, but transferring complexity to an algorithm means transferring it to the person who writes and maintains your algorithms – your <phrase><annotation type="role">information architects</annotation></phrase> and <phrase><annotation type="role">content engineers</annotation></phrase>. In many case, the <phrase><annotation type="algorithm">change management</annotation></phrase> strategy you are implementing depends precisely on this: that in the event of a certain kind of change it will be handled by changing a single algorithm rather than by changing thousands of pieces of content. Insisting on a fixed and invariant tool set essentially mean cutting yourself off from the possibility of partitioning complexity, particularly the complexity of change, in this way. This will greatly limit the extent to which you can bring much of your currently unhandled complexity under management, and thus the amount of complexity you can direct away from your readers.</p>
<p>A general move to the <phrase><annotation type="concept">document domain</annotation></phrase> (or the <phrase><annotation type="concept">subject domain</annotation></phrase>, or even a disciplined use of styles in a word processor) will allow you to handle font and layout changes. But what if the re-branding goes further? Suppose it involves changing the names of products or even the company. Should your structured writing approach explicitly support that change? Some organization like to mandate that writers insert a variable rather than the actual name for the company name and all product names. That way, when a product name or the company names changes all you have to do is redefine the variables.</p>
<codeblock language="sam">

We here at &gt;($company-name) do not recommend using 
our product to catch roadrunners. 
</codeblock>
<p>I have always been skeptical of the value of this practice. It forces the writers to remember to use the variable every time. This interrupts their chain of thought, which slows their writing down and uses up some of their precious attention, thus impacting content quality. And it is virtually impossible to ensure <phrase><annotation type="algorithm">compliance</annotation></phrase>. Writers will sometimes simply forget and write the names out normally, which means you always have to search for these instances anyway when a change happens. Then there are issues with historical usage of the names, where you don’t want the change to happen, and with inflections if the new or old names end in ‘s’ (in English; other languages may have different inflection problems).</p>
<p>Company and product names are distinct strings that are easy to search for when you need to make a change. The overhead of creating and maintaining the variables is greater than the overhead of doing a search and replace through the content when a change occurs. The use of variables, in other words, is creating more complexity than it is partitioning and transferring. And doing a search and replace allows you to make intelligent choices about historical usage and  inflections. It your content is held in text form (in a markup language) in a repository (file system or <phrase><annotation type="tool">content management system</annotation></phrase>) that allows you to do a search and replace across multiple files, this is probably easier and more reliable than using variables. (And it is what you are going to have to do anyway if there is a name change that you did not anticipate and therefore did not use variables for.)</p>
<p>You may well need some markup for company and product names, however. You may want to format them differently or link from them to more information about the product or company. Rather than use a variable I would rather use an annotation like this:</p>
<codeblock language="sam">

We here at {Acme Corporation}(company) do not recommend 
using our product to catch roadrunners.
</codeblock>
<p>This second approach identifies the words “Acme Corporation” as a company name. Creating this markup requires no extra thought from the writer. They do not have to remember what the appropriate variable name is. (They do have to remember <code>company</code> as an annotation type, but that is a type, not an individual name, and if your markup is well designed your annotation types should be few and memorable.) And this same markup can be used to format the company name appropriately and to generate links to information on the company.</p>
<p>This does not guarantee that the writer will always remember to add the annotation, or that they will always spell the company name correctly. (There is no way to guarantee that a free-floating annotation will always be remembered. The best you can do is make them easy to do.) But you can use the <code>company</code> annotation to find all the phrases marked as company name, sort them, and look for variants. This then allows you to go back and fix incorrect spellings. But it also allows you to identify the ways in which writers are misspelling the company name and search the whole text for those misspellings. This improves your success rate catching both misspellings and the failure to annotate. This kind of <phrase>content hygiene</phrase> operation should be performed regularly on any content set, and <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> makes it easier to do while removing a distraction for writers. (For more on this, see <citation nameref="chapter.taxonomy"/>.)</p>
<p>At another level, re-branding can involve the organization deciding to change its tone or voice. It may wish to go from professional and reserved to friendly and jocular. There is no way, of course, for any structured writing process to recast content from formal to funny. You can’t make your content proof against every kind of change.</p>
<section>
<title>Out with the old, in with the new</title>
<p>One form of change that is so common that it may be overlooked is simply the ongoing creation of new content and the editing of old content. In the age of the <phrase><annotation type="media">Web</annotation></phrase>, this is a particular concern because we can now add a new piece of content whenever it is ready, edit an existing piece whenever it needs it, and delete an old piece whenever it becomes obsolete. We don’t have to wait for a major publication release for all these changes to roll out. Each rolls out when it is ready. And each time one rolls out, it impacts the <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> of the entire content set.</p>
<p>Adding, editing, or deleting one topic does not mean that all the other topics are unaffected:</p>
<ul>
<li>
<p>There may be topics that link to the deleted topic.</p>
</li>
<li>
<p>There may be topics that should link to the newly added topic.</p>
</li>
<li>
<p>There may be topics that should no longer link to a changed topic, and topics that should now start linking to it.</p>
</li>
<li>
<p>Topics in a category may now have a new neighbor or may have lost one.</p>
</li>
<li>
<p>Any <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> navigation tools need to be updated for the topic changes.</p>
</li>
<li>
<p>Deleted topics may leave holes in the information set that need to be filled.</p>
</li>
<li>
<p>New topics or edited topics may mention subjects that are not adequately covered by existing topics, revealing the need for yet more topics.</p>
</li>
<li>
<p>Deleted or edited topics may leave other topics orphaned, needing to be removed or edited to serve a current purpose.</p>
</li>
<li>
<p>Events in the world can change the status of a whole set of topics, for instance, those relating to an upcoming event which becomes a previous event the moment it has taken place.</p>
</li>
</ul>
<p>When there is the potential for adding, editing, or deleting a topic to have ripple effects through the whole content set, and when such additions, deletions, and edits happen on a daily basis, it is vital to have algorithmic support for change management. Managing all the effects by hand is doomed to failure.</p>
<p><phrase><annotation type="tool">Content management systems</annotation></phrase> often have change management features that can be helpful. For instance, many of them will inform you if a change or deletion of an existing <phrase><annotation type="structure">topic</annotation></phrase> will break any existing <phrase><annotation type="structure">links</annotation></phrase>. They will also help you find topics on related subjects or manage the membership of <phrase><annotation type="concept">categories</annotation></phrase> and the navigation aids that are based on them. What they won’t do is tell you things like which pieces of existing content should be linking to the new content you just added. The only way to discover that is if the existing content contains subject domain annotations that relate to to the subject for the new topic. With these in place, a linking algorithm (as described in <citation nameref="chapter.linking"/>) can discover these relationships automatically.</p>
<p>As should be coming clear by this point, change management is really an aspect of all the structured writing algorithms. For any of the algorithms to keep working over time and as content changes, the structures that support those algorithms have to stay <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase>. Part of designing those structures, therefore, should be thinking seriously about what it will take to maintain them in a conformant state when changes happen.</p>
<p>Change management, therefore, relies heavily on  <phrase><annotation type="process">conformance</annotation></phrase> to constraints and to the structures that express them. And this is a reciprocal relationship. To maintain conformance of your content, you have to be able to manage change successfully. But to manage change successfully, you need content to be conformant so that you can reliably identify the changes that are required and, as far as possible, execute those changes algorithmically.</p>
<p>For example, say you have a movie review site that contains movie reviews as well as biographies of actors and directors. You have a review of <phrase><annotation type="italic">Rio Bravo</annotation></phrase> marked up like this:</p>
<codeblock language="sam">

movie-review:
    movie-title: Rio Bravo
    review-text:
        In {Rio Bravo}(movie), {the Duke}(actor "John Wayne") 
        plays an ex-Union colonel.
</codeblock>
<p>At first, you do not have a biography for John Wayne on your site, so none of the reviews that mention John Wayne have a link to a biography. Then you add a John Wayne biography to your collection:</p>
<codeblock language="sam">

topic: 
    title: Biography of John Wayne
    index:
        type: actor
        value: John Wayne
    body:
    
        John Wayne was an American actor known for westerns.
</codeblock>
<p>Suddenly every movie review that mentions John Wayne in the text or lists him as a star should be <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> to this biography. That might be fifty pages of your site that now should be linking to the topic you just added. That is a lot of change to process just because of one added page. But if you have used the linking technique based on subject annotations, as described in <citation nameref="chapter.linking"/>, then all you have to do is rebuild your content set and those links will be created automatically. There is literally no separate change management step that need needs to be done to get those links. It has been entirely factored out.</p>
<p>As we noted in <citation nameref="chapter.conformance"/>, the heart of <phrase><annotation type="process">conformance</annotation></phrase> is designing structures that are easy to conform to. Change management is not something you can tack on as an afterthought, but nor is is something that necessarily requires a separate set of structures. Content that is highly <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> and highly <phrase><annotation type="algorithm">auditable</annotation></phrase> is easy to change consistently, which in turn help maintain conformance. The heart of the problem lies in designing content for conformance.</p>
</section>
</chapter>
