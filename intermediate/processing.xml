<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.processing">
<title>Processing Structured Text</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="process">conformance</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforming</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> <phrase><annotation type="process">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<index>
<record>
<type>task</type>
<term>processing structured text</term>
</record>
</index>
<p><citation type = "nameref" value = "chapter.separating"/> looked at separating content from formatting. Separating them is necessary to achieving certain rhetorical and process goals. But of course they cannot stay separated. Content must be formatted before you present it to the reader. So let’s look at the algorithm for putting them back together again.</p>
<p>Understanding how to put things back together is a big part of understanding how to separate them. Indeed, describing how you would put them back together is the only way to know for certain that you didn’t lose anything when you did the separation. This is essential to ensuring a clean partitioning that does not allow any complexity to fall through to the reader.</p>
<section>
<title>Two into one: reversing the factoring out of invariants</title>
<p>Moving content from the <phrase><annotation type="concept">media domain</annotation></phrase> to the <phrase><annotation type="concept">document domain</annotation></phrase> or the <phrase><annotation type="concept">subject domain</annotation></phrase> involves progressively factoring out invariants in the content. Each step in this process creates two artifacts: the structured content and the invariant piece that was factored out.</p>
<p>Processing structured text is about putting the pieces back together – combining the structured content with the invariants that were factored out. But processing structured text is also about making and/or executing the decisions that were partitioned away from the writer. These decisions may be invariant, such as applying approved corporate style, or they may be variable, such as presenting content differently in different media or for different audiences. Invariant decisions are always made the same way for a given purpose. They may be made differently for different purposes but still the same way for each purpose.</p>
<p>If factoring out the invariants moves content toward the document or subject domains, recombining the content with the invariants moves it in the opposite direction, toward the media domain. This could mean moving the content from the subject domain to the document domain or from the document domain to the media domain, or simply from a more abstract form in the media domain to a more concrete form, which is our first example.</p>
<pagination-tweak>
<min-space>1.5in</min-space>
</pagination-tweak>
</section>
<section>
<title>Restoring style information</title>
<p>In <citation type = "nameref" value = "chapter.separating"/>, the first example of <phrase><annotation type="concept">separating content from formatting</annotation></phrase> factored out the style information from this structure:</p>
<codeblock>

{font: 10pt "Open Sans"}The box contains:
{font: 10pt "Open Sans"}[bullet][tab]Sand
{font: 10pt "Open Sans"}[bullet][tab]Eggs
{font: 10pt "Open Sans"}[bullet][tab]Gold
</codeblock>
<p>The style information was replaced with style names:</p>
<codeblock>

{style: paragraph}The box contains:
{style: bullet-paragraph}Sand
{style: bullet-paragraph}Eggs
{style: bullet-paragraph}Gold
</codeblock>
<p>And then the styles were defined as follows:</p>
<codeblock>

paragraph = {font: 10pt "Open Sans"}
bullet-paragraph = {font: 10pt "Open Sans"}[bullet][tab]
</codeblock>
<p>To unite each paragraph with the correct style, you can write a set of search-and-replace rules:</p>
<codeblock>

find {style: paragraph}
    replace {font: 10pt "Open Sans"}

find {style: bullet-paragraph}
    replace {font: 10pt "Open Sans"}[bullet][tab]
</codeblock>
<p>This algorithm combines two sources of information: the structured text and the style definitions. Usually, the style definitions are embedded in the rules, as in this example. In some cases, however, the rules may pull content from a separate file. I show examples of this later.</p>
<p>Applying these rules brings back the original content:</p>
<codeblock>

{font: 10pt "Open Sans"}The box contains:
{font: 10pt "Open Sans"}[bullet][tab]Sand
{font: 10pt "Open Sans"}[bullet][tab]Eggs
{font: 10pt "Open Sans"}[bullet][tab]Gold
</codeblock>
<pagination-tweak>
<min-space>1in</min-space>
</pagination-tweak>
<p>If you want to change the styles, you can apply a different set of rules (in other words, make a different set of decisions):</p>
<codeblock>

find {style: paragraph}
    replace {font: 12pt "Century Schoolbook"}

find {style: bullet-paragraph}
    replace {font: 12pt "Century Schoolbook"}[em dash][tab]
</codeblock>
<p>Applying these new rules gives you the following:</p>
<codeblock>

{font: 12pt "Century Schoolbook"}The box contains:
{font: 12pt "Century Schoolbook"}[em dash][tab]Sand
{font: 12pt "Century Schoolbook"}[em dash][tab]Eggs
{font: 12pt "Century Schoolbook"}[em dash][tab]Gold
</codeblock>
</section>
<section>
<title>Rules based on structures</title>
<p>The tools that do this sort of processing do not literally use search and replace like this. Rather, they parse the source document to pull out the structures and allow you to specify your processing rules by referring to those structures.</p>
<p>The mechanism by which a processing tool recognizes structure is less important then what the tool does once it finds a structure. So, the next set of rules matches structures rather than looking for literal strings in the text:</p>
<codeblock>

match paragraph
    apply style {font: 12pt "Century Schoolbook"}

match bullet-paragraph
    apply style {font: 12pt "Century Schoolbook"}
    output "[em dash][tab]"
</codeblock>
<p>The result of applying these rules is the same as before:</p>
<codeblock>

{font: 12pt "Century Schoolbook"}The box contains:
{font: 12pt "Century Schoolbook"}[em dash][tab]Sand
{font: 12pt "Century Schoolbook"}[em dash][tab]Eggs
{font: 12pt "Century Schoolbook"}[em dash][tab]Gold
</codeblock>
<p>The way I have written these rules is an example of <phrase><annotation type="concept">pseudocode</annotation></phrase>. Pseudocode is a means for sketching out an algorithm so you understand what you are trying to do before you write actual code. There is no formal syntax for pseudocode. It is intended for humans, not computers, and you can use whatever approach you like as long as it is clear to your intended audience. However, pseudocode should lay out a set of logical steps for accomplishing something and make it clear how the steps go together.</p>
<p>Writing an algorithm in pseudocode is a great way to make sure you understand the algorithm without worrying about the details of code – or even learning how to code. And algorithms are a great way to tell programmers what you need a program to do.</p>
</section>
<section>
<title>The order of the rules does not matter</title>
<p>You may have noticed that these rules do pretty much exactly what style sheets do in applications such as <phrase><annotation type="tool" specifically="Microsoft Word">Word</annotation></phrase> or <phrase><annotation type="tool">FrameMaker</annotation></phrase>. If you understand style sheets, you understand a good deal of how structured writing algorithms work.</p>
<p>One important thing to notice is that when you create a style sheet in <phrase><annotation type="tool" specifically="Microsoft Word">Word</annotation></phrase> or <phrase><annotation type="tool">FrameMaker</annotation></phrase>, you don’t specify the order in which styles are applied to the document. The same is true when you create a CSS style sheet. The style sheet is just a flat list of rules. The order in which the rules are applied to the document depends entirely on the order in which the various structures occur in the document.<citation type = "idref" value = "fn.priority"/></p>
<footnote id="fn.priority">
<p>Actually, there is a wrinkle to this. It is possible to have more than one rule that could match a particular structure. In this case the language in which the rules are implemented has to decide which rule to pick. There are various mechanism that a language can use to decide which rule to choose, for example, choosing a more specific rule over a more general one. But in some cases, the selection may be based simply on which rule comes first (or last) in the rule set. But this is a minor detail and does not distract from the idea that rules are fundamentally unordered and document driven.</p>
</footnote>
<p>To put it another way, rather than being a set of steps to follow, style-sheet rules define a set of decisions to be made when certain events occur. If you see X, do Y. The structure of the source document determines the order in which the processor applies the rules; the order of the rules in the style sheet doesn’t matter.</p>
<p>This may seem obvious, but it is key to understanding how structured text is usually processed. This can be confusing even to skilled programmers, because style sheets are processed differently from the way most programmers learn to write computer programs.</p>
<p>Things get more complex when you move into processing the nested structures of the <phrase><annotation type="concept">document domain</annotation></phrase> and <phrase><annotation type="concept">subject domain</annotation></phrase>, but the basic pattern of a set of unordered rules to describe a transformation algorithm still applies.</p>
</section>
<pagination-tweak>
<min-space>1.5in</min-space>
</pagination-tweak>
<section>
<title>Applying rules in the document domain</title>
<p>Suppose you have a piece of document-domain structured text that contains this <code>title</code> structure:</p>
<codeblock language="sam">

title: Moby Dick
</codeblock>
<p>You want to transform this document into HTML. When a rule matches a structure in the source document, the processor outputs the equivalent HTML structure. Here is the pseudocode for this rule (it is in a slightly different format from the pseudocode above):</p>
<codeblock language="pseudo">

match title
    create h1 
        continue
</codeblock>
<p>This says, when the processor sees a <code>title</code> structure in the source, it creates an <code>h1</code> structure in the output and then continues applying rules to the content of the title structure.</p>
<p>The <code>continue</code> instruction is indented under the <code>create h1</code> instruction to indicate that the results will appear inside the <code>h1</code> structure. Another way of expressing this would be:</p>
<codeblock language="pseudo">

match title
    &lt;h1&gt;
        continue
    &lt;/h1&gt;
</codeblock>
<p>Again, it does not matter what form you use for your pseudocode as long as you clearly express the decision to make when the event in question occurs.</p>
<p>In this example, the processor outputs the text content of the structure automatically (as is the case in many tools), so the output of this rule (expressed in HTML) is:</p>
<codeblock language="html">

&lt;h1&gt;Moby Dick&lt;/h1&gt;
</codeblock>
<p>But suppose there is another structure inside the title? In this case that structure is an <phrase><annotation type="concept">annotation</annotation></phrase> of part of the title text:</p>
<codeblock language="sam">

title: Review of {Rio Bravo}(movie)
</codeblock>
<p>Here the annotated text is set off with curly braces and the annotation itself is in parentheses immediately after it. (This is a feature of the <phrase><annotation type="language">SAM</annotation></phrase> markup syntax that I use for most of the examples in this book.) This annotation says that the words “Rio Bravo” refer to a movie. The annotation is a content structure, just like the title structure, and is nested inside the text of the title.</p>
<p>So what do you need to do to your <code>title</code> rule to make it handle <code>movie</code> annotations embedded in the title text? Absolutely nothing. Instead, you write a separate rule for handling <code>movie</code> annotations no matter where they occur:</p>
<codeblock language="pseudo">

match movie
    create i
        continue
</codeblock>
<p>When the processor hits <code>continue</code> in the <code>title</code> rule, it processes the content of the title structure. In doing so, it encounters the <code>movie</code> structure and executes the <code>movie</code> rule. The result is output that looks like this:</p>
<codeblock language="html">

&lt;h1&gt;Review of &lt;i&gt;Rio Bravo&lt;/i&gt;&lt;/h1&gt;
</codeblock>
<p>The <code>continue</code> instruction is all you need to add to your rules to allow them to deal with nested structures. The rules remain an unordered collection, just like a style sheet. (In fact, <phrase><annotation type="tool">XSLT</annotation></phrase>, a language that implements this model, calls a set of processing rules a “stylesheet.”)</p>
</section>
<section>
<title>Processing based on context</title>
<p>When you move to the <phrase><annotation type="concept">document domain</annotation></phrase>, you use context to reduce the number of structures you need. For example, where <phrase><annotation type="language">HTML</annotation></phrase> has six different heading structures (<code>H1</code> through <code>H6</code>), <phrase><annotation type="language">DocBook</annotation></phrase> has only one (<code>title</code>), which can occur in many different contexts. So how do you apply the right formatting to a title based on its context? You create a different rule for the <code>title</code> structure in each context. You express the context by listing the parent structure names separated by slashes:</p>
<codeblock language="pseudo">

match book/title
    create h1 
        continue

match chapter/title
    create h2
        continue

match section/title
    create h3 
        continue

match figure/title
    create h4
        continue
</codeblock>
<p>Now here is the clever bit. You don’t have to change the <code>movie</code> rule to work with any of these versions of the <code>title</code> rule. Suppose your title is the title of a section, like this:</p>
<codeblock language="sam">

section:
    title: Review of {Rio Bravo}(movie)
</codeblock>
<p>When you process, the processor will execute the <code>section/title</code> rule to deal with the title structure and the <code>movie</code> rule when the <code>movie</code> structure occurs in the course of processing the content of the <code>title</code> structure. The results are as follows:</p>
<codeblock language="html">

&lt;h3&gt;Review of &lt;i&gt;Rio Bravo&lt;/i&gt;&lt;/h3&gt;
</codeblock>
<p>Here is the basic pattern for most structured writing algorithms:</p>
<ul>
<li>
<p>For each input structure, create a rule that says how to transform that structure into the new structure you want.</p>
</li>
<li>
<p>For each rule, specify the new structure(s) and where to place the content in the new structure(s).</p>
</li>
<li>
<p>For each rule, specify where to process any nested structures. I use the term <code>continue</code> for this function.</p>
</li>
<li>
<p>If you want a different rule for a structure that occurs in different contexts, write a separate rule for each context.</p>
</li>
</ul>
<p>Why is it important to understand this pattern? Because when you abstract out invariants to move content to the <phrase><annotation type="concept">document domain</annotation></phrase> or <phrase><annotation type="concept">subject domain</annotation></phrase>, understanding how those invariants will be factored back in can help you recognize them in your source and give you the confidence to factor them out. Writing pseudocode helps you validate that you have factored out invariants correctly, that the structures are easy to process, and that the processing rules are clear, consistent, and reliable.</p>
<p>Obviously, building a complete processing system is much more complex, and I won’t go into all the details here, but let’s look at a few common cases.</p>
</section>
<section>
<title>Processing container structures</title>
<p>When you move content to the <phrase><annotation type="concept">document domain</annotation></phrase> or the <phrase><annotation type="concept">subject domain</annotation></phrase>, you often create container structures to provide context. These container structures have no media-domain analog, so what do you do with them when you publish? The containers provide context for the rest of your processing rules, but what do you do with the containers themselves?</p>
<p>In the previous example the content was contained in a <code>section</code> structure. So how does the <code>section</code> structure get processed?</p>
<codeblock language="pseudo">

match section
    continue
</codeblock>
<p>Yes, it’s that simple. You don’t output any new structure in its place. The section container has done its work at this point so you simply discard it. You still want what’s inside it, so you use the <code>continue</code> instruction to make sure the contents get processed. But the container is just a box; you unpack the contents and discard the box.</p>
</section>
<section>
<title>Restoring factored-out text</title>
<p>Sometimes when you factor out invariants, you not only factor out styles, you also factor out text. To process the content, you need to restore the text (obviously you can restore different text if you need to, which is why you factored it out in the first place).</p>
<p>As we saw in <citation type = "nameref" value = "chapter.separating"/>, a simple example of factoring out text is numbered and bulleted lists, where you factor out the text of the numbers and bullets. Let’s look at how you create rules to put them back.</p>
<p>Suppose you have a document that contains these two different kinds of lists:</p>
<codeblock>

paragraph: To wash hair:
ordered-list:
    list-item:Lather
    list-item:Rinse
    list-item:Repeat
    
paragraph: The box contains:
unordered-list:
    list-item:Sand
    list-item:Eggs
    list-item:Gold
</codeblock>
<p>Let’s write a set of rules to deal with this document. Converting this to HTML lists isn’t very interesting, since HTML handles list numbering and bullets itself. Instead, let’s create instructions for printing on paper. Real printing instructions get tediously detailed, so let’s use the same style specification shorthand used earlier. The <code>paragraph</code> rule is simple enough:</p>
<codeblock>

match paragraph
    apply style {font: 10pt "Century Schoolbook"}
    continue
</codeblock>
<p>Now let’s deal with the <code>ordered-list</code>. The ordered list structure is just a container, so you don’t need to create an output structure for it. But because this is an ordered list, you need to start a count to number the items in the list. That means you need a variable to store the current count. The <code>$</code> prefix indicates that you are creating a variable:</p>
<codeblock>

match ordered-list
    $count=1
    continue
</codeblock>
<p>Then, the rule for each ordered list item outputs the value of the variable <code>$count</code> and increments it by one:</p>
<codeblock>

match ordered-list/list-item
    apply style {font: 12pt "Century Schoolbook"}
    output $count
    output ".[tab]"
    $count=$count+1
    continue
</codeblock>
<p>Every time the <code>ordered-list/list-item</code> rule is executed, the count increases by one, numbering the list items sequentially.</p>
<p>When the processor encounters a new numbered list, it executes the <code>ordered-list</code> rule, which resets <code>$count</code> to 1.</p>
<p>This rule does not match <code>list-item</code> elements that are children of an <code>unordered-list</code> element, so you need a separate set of rules for unordered lists:</p>
<codeblock language="pseudocode">

match unordered-list
    continue
    
match ordered-list/list-item
    apply style {font: 12pt "Century Schoolbook"}
    output "[em dash][tab]"
    continue
</codeblock>
<p>Applying the combined set of rules produces output like this:</p>
<codeblock>

{font: 10pt "Century Schoolbook"}To wash hair:
{font: 10pt "Century Schoolbook"}1.[tab]Lather
{font: 10pt "Century Schoolbook"}2.[tab]Rinse
{font: 10pt "Century Schoolbook"}3.[tab]Repeat           
{font: 10pt "Century Schoolbook"}The box contains:
{font: 10pt "Century Schoolbook"}[em dash][tab]Sand
{font: 10pt "Century Schoolbook"}[em dash][tab]Eggs
{font: 10pt "Century Schoolbook"}[em dash][tab]Gold
</codeblock>
<p>This process flattens the structure and removes the document-domain containers. You are back in the media domain, with a flat structure that specifies formatting and text.</p>
</section>
<section>
<title>Processing in multiple steps</title>
<p>You may not always want to apply final formatting to your content in a single step. When you separated content from formatting, you did the separation in several stages. You may want to put them back together in several stages. This not only results in simpler, easier-to-maintain algorithms, it can make it possible for you to reuse some of the downstream steps (nearer the media domain) for different types of document-domain and subject-domain content.</p>
<p>So far the examples have come from the <phrase><annotation type="concept">media domain</annotation></phrase> and the <phrase><annotation type="concept">document domain</annotation></phrase>. Here is a <phrase><annotation type="concept">subject-domain</annotation></phrase> example that builds on <citation type = "nameref" value = "ex.separate-1"/>, which moved a labeled list from the document domain to the subject domain.</p>
<codeblock language="sam">

address:
    street: 123 Elm Street
    town: Smallville
    country: USA
    code: 12345
</codeblock>
<p>Moving this content back to the document domain should make it look like this:</p>
<codeblock language="sam">

labeled-list:
    list-item:
        label: Street
        contents: 123 Elm Street
    list-item:
        label: Town
        contents: Smallville
    list-item:
        label: Country
        contents: 123 USA
    list-item:
        label: Code
        contents: 12345
</codeblock>
<p>Here is the set of rules to accomplish this transformation:</p>
<codeblock>

match address
    create labeled-list
        continue
    
match street
    create list-item 
        create label 
            output "Street"
        create contents
            continue
                
match town
    create list-item 
        create label 
            output "Town"
        create contents
            continue

match country
    create list-item 
        create label 
            output "Country"
        create contents
            continue

match code
    create list-item 
        create label 
            output "Code"
        create contents
            continue
</codeblock>
<p>Notice that the label text, which you factored out when you moved to the subject domain, is being factored back in and is specified in the processing rules. As you moved the content from the media domain to the document domain to the subject domain, you first factored out invariant formatting and then invariant text. In the algorithms, you put back the text and the formatting, each at a different processing stage. (Or different label text, of course, if you want to change the presentation decisions.)</p>
<p>Processing content in multiple steps can save you a lot of time. The <phrase><annotation type="concept">subject-domain</annotation></phrase> <code>address</code> structure is specific to a single subject, and you might have similar structures for different subjects in your subject-domain markup. However, you might choose to present those different subjects using the same <code>labeled-list</code> structure. Since a labeled list is a <phrase><annotation type="concept">document-domain</annotation></phrase> structure that can be used to present all kinds of information and formatted for many different media, you don’t have to write any code to format the <code>address</code> structure – or any of the similar structures – directly. You can format them all correctly for multiple media using the existing <code>labeled-list</code> formatting rules.</p>
</section>
<section>
<title>Query-based processing</title>
<p>The rule-based approach shown here is not the only way to process structured writing. There is another approach that I call the query-based approach.<citation type = "idref" value = "1"/> In this approach, you write a query expression that reaches into the structure of a document and pulls out a structure or a set of structures from the middle of the document.</p>
<p>This is a useful technique if you want to radically rearrange the content of a document or if you want to pull content out of one document to use in another. Any reference in these pages to using an algorithm to go through a content set and pull out certain pieces of data is an example of the query-based approach. You will see more examples of this in future chapters.</p>
<footnote id="1">
<p>The rule-based and query-based approaches are often called “push” and “pull” methods respectively, but I sometimes find it hard to remember which is which. I find rule-based and query-based more descriptive.</p>
</footnote>
<p>This chapter does not by any means describe the full range of available content processing techniques or all the ways in which algorithms can recognize and manipulate structures in content. The point of introducing structured writing algorithms and the basics of content processing is to enable you to think about structures with an eye to how they can be processed. Often when you look at structures in this way you can see how you can use a simpler structure and how that simpler structure can be processed to achieve the same result as a more complex structure.</p>
<p>Don’t be afraid to write out your algorithms in pseudocode to make sure you have a clear idea of the processing you intend for your structures, and don’t feel confined by the algorithms shown in this book or the annotation I use for pseudocode. You own your pseudocode. Choose a format that is clear to you and that communicates clearly to whoever will be implementing the actual code. Working together with that person can help you improve your appreciation of algorithms and your ability to write useful pseudocode.</p>
<p>Can learning to write real code help with this to? Absolutely it can. Is it necessary? No. What is essential is to think in terms of distributing certain parts of your content system to algorithms and to develop the ability to describe those algorithms and structures well enough that a programmer can implement them.</p>
</section>
</chapter>
