<?xml version="1.0" encoding="UTF-8"?>
<chapter name ="chapter.separating">
<title>Separating Content from Formatting</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conformance algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conformance</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conformant</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conforming</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conforms</annotation></phrase> <phrase><annotation type="algorithm">content management algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content management algorithm">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<index>
<record>
<type>concept</type>
<term>separating content from formatting</term>
</record>
</index>
<p>If there is one phrase that most people associate with structured writing, it is “separating content from formatting.” This is the most basic and well-known method that we use to partition and redirect complexity, and it illustrates the method we use to do all the rest. Separating content from formatting separates decisions about the appearance of a document from decisions about its content. However, as we will see in this chapter, this is not as simple as it may seem.</p>
<section>
<title>Separate out style instructions</title>
<p>Let’s start with a fragment that includes a description of its format. I use CSS syntax to describe the format. I could use a variety of formats, but CSS is easy to understand and helps illustrate the separation. I also represent certain characters (bullets and tabs) by their names, so you can see exactly where everything is going:</p>
<codeblock>
{font: 10pt "Open Sans"}The box contains:
{font: 10pt "Open Sans"}[bullet][tab]Sand
{font: 10pt "Open Sans"}[bullet][tab]Eggs
{font: 10pt "Open Sans"}[bullet][tab]Gold
</codeblock>
<p>This file contains content and formatting, so let’s separate the two. Of course, when you remove the formatting, you need to add something in its place so you can add the formatting back later. The simplest method is to replace it with a named style:</p>
<codeblock>
{style: paragraph}The box contains:
{style: paragraph}[bullet][tab]Sand
{style: paragraph}[bullet][tab]Eggs
{style: paragraph}[bullet][tab]Gold
</codeblock>
<p>Then, you need to record the style; it isn’t being removed, just separated from the text:</p>
<codeblock>
paragraph = {font: 10pt "Open Sans"}
</codeblock>
<p>Once the style information is separated, you can change the formatting without changing the text; for example, you could choose a different font:</p>
<codeblock>
paragraph = {font: 12pt "Century Schoolbook"}
</codeblock>
</section>
<section>
<title>Separate out formatting characters</title>
<p>Cool, but suppose you need to change the style of the bullets. The bullet style is certainly formatting, but bullets are text characters. To change them you can’t just change the font, you have to change the characters themselves.</p>
<p>Some characters in your text are part of the content, and some are part of the formatting. Therefore, a style may include characters as well as formatting directives, as shown here:</p>
<codeblock>
paragraph = {font: 12pt "Century Schoolbook"}
bullet-paragraph = {font: 12pt "Century Schoolbook"}[bullet]
</codeblock>
<p>Now the content looks like this:</p>
<codeblock>
{style: paragraph}The box contains:
{style: bullet-paragraph}[tab]Sand
{style: bullet-paragraph}[tab]Eggs
{style: bullet-paragraph}[tab]Gold
</codeblock>
<p>However, you still must begin the bulleted lines with a tab, which is awkward and error prone, so let’s move that character to the style as well:</p>
<codeblock>
paragraph = {font: 12pt "Century Schoolbook"}
bullet-paragraph = {font: 12pt "Century Schoolbook"}[bullet][tab]
</codeblock>
<p>Now the content looks like this:</p>
<codeblock>
{style: paragraph}The box contains:
{style: bullet-paragraph}Sand
{style: bullet-paragraph}Eggs
{style: bullet-paragraph}Gold
</codeblock>
<p>And now you can change the bullet style:</p>
<codeblock>
bullet-paragraph = {font: 12pt "Century Schoolbook"}[em dash][tab]
</codeblock>
<p>Because the style now uses an em-dash, rather than a bullet, the name bullet-paragraph may not be the best choice. The content still contains a style named for a particular piece of formatting, which means writers are still making the formatting choice “bullet” when it would be better for them to focus on the content choice “list.”</p>
</section>
<section>
<title>Name your abstractions correctly</title>
<p>The names you choose for styles and other abstractions matter. The wrong name sets up a false expectation, which can lead to authors using a style incorrectly. So the first lesson about separating content from formatting is that naming matters. You are creating an abstraction, so you need to figure out what that abstraction is and name it appropriately.</p>
<p>What is the abstraction here? Sand, Eggs, and Gold are list items. So maybe we do this:</p>
<codeblock>
{style: paragraph}The box contains:
{style: list-item}Sand
{style: list-item}Eggs
{style: list-item}Gold
</codeblock>
<p>and</p>
<codeblock>
list-item = {font: 12pt "Century Schoolbook"}[em dash][tab]
</codeblock>
</section>
<section>
<title>Make sure you have the right set of abstractions</title>
<p>But then, of course, you run into lists like the following:</p>
<codeblock>
{style: paragraph}To wash hair:
{style: list-item}Lather
{style: list-item}Rinse
{style: list-item}Repeat
</codeblock>
<p>These list items should have numbers, not dashes or bullets. So the abstraction does not cover all list items. If you look at the different kinds of list items, group them into abstract types, and come up with names for those types, you probably come up with <code>ordered-list-item</code> and <code>unordered-list-item</code>. Then you have:</p>
<codeblock>
{style: paragraph}The box contains:
{style: unordered-list-item}Sand
{style: unordered-list-item}Eggs
{style: unordered-list-item}Gold
</codeblock>
<p>and</p>
<codeblock>
{style: paragraph}To wash hair:
{style: ordered-list-item}Lather
{style: ordered-list-item}Rinse
{style: ordered-list-item}Repeat
</codeblock>
<p>The style for ordered-list-items now looks something like this:</p>
<codeblock>
ordered-list-item = {font: 12pt "Century Schoolbook"}&lt;count&gt;.[tab]
</codeblock>
<p>But you need a way to increment the count and reset it to 1 for a new list, which leads to:</p>
<codeblock>
{style: paragraph}To wash hair:
{style: first-ordered-list-item}Lather
{style: ordered-list-item}Rinse
{style: ordered-list-item}Repeat
</codeblock>
<p>and</p>
<codeblock>
first-ordered-list-item = 
    {font: 12pt "Century Schoolbook"}&lt;count=1&gt;.[tab]
ordered-list-item = 
    {font: 12pt "Century Schoolbook"}&lt;++count&gt;.[tab]
</codeblock>
<p>(<code>++count</code> here means add one to <code>count</code> and then display it.)</p>
<p>This is pretty much how <phrase><annotation type="tool">FrameMaker</annotation></phrase>, <phrase><annotation type="tool">Microsoft Word</annotation></phrase>, and many other tools handle lists. The reason for going through this example in such detail is to point out how much is involved in even this simple bit of partitioning. We began by removing formatting commands, followed by characters, which forced us to include characters in our style definitions. And then we had to calculate the value of characters. At each step, we created abstractions and had to consider all the cases we might run into and create abstractions to handle them.</p>
</section>
<section>
<title>Create containers to provide context</title>
<p>As noted in <citation type = "nameref" value = "chapter.document-domain"/>, one problem with this approach to creating lists is that you have to apply a different style to the first item of a list. It would be better if you could use the same style for each list item and have the numbering just work. However, this is hard to do because nothing in the content says where one numbered list ends and the next begins. For this we need a new abstraction. So far, we have abstractions for ordered and unordered list items, but we don’t have an abstraction for lists themselves.</p>
<p>Up to this point, we have been separating content from formatting purely in the <phrase><annotation type="concept">media domain</annotation></phrase>. We replaced direct formatting definitions with indirect definitions through styles. But now we start to venture into the <phrase><annotation type="concept">document domain</annotation></phrase>, creating the abstract idea of a list and inserting that abstract idea into our content.</p>
<codeblock>
paragraph: To wash hair:
list:
    ordered-list-item:Lather
    ordered-list-item:Rinse
    ordered-list-item:Repeat
</codeblock>
<p>There are a number of significant changes here. First, the structure is no longer flat. We have introduced a container. A list is a container for list items. Previously it was a series of paragraphs with different styles attached. Now we have a container, which, as far as the formatting is concerned, never existed in the original. The writer and reader knew that the sequence of bulleted paragraphs formed a list, but that was an interpretation of the formatting. Now we have taken that interpretation and recorded it explicitly in the content itself.</p>
<p>By creating the idea of a list, we further separate list formatting from the list content – now an algorithm can recognize a list and can make formatting decisions based on that knowledge.</p>
<p>The second important thing is that the content no longer refers to style names. Instead we have structures. <code>list</code> is a structure and so are <code>paragraph</code> and <code>ordered-list-item</code>.</p>
<p>By replacing styles with structures, you can give the same structure a different style depending on where it is in the document. The <phrase><annotation type="concept">formatting algorithm</annotation></phrase> determines if an ordered-list-item is the first one inside a list and formats it accordingly. (Which is <phrase><citation type = "citation" value = "https://css-tricks.com/numbering-in-style/">how list formatting works in CSS.</citation></phrase>)</p>
<p>Now authors no longer apply styles to content, even styles with abstract names. Rather they place content in structures and allow the formatting algorithm to apply styles appropriately. This separates the content even more from the formatting.</p>
</section>
<section>
<title>Move the abstractions to the containers</title>
<p>But there is a problem here. What if an author inadvertently does this:</p>
<codeblock>
paragraph: To wash hair:
list:
    ordered-list-item:Lather
    unordered-list-item:Rinse
    ordered-list-item:Repeat
</codeblock>
<p>To avoid this, move the abstraction outward. Instead of ordered and unordered list items, you create ordered and unordered lists:</p>
<codeblock>
paragraph: To wash hair:
ordered-list:
    list-item:Lather
    list-item:Rinse
    list-item:Repeat
</codeblock>
<p>and</p>
<codeblock>
paragraph: The box contains:
unordered-list:
    list-item:Sand
    list-item:Eggs
    list-item:Gold
</codeblock>
<p>Now, you have a single <code>list-item</code> structure that you can use in either an unordered list or an ordered list; the <phrase><annotation type="concept">formatting algorithm</annotation></phrase> determines the formatting based on which type of list the list-item belongs to. The name <code>list-item</code> describes a role in the document that is entirely separate from formatting.</p>
<p>Moving the abstraction out to the container is an important part of the algorithm of separating content from formatting. It partitions ordered and unordered lists, making the construction of each simpler and more reliable. This helps keep things consistent and reduces the number of things authors have to remember. (Notice that this requires writers to decide whether a list is ordered or unordered, but they had to decide this anyway; the decision is implicit in the rhetoric of the piece.)</p>
<p>Some markup languages take better advantage of containers than others. For example, HTML and Markdown both provide six different heading levels. However, content under an <code>H2</code> or an <code>H5</code> heading is not in any container. The content simply comes after the heading. This means that is it perfectly possible and legal to use heading elements in any order you want. Writers must select the heading level and ensure that it fits the structure of their document.</p>
<p>By contrast, <phrase><annotation type="language">DocBook</annotation></phrase> has a <phrase><annotation type="structure" namespace="DocBook">section</annotation></phrase> structure. Like a list, a section records your interpretation of what you are creating in the document. The <phrase><annotation type="structure" namespace="DocBook">section</annotation></phrase> structure instantiates the concept of a section. And once you have the instantiation of a section, you don’t need six levels of heading. You can have one structure called <phrase><annotation type="structure" namespace="DocBook">title</annotation></phrase>. Sections can be nested inside other sections, and the formatting algorithm applies the correct style to the title based on context:</p>
<codeblock>
section: 
    title:
    paragraph:
    section:
        title:
</codeblock>
<p>This eliminates decisions about which heading element to use; there is just one: <code>title</code>. This ensures that the headings in the output consistently reflect the section and subsection structure of the document.<citation type = "idref" value = "fn.signposts"/></p>
<footnote id ="fn.signposts">
<p>Not everyone holds to the view that headings in a text must reflect a hierarchy of sections. Instead, headings may be simply signposts along the way, where the size of the sign reflects some quality – size of the town or the importance of the section – other than a strict hierarchy. If that is how you look at document structures, you should choose a different way to separate content from formatting.</p>
</footnote>
</section>
<section>
<title>Separate out abstract formatting</title>
<p>I noted that in the case of ordered and unordered lists, separating content from formatting actually involves separating out some of the content as well. Or rather, it involves separating out some of the characters. In other words, the distinction between content and formatting is not the same as the distinction between characters and the styles applied to them. Sometimes characters are part of the formatting rather than the content.</p>
<p>Consider a labeled-list structure:</p>
<blockquote>
<ll>
<li>
<label>Street</label>
<p>123 Elm Street</p>
</li>
<li>
<label>Town</label>
<p>Smallville</p>
</li>
<li>
<label>Country</label>
<p>USA</p>
</li>
<li>
<label>Code</label>
<p>12345</p>
</li>
</ll>
</blockquote>
<p>The generic structure of a labeled list might look like this:</p>
<codeblock language ="sam">
labeled-list:
    list-item:
        label: Street
        content: 123 Elm Street
    list-item:
        label: Town
        contents: Smallville
    list-item:
        label: Country
        contents: 123 USA
    list-item:
        label: Code
        contents: 12345
</codeblock>
<p>But what if you have hundreds of addresses, all with the same labels? Are the labels content or are they presentation? Since the labels don’t change from one list to another, you could look at them as being part of the presentation rather than the content. So let’s look for a way to separate them from the content.</p>
<p>As always, when you separate something from your content, you have to replace it with something else. In this case, we use named structures that reflect the subject matter of the entries, which moves this content into the <phrase><annotation type="concept">subject domain</annotation></phrase> (see <citation type = "idref" value = "ex.separate-1"/>):</p>
<figure id ="ex.separate-1">
<title>Address markup in the subject domain</title>
<codeblock language ="sam">
address:
    street: 123 Elm Street
    town: Smallville
    country: USA
    code: 12345
</codeblock>
</figure>
<p>Here, once again, it is important to distinguish formatting and presentation. As discussed in <citation type = "nameref" value = "chapter.document-domain"/>, <phrase><annotation type="italic">formatting</annotation></phrase> refers to the precise details of a text’s appearance: the font chosen, the width of the text column, the size of the characters, the spacing between line, the size and shape of the bullet characters. <phrase><annotation type="italic">Presentation</annotation></phrase> refers to the organization of text. Deciding to use a list for a certain piece of information is a presentation decision, which is independent of the formatting details applied to lists. When you move content from the <phrase><annotation type="concept">media domain</annotation></phrase> to the <phrase><annotation type="concept">document domain</annotation></phrase>, you separate the formatting of the content from its presentation. The decision to present the information as a list remains; the decision about what that list will look like has been separated out.</p>
<p>In contrast, moving content from the <phrase><annotation type="concept">document domain</annotation></phrase> to the <phrase><annotation type="concept">subject domain</annotation></phrase> separates the <phrase><annotation type="italic">information</annotation></phrase> from the <phrase><annotation type="italic">presentation</annotation></phrase>. The subject-domain structure in <citation type = "idref" value = "ex.separate-1"/> is not a labeled list. It is a data record that could be turned into many different forms of presentation.</p>
<p>The job of turning such structures into a specific form of presentation is the job of the presentation algorithm (see <citation type = "nameref" value = "chapter.publishing"/>). The presentation algorithm could turn it into a labeled list, a table, a paragraph, or an address label.</p>
<p>In the <phrase><annotation type="concept">subject domain</annotation></phrase>, with the content separated from both formatting and presentation, you also gain the ability to query and reorganize the content in various interesting and useful ways (which I will explore in later chapters).</p>
<p>This is as far as you can go in separating content from formatting, and you can’t separate all content from formatting to quite this extent. Separating content from format is not a binary operation. There are various degrees of separation that you can apply for various reasons. It is important to understand exactly which degree of separation best serves your needs.</p>
</section>
</chapter>
