<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.rhetorical_structure">
<title>Rhetorical Structure</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="process">conformance</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforming</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> <phrase><annotation type="process">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<index>
<record>
<type>concept</type>
<term>rhetorical structure</term>
</record>
<record>
<type>concept</type>
<term>mechanical structure</term>
</record>
</index>
<p>Throughout the section on algorithms we have talked a lot about structure. Structure is how you constrain content so that you can partition and redirect the complexity of the content system to algorithms. Successful partitioning depends on the ability to transfer the necessary information between partitions without loss. This is the role of structure. So lets look at the elements of structure and how you go about designing a structure to support the partitioning of complexity you want to achieve for your content.</p>
<p>I want to repeat that phrase, designing a structure to support the partitioning of complexity, because it is very important. The worst thing you can do when setting out to design a structure for structured writing is simply to look at the content and try to mark up the structures you find there. That is not likely to give you a structure that supports the algorithms you want to run or that partitions responsibilities appropriately in your content system. The mechanical structure of content is designed and imposed for one reason and for one reason only: to partition the complexity of the content system. If you design your structures without thinking about the partitioning of the complexity of the content system, you will still end up partitioning it, but you may not partition it in a way that is advantageous for your writers, your readers, and the other players in your content system.</p>
<p>That said, the place to begin when designing a content structure is rhetoric, with the way that a piece makes its argument or assembles and organizes information to inform the reader. The work of the writer is rhetoric and the point of partitioning the content system is, in large part, to allow the writer to focus on rhetoric, while still providing the information needed for the other partitions in the content system to operate without dropping complexity.</p>
<p>Achieving an effective rhetoric in the content we present to readers is the ultimate aim of any content system. The result of any failure to handle complexity in the content system is felt largely in the form of impaired rhetoric. (Impaired ergonomics – formatting that is hard to read for instance – is a secondary source of difficulty for the reader.) When we factor out formatting in the transition to the document domain, it is to allow for a greater focus on rhetoric. When we factor out or enforce rhetorical constraints in the transition to the subject domain, it is to achieve a higher level of <phrase><annotation type="process">conformance</annotation></phrase>, <phrase><annotation type="algorithm">validity</annotation></phrase>, and <phrase><annotation type="algorithm">repeatability</annotation></phrase> in rhetoric. The movement from the media domain to the subject domain is a movement from appearance to rhetoric. The aim of the content system is always to produce better rhetoric, and therefore applications of structured writing are about improving rhetoric, either by removing the complexities that detract from writers focusing on rhetoric or by explicitly supporting the consistent and repeatable development of superior rhetoric.</p>
<p>Whether you decide to model a specific rhetorical structure for your content or whether you decide to factor out a specific rhetorical structure by recording facts independent of presentation so that you can generate a differential rhetorical structure with algorithms, or so that you can test and tweak aspects of the presentation without having to rewrite content, the the place to start in designing content structures is by defining the rhetorical pattern or patterns you want to deliver.</p>
<p>The rhetorical structure of a piece of content is how it tells its story. For many types of stories, the optimal rhetorical structure is quite consistent and often well known. In other cases, the best rhetorical structure can be determined both by a careful consideration of what needs to be said and by experience and testing with readers. In other words, there is a right way, a best way, to tell a wide range of stories. This best is not necessarily universal. Best for your subject matter and your audience may be different from best for mine, just as the best recipe presentation for <phrase><annotation type="italic">Wine Weenie</annotation></phrase> is different from the best format for <phrase><annotation type="italic">The Teetotaler's Trumpet</annotation></phrase>, but for you and your readers there is a definable, testable, repeatable best.</p>
<p>Maintaining a consistent high-level of conformance to the optimal rhetorical structure for a particular subject can be complex, however, especially if you have a variety of contributors. Content quality is greatly enhanced when the rhetorical structure is well defined and followed consistently. Lapses of quality occur then the complexity of maintaining the optimal rhetorical structured for content is not properly managed and the unmanaged complexity falls through to the reader in the form or content that is not rhetorically optimal. Also, a well defined rhetorical structured provides an effective baseline against which to compare and measure proposed improvements. Using an explicit predefined rhetorical structure helps enhance and maintain content quality.</p>
<p>We can see rhetorical structure as made up of information requirements and presentation requirements – what needs to be said and how best to say it. Sometimes information requirements dominate the structure and sometimes it is presentation requirements. Sometimes there is no regular set of facts to relate across all instances, but a particular approach to presentation is known to work particularly well.</p>
<p>The recipe example that I have used so often in this book is an example of both information requirements and presentation requirements.</p>
<p>The presentation requirements for recipes in general are the listing of ingredients, including the specific and precise way that the measurements of those ingredients are presented, and the list of presentation steps. Information requirements for recipes produced by particular publications include wine matches, prep time, servings, and number of calories.</p>
<p>One of the key presentation requirements is the presentation of the list of ingredients as a separate section with precise measurements. Yes, this is also an information requirement. But notice that all recipes (or almost all) break out this list and separate it from the preparation steps. The ingredients are mentioned again in the preparation steps, so why not just put the measurements in the steps and omit the listing of ingredients? This is an important rhetorical decision. It is not like deciding whether to pull out the prep time and number of servings into separate fields or leave them in the introduction. It has a much more important rhetorical purpose.</p>
<p>We separate out the list of ingredients for a recipe, because the cook’s first step in making a dish is not the first item in the list of preparation steps. The first step is to make sure that you have all the ingredients you need. The rhetorical structure of a recipe could be to make this an explicit first step:</p>
<codeblock language="sam">

recipe: Hard Boiled Egg
    introduction:
        A hard boiled egg is simple and nutritious.
    preparation:
        1. Make sure you have the following ingredients on hand:
            * 12 eggs
            * 2qt water
        2. Place eggs in pan and cover with water.
        3. Bring water to a boil.
        4. Remove from heat and cover for 12 minutes.
        5. Place eggs in cold water to stop cooking.
        6. Peel and serve.
</codeblock>
<p>But since this is a universal first step for every recipe, it has been implicitly factored out in the rhetorical pattern of a recipe and is supported by a separate list.</p>
<p>There are other implicit steps as well. Another is to collect and measure your ingredients before you start cooking. Some cooks measure and lay out all their ingredients before they start cooking. Others measure and add as they go. By simply providing a list of ingredients rather than making this an explicit step, a recipe accommodates both behaviors.</p>
<p>In fact, there is a step that is prior to all of these: the step of deciding whether to make the dish or not. This is why most recipes have some form of introduction to the dish and a picture of what the finished dish or a typical serving will look like. Obviously no one is ever going to start a recipe with “Step 1. Decide if you want to make this dish”. But that decision is actually the first step a cook makes when they come to a recipe, and the rhetorical structure of the recipe is designed to support that step. (There is an important generality here about what supporting a task means. Tasks are things people do. Procedures are text structures. Supporting a task is a far broader rhetorical problem than writing a procedure.)</p>
<p>It is also interesting what a recipe does not do. A recipe does not call out a list of the pots and pans and other utensils you will need. Sometimes the instructions will be quiet explicit about what kind of pot or spoon to use for a step, but nonetheless, most recipes do not list tools the way they list ingredients, perhaps because they assume all kitchens are similarly equipped. Knitting patterns, which are highly similar rhetorical structures to recipes, and frequently consumed by the same people, tend to explicitly call out the specific tools to use. Whatever the reason, this is as much a defined and established part of the rhetorical structure as recipes are in inclusion of a specific list of ingredients. It is the established way in which information on the preparation is presented, blessed and approved by generations of cooks.</p>
<p>But while there is a general rhetorical consensus about the general pattern of recipes, individual organizations, may require more specific rhetorical structure. As we saw in <citation type = "nameref" value = "chapter.subject-domain"/>, a wine magazine may require every recipe to have a wine match. A health-oriented magazine may require every recipe to contain a complete set of nutritional information. Other organizations may have specific requirements about how recipes are to be presented, such as requiring ingredients to be presented in a table rather than a list. The specific set of requirements of an organization – their unique constraints – constitute a formal content structure.</p>
<p>In some cases, rhetorical structures are immediately obvious because they have a visual shape. The various components of a recipe just happen to look physically different on a page (which is why recipes are the most popular structured writing example). There is the picture; the introduction, which is a block; the ingredients, which are a list; and the steps, which are a numbered list. The recipe pattern is visually distinctive even without looking at a word of the text.</p>
<p>However, rhetorical structures are not about elements that are visually distinct. They are about the different types of information that are required, the way they are expressed, and the order they are presented in. There may be considerable variation in the second two properties. Whether we would count these variations as options within one rhetorical pattern or as defining different rhetorical structures should probably depend on their effect. Any organization and means of expression that has the same rhetorical effect we can reasonable count as variations on a single rhetorical structure.</p>
<p>When you look at a page that appears to be just a sequence of paragraphs with perhaps some subheadings thrown it, it is easy to assume that there is no particular rhetorical structure present. But this is not necessarily true at all. If a consistent set of information is being presented for a particular purpose, and we can find (or reasonably imagine) that same set of information being assembled for the same purpose to describe another object of the same type, then we have a rhetorical structure. Similarly, where there is a deliberate strategy for laying out an argument or demonstrating or supporting a process, we have rhetorical structure. And where we have a repeatable rhetorical structure, we can define a structured content type for a specific business purpose.</p>
<p>By structured content type here I mean a set of formal computable structures into which text is inserted and by which text – its creation and interpretation – is constrained. This is not quite the same thing as the mechanical structure of the content, which we will look at in <citation type = "nameref" value = "chapter.mechanical-structure"/>. The mechanical structure is the implementation of the structured content type, but the structured content type can be described independent of how it is implemented, and can indeed be implemented in more than one way. You can even define a structured content type without creating or using a mechanical structure to implement it, though obviously with the mechanical structure, you can hand over any part of its validation or processing to algorithms.</p>
<p>You should not expect that, once you define a structured content type, you will be able to take the mechanical structure that implements that type and simply wrap it around every existing piece of content without changing a word. (The point of structured writing is to improve content, not to faithfully represent its current state.) Content that has been written in an unstructured format, even if it obeys an consistent rhetorical structure, may not fit the precise structure you have defined, particularly if you have factored out certain parts of the desired presentation when structuring your content in the subject domain.</p>
<p>What you will find when you start to move content that generally follows a <phrase><annotation type="structure">rhetorical structure</annotation></phrase> into a defined <phrase><annotation type="concept">structured content type</annotation></phrase> is that a lot of the content does not fit the defined type particularly well. You will find some instances that only partially fit, but which omit information commonly found in the rhetorical structure (and perhaps required in the structured type). You will find that some instances contain information not found in most instance of the pattern, and not supported by the structured type. You will find information not expressed in the way that the structured type expects.</p>
<p>These discoveries mean one of four things:</p>
<ul>
<li>
<p>The discernment of rhetorical structures in incorrect and you are trying to make content with a different pattern fit your structured type. You need to define a new structured types for this new rhetorical structures.</p>
</li>
<li>
<p>The definition of the structured type is incorrect. You need to modify the structured types to more correctly reflect the rhetorical structures.</p>
</li>
<li>
<p>The content is a variation of the rhetorical structures that is deliberately not supported by the structured type. The content needs to be edited to fit.</p>
</li>
<li>
<p>The content is deficient. It does not meet the rhetorical structure and it needs to be upgraded so that it fulfills it purpose correctly, as defined by the structured type.</p>
</li>
</ul>
<p>Interpreting the mismatch between existing content and the structured type can make or break your entire structured writing project. There is a huge temptation to treat existing text as canonical and try to shape the model to fit it. But as I have stressed several times, the purpose of structured writing it not to represent existing texts, but to partition and redistribute the complexity of the content system, ultimately resulting in better content for the reader. If your current content processes are so good that all your existing content fits your new structures perfectly, then you are not realizing any gain in content quality and you are wasting your time by adding additional mechanical structure. Finding content that does not fit the model is not a sign that the model is broken, but that the process is working.</p>
<p>This does not mean that the models never need to be changed. But it does mean that you change the models to match the things you discover about the best rhetorical structure for your content to achieve your business goals, not to make your existing content, or even the new content that authors want to write, fit the model.</p>
<p>This means that applying structure to your existing content is not a trivial or mechanical task. The purpose, after all, is to improve the quality of the existing content, and that is going to mean additional research and writing work to bring the content up to standard.<citation type = "idref" value = "1"/></p>
<footnote id="1">
<p>Let’s make this distinction clear: people often convert content from one file format to another, including for binary formats to markup formats. This is a mechanical process, though one that may require some cleanup. It does not, in itself, impose any additional constraints on the content. It merely changes the syntax that expresses existing structures. This kind of conversion is often possible to <phrase><annotation type="concept">document domain</annotation></phrase> formats like DITA and DocBook. This does not mean that the resulting <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> or <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> output will correctly express the full range of constraints or structures that these formats are capable of. You can also do a reliable transformation from one subject domain format to another (say from a relational database to XML markup). But your cannot do a reliable mechanical transformation of media domain content to the document domain or of document domain content to the subject domain. The subject domain imposes constraints that may be expressed rhetorically in the document domain, but are not expressed mechanically. These conversions are writing tasks, not something than can be done mechanically.</p>
</footnote>
<section>
<title>Presentation-oriented rhetorical structures</title>
<p>In some cases, as we have seen, it is possible to factor out the rhetorical structure of an item and move the content almost entirely into the subject domain. This is possible with a recipe, for instance (see <citation type = "nameref" value = "chapter.subject-domain"/>). In these cases, any reasonable rhetorical design can be created from the subject domain content by the presentation algorithm because the rhetorical design consists of a particular arrangement of facts.</p>
<p>But not all rhetorical models are reducible to an arrangement of facts. This is clearly true of philosophical essays and even of books like this one. In works of this sort, the rhetorical structure – the course of the argument – cannot easily be reduced to a repeatable structure. But there are certainly cases in which rhetorical structures can be highly repeatable and yet does not consist merely of an arrangement of facts. In other words, there are rhetorical models that focus on the optimal presentation of information in certain circumstance, independent of the specifics of the subject matter. A well known example is the pyramid structure used in newspapers, which clusters the key points of a story at the top.</p>
<p>There is a presentation-oriented rhetorical pattern that is useful in technical communication (and perhaps in other fields) that I call the think-plan-do pattern. Many technical communication tasks simply involve telling a user how to perform specific functions on specific pieces of machinery. But there are cases in which the user’s task has highly complex input conditions and potentially far-reaching consequences. In this case, the technical communication task goes well beyond telling the user how to operate the machine. It is about helping them to correctly plan their actions to achieve the desired business outcome.</p>
<p>You can approach this problem by simply collecting all the relevant facts that the user would need to make a correct decision. But a mere listing of relevant facts is not helpful to a user who does not fully understand the complexity of the task or the seriousness of its potential consequences. For example, a user may well not understand the security implication of a particular configuration option of a computer system. The safety of that option may depend of a variety of factors, such as who has access to the system, what software is running on the system, what data it contains, and how other settings are configured.</p>
<p>If the user does not appreciate the seriousness or complexity of the issues involved, they may skip all of the additional information and go straight to the beginning of the procedure. If they do, a mere listing of relevant facts may scare them out of trying to change the setting (which may be just as unsafe as changing it, and may have other negative consequences).</p>
<p>A potential rhetorical structure addressing this problem is to walk the user through each of the decisions that need to be made in order to plan their changes correctly. This can consist of a number of carefully designed discrete questions designed to help the user figure out which issues apply to their situation and, if they do apply, how to deal with them.</p>
<p>In other words, the model presents a formal planning methodology in the form of a set of questions which break down the planning of the change into manageable pieces that the user can successfully comprehend and act on. It supports cognition by breaking a complex subject down into manageable pieces.</p>
<p>Depending on the material, it may be possible to find a common patterns in the subject matter of these questions. (The exact same set of questions need to be considered for each configuration setting, for example.) But in many cases, the questions that need to be asked are particular to the individual case. It is the rhetorical device of breaking the planning process into a set of discrete questions that is most important to improving the quality of the content and ensuring that the reader is successful.</p>
<p>So far in this book I have mostly presented document domain models as rather loose collections of generic document structures mainly used to <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> or to facilitate <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase>. But this example shows that the document domain can also be used to model a specific rhetorical strategy.</p>
<p>In some cases, you may find that specific subjects require a specific rhetorical strategy, but do not particularly lend themselves to the subject-domain approach of breaking out a consistent set of information to be provided for each instance of a subject. In these cases, creating a document domain model that enforces the appropriate rhetorical strategy may be the best approach.</p>
</section>
<section>
<title>Rhetorical metamodels</title>
<p>There are different ways of thinking about the rhetorical structure of content. Above, I describe the topic pattern of a recipe as consisting of a picture, an introduction, ingredients, and a list of preparation steps.</p>
<p>However, we could notice that there are a great many other type of information with a similar pattern. For instance, a knitting pattern  usually has a picture of the garment, an introduction describing the project, a list of the yarns and needles required, and a list of steps for knitting and assembling the pieces. Lots of other things look similar. Instructions for assembling flat pack furniture, for example, or planting flowers in your garden.</p>
<p>These are not the same rhetorical structure. You would not confuse a recipe with a knitting pattern. And each of them can have specific information fields that would make no sense for the others. A pot roast will never have washing instructions. A flat pack bookcase will never have a wine match. Nonetheless, they all have the basic pattern of picture, description, list of stuff you need, steps to complete. We might call this the make-thing-out-of-stuff-with-tools pattern.</p>
<p>The make-thing-out-of-stuff-with-tools pattern is what we might call a meta-model. It is not based on seeing similarities between texts, but on seeing similarities in the rhetorical patterns of texts. The meta pattern is not intended for creating content directly, but it can potentially provide hints that help us develop individual topic patterns.</p>
<p>Not only are there meta-patterns for topics, like the make-thing-out-of-stuff-with-tools meta pattern, there are also meta patterns for the different types of information that go into a meta pattern, such as the picture, description, list of stuff you need, and steps to complete. These are sometimes called “information types” (a confusing term, since text at any scale expresses information, and therefore the structure of information at any scale is an information type).</p>
<p>Two notable examples of these information type meta patterns are found in <phrase><annotation type="method">Information Mapping</annotation></phrase> and <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>. Information Mapping proposes that document are composed of just six information types: procedure, process, principle, concept, structure, and fact.<citation type = "citation" value = "http://www.informationmapping.com/fspro2013-tutorial/infotypes/infotype1.html"/> Documents are then constructed of some arrangement of information blocks of one of these six types, which it calls a map. In other words, Information Mapping proposes that every rhetorical structure is always composed of some combination of these six information types.</p>
<p><phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> proposes something similar, but it proposes just three types: concept, task, and reference,<citation type = "idref" value = "3"/> which, confusingly, it calls topic types. Like information mapping, DITA assembles documents out of these topic (information) types using a map.</p>
<footnote id="3">
<p>Or, at least, it originally proposed these three types. The DITA specification now includes other topic types, some of which are much more concrete than these original three.</p>
</footnote>
<p>In the concept/task/reference metamodel, our recipe topic pattern would consist of one concept topic (the introduction), one reference topic (the list of ingredients), and one task topic (the preparation steps). And our make-thing-out-of-stuff-with-tools meta-pattern would similarly consist of one concept topic (description), one reference topic (list of stuff you need), and one task topic (steps to complete). (DITA’s information model does not include pictures. It just provides a mechanism for including them in textual topic types.)</p>
<p>What neither DITA nor Information Mapping provide is any way to model the larger recipe pattern. DITA will let you write a map to combine a concept topic containing an introduction (which presumably is where you would include the picture), a reference topic containing a list of ingredients, and a task topic containing preparation instructions. But it does not give you a way to specify that a recipe topic consists of one concept topic, one reference topic, and one task topic. In other words, DITA does not provide any way to define larger types or the overall rhetorical structure of documents.</p>
<p>What <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> does do is provide a way to specify a concrete instance type of any of its meta-types. A list of ingredients has a specific structure that is not the same as the list of pieces in a flat-pack furniture box. It consists of an ingredient name, a quantity, and a unit of measure. The unit of measure is vital in an ingredient listing because not all ingredients are quantified in the same way. You don’t measure eggs the same way you measure flour, for instance.</p>
<p>To express this constraint, DITA will let you specialize the reference topic type to create a list-of-ingredients topic type that imposes (and records) this constraint. You could then construct a recipe using a introduction-to-recipe topic (a specialization of concept), a list-of-ingredients topic (a specialization of reference), and a preparation-steps topic (a specialization of task). However, it still would not give you a way to specify that a recipe consists of these three topic types in this order. (More on DITA specialization in <citation type = "nameref" value = "chapter.extensible"/>.)</p>
<p>Actually, it is possible to define a recipe topic types in DITA, but this involves having a different idea about how atomic the basic DITA topic types are. Some DITA practitioners might say that a recipe is not a map made up of three information types, but a single task topic. In this view, a task topic is much more than what Information Mapping would call a procedure. It allows for the introduction of a task, a list of requirements, and the procedure steps all within the definition of a single topic. (I have asked a number of DITA practitioners how a recipe should be modeled in DITA and have received each answer from multiple people.)</p>
<p>One of the reasons for this uncertainty about what an atomic topic is in DITA is DITA’s focus on content reuse. DITA topics are not only units of information typing, they are units of reuse. The approach in which a recipe is a single topic leaves you with fewer, larger units of content, which makes individual topics harder to reuse. The atomic unit of  content that is small enough to maximize potential reuse is much smaller than the atomic unit of  content that contains a complete <phrase><annotation type="structure">rhetorical pattern</annotation></phrase>. The atomic unit of reuse is smaller than the atomic unit of use.</p>
<p>Because DITA has no mechanism for describing model larger than a topic, a DITA practitioner is left with a choice between modeling for maximum reuse and modeling to constrain a topic type to rhetorical structure. In practice, it seems that different DITA users make different decisions about how atomic their topic types should be, based on their business needs.</p>
<section>
<title>Meta-models vs generic models</title>
<p>Ideally, a meta-model should just be a model of models. You should not be able to use it for anything other than to create concrete models. It should not only suggest those things that each specific model should have in common, but also the unique things that are specific to particular instance of the pattern. For instance, it should in some way suggest that a recipe instance of the make-thing-out-of-stuff-with-tools meta pattern might want to include a wine match. (A thing-goes-with-other-thing relationship, perhaps.)</p>
<p>In practice, a meta-models often turn out to be simply a list of those things that all instances of the meta-model have in common. In many cases, instead of inventing an entirely new notation for describing meta-models, people just create a model with only the common properties. Thus the expression of the meta-model takes the form of a generic model, which means that it is perfectly possible to write content using that generic model. Thus while DITA’s concept, task, and reference topic types are intended as meta-models to be specialized into concrete models, they are implemented as generic models which can be used directly.</p>
<p>A great many DITA users don’t specialize at all. They write all of their content in the base task, reference, and concept topic types (or the even more basic “topic” topic type, of which task, reference, and concept are actually specializations). This means that the topic type imposes no specific rhetorical pattern. But at the same time, the generic pattern can be confining. For instance, DITA’s default topic model does not allow you to have two procedures in a single task topic.</p>
<p>Are meta-models useful for defining topic patterns? If a concrete topic pattern describes the kinds of information that are needed to help a particular audience perform a particular task, do we arrive at that pattern more easily by derivation from a meta-model or from observation of multiple concrete examples of actual topics?</p>
<p>The obvious problem with the current generation of content meta-models is that none of them alert us that a recipe might need a field for a wine match. It is not impossible to imagine that a meta-model could do this. A meta-model could observe that objects are commonly used with other objects and lead us to ask what other objects is a steak dinner used with. There are obviously multiple aspects of this question. A steak dinner is used with a knife and fork. A steak dinner is used with a table and chair. A steak dinner is used with family and friends. A steak dinner is used with a glass of wine. How do we characterize each of these thing-used-with-thing relationships in a meta-model, and how do we decide which of these types of thing-used-with-thing types is relevant to a recipe?</p>
<p>Perhaps, for instance, we might decide that because a recipe describes a foodstuff, thing-used-with-thing relationships are relevant when the other thing is also a foodstuff. In other words, we might decide that a thing-used-with-like-thing relationship is part of the meta-model.<citation type = "idref" value = "2"/> (I am not, by the way, suggesting that this is a useful part of a meta-model, I merely wanted to illustrate the problem of defining a meta-model that would comprehend all the specific models we might care about in the real world.)</p>
<footnote id="2">
<p>Rob Hanna’s Enterprise Content Metamodel<citation type = "citation" value = "https://www.oasis-open.org/committees/download.php/41040/Enterprise%20Content%20Metamodel.pptx"/> does attempt to do something like this for business information, attempting to describe the relationships between pieces of business content based on the business functions they serve as a basis for deriving specific information types.</p>
</footnote>
<p>This is getting complicated enough for me to conclude that, while the <phrase><annotation type="concept" specifically="ontology">ontologists</annotation></phrase> may one day come up with a such a model and a reliable way to derive concrete content models from it, for most writers, information architects, and content strategist, building a concrete topic model from the observation of instances is probably the preferable method.</p>
<p>Creating a good subject-domain structured model for content is actually pretty simple when you get down to it. You simply ask yourself five questions:</p>
<ol>
<li>
<p>What information does the reader need to fulfill whatever purpose this unit of content is meant to serve?</p>
</li>
<li>
<p>What is the best way to express each of these elements?</p>
</li>
<li>
<p>What is the best way to organize these elements so that the reader can quickly recognize that this is the content they need and can effectively find the information then need in the content?</p>
</li>
<li>
<p>What constraints do I need to apply to the content to make sure that what the author creates conforms with the answers to the first three questions, and how will I test their conformance to those constraints?</p>
</li>
<li>
<p>What level of detail and precisions do I need in the content structures I create to make sure that the structured writing algorithms I want to apply to the content can run reliably.</p>
</li>
</ol>
<p>Answering those question is not necessarily easy, of course. But the process itself is simple and you should not make it any more complex than it needs to be.</p>
</section>
</section>
<section>
<title>Making the rhetorical structure explicit</title>
<p>I noted above that there can be a rhetorical structure in a piece of text that is just a sequence of paragraphs. You can discern the topic pattern in those paragraph and model that pattern in a content type, and still present the output as a sequence of paragraphs. Presumably, in each instance of the topic type, those paragraphs would now be more consistently expressed with fewer errors and omissions than before, but the presentation itself would be the same.</p>
<p>Alternatively, you may choose to make the rhetorical structure more explicit to the reader as well as to the writer. In this case, the sequence of paragraphs might be replaced with a distinct combination of headings, graphics, tables, lists, pictures, and text sections that would repeat in every topic of that type.</p>
<p>The question, of course, is whether making the rhetorical structure explicit in this way improves the content. In its favor, the more explicit rhetorical structure makes it easier for the reader to recognize the type. (As we noted above, you can recognize a recipe by its shape, without reading a word.) This makes it easier to identify <phrase><annotation type="algorithm">relevant</annotation></phrase> content, which is particularly important on the Web. It can also make it easier to scan the content to pick out the parts you need. The argument against this treatment is that it can lead to a noisier page that is harder to read straight through.</p>
<p>Whether you want to make the rhetorical structure of your pages explicit in these ways, therefore, is a matter to be decided on a case-by-case basis. But don’t fall into the trap of supposing the because you have chosen a plain presentation, that means there is no rhetorical structure, and therefore no structured type. The rhetorical structure of the content is a separate thing from the presentation of the content, and the aim of structured writing is to improve the rhetorical structure, not just to make the presentation more uniform.</p>
</section>
<section>
<title>Structure and repeatability</title>
<p>However much success we may have in defining common rhetorical structures, most content does not surrender to the analytical knife entirely. When we define a rhetorical structure, we are essentially defining something repeatable. While one could hypothetically take a piece of exposition and define the structured that it follows (and in a sense, this is what ontology does), this is only useful in a structured writing sense when that structure is repeatable, when there is another piece of content that can follow the same structure, enabling us to reuse the design work and testing that we have done, and allowing algorithms to take over parts of the processing of that structure.</p>
<p>Where the rhetorical structure of a piece is unique – specifically when it is irreducibly unique, not just unique because you have not recognized its similarity to the structure of other pieces – there is no benefit to the imposition of an external structure definition. Irreducible rhetorical uniqueness can occur at any scale. Sometimes it occurs at the scale of an entire book, such as this one. Sometimes it occurs in a single descriptive paragraph in a reference work that otherwise consists entirely of repeatable key/value pairs. (Which is why so many content types have a “description” section for everything that cannot be easily modeled. The content of such a section is not uniquely descriptive, it is simply not easily reducible to fielded data.)</p>
<p>This variation in the degree of unique vs repeatable rhetorical structure in content is the reason why we need different structures for different types of content. If we attempt to fit all content into one structure, however broad that structure may be, we are either failing to model, and therefore to manage or apply algorithms to, much of the repeatable structure of our content, and therefore diminishing the repeatability of our process, or we are squeezing unique rhetorical structures into the mold of a repeatable structure, distorting their rhetoric. (This is a common problem with strict information typing systems like <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>’s task/concept/reference, which often don’t fit the rhetorical pattern the writer is trying to create.)</p>
<p>We can usefully consider rhetorical repeatability in three categories:</p>
<ll>
<li>
<label>Repeatable data</label>
<p>The same information is required in each instance. For instance, a recipe requires the name, quantity, and unit for each ingredient of a dish.</p>
</li>
<li>
<label>Repeatable argument</label>
<p>The way in which the information is conveyed to the reader is the same each time. For instance, the think-plan-do approach to task support content.</p>
</li>
<li>
<label>Repeatable relationships</label>
<p>The way in which the subject discussed in a piece are related to their subject matter is the same each time. For instance, the consistent use of the same subject annotations across an entire content set, including everything from strict reference content to highly discursive conceptual material reflects a consistency in what types of subjects are important in an information set and how they are named.</p>
</li>
</ll>
<p>Note that these types of repeatability are not exclusive to an entire piece of content. Rather, each piece of content contains some mix of these types. Thus one of your content types may be a generic document-domain structure that is used for highly discursive material with no repeatable data or repeatable argument, but it can still us the same subject annotations as the rest of the content set.</p>
<p>Remember that the ultimate aim is to partition and redirect complexity in the content system. Part of that complexity is the varying levels of repeatability in content – a problem seldom seen in other forms of data management. If you want to deal effectively with all of the complexity in your content system, then this variation in degrees of repeatability is one of the the things you need to deal with. If it is not dealt with successfully, either the repeatability of repeatable content will be lost or diminished, or the uniqueness of unique content will be compromized. Either way, that is complexity falling through to the reader in the form of impaired content quality.</p>
</section>
<section>
<title>The importance of the rhetorical model</title>
<p>If the aim of structured writing is to partition and redirect complexity in the content system without letting any of that complexity leak out of the process and fall down to the reader, then the correctness and consistency of rhetorical models is a core concern. Poor rhetoric means poor content, and poor content means that the complexity of achieving consistent and correct rhetoric has been dropped somewhere in the content system.</p>
<p>A content system relies for its effectiveness on the ability of its principle authors and occasional contributors to maintain a consistent rhetorical standard. The three tools that it has available to do this are:</p>
<ul>
<li>
<p>Minimize intrusions into the attention of writers while they are writing. Any attention given to other matters while writing is attention taken away from rhetoric.</p>
</li>
<li>
<p>Guide writers to help them provide the correct rhetoric. In other words, reuse the rhetorical design work that you have done, and that you have tested and refined with readers.</p>
</li>
<li>
<p>Partition out the rhetorical aspects of a composition by collecting facts in a subject domain structure which can then be transformed into the appropriate rhetorical form by algorithms.</p>
</li>
</ul>
<p>Content inherently varies in how structured it is, so the more structured of these techniques only work for some part of your content set. Your need all three of these techniques to provide the most comprehensive rhetorical support across your content system.</p>
</section>
</chapter>
