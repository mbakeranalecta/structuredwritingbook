<?xml version="1.0" encoding="UTF-8"?>
<chapter name ="chapter.document-domain">
<title>Writing in the Document Domain</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conformance algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conformance</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conformant</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conforming</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance algorithm">conforms</annotation></phrase> <phrase><annotation type="algorithm">content management algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content management algorithm">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<index>
<record>
<type>concept</type>
<term>media domain</term>
</record>
<record>
<type>concept</type>
<term>document domain</term>
</record>
<record>
<type>concept</type>
<term>subject domain</term>
</record>
</index>
<p>The <phrase><annotation type="concept">document domain</annotation></phrase> is concerned with the presentation of information as a document. In the document domain you use structures such as title, list, and table, without specifying how they will be formatted. You make document-domain decisions and defer media-domain decisions to someone else. In all likelihood, you defer those decisions to a designer who creates an algorithm to execute the decision.</p>
<sidebar>
<title>Formatting versus presentation</title>
<p>The words <phrase><annotation type="italic">formatting</annotation></phrase> and <phrase><annotation type="italic">presentation</annotation></phrase> are commonly used as synonyms, but here I make a distinction between, for example, the decision to present a piece of information as a list (presentation), and the decision to format list items in 12-point Palatino with 1-em indent and a square bullet (formatting). In this sense, presentation and formatting are distinct and can be partitioned from each other. However, it’s easy to lose this distinction because most of today’s tools combine these two operations in a <phrase><annotation type="concept">WYSIWYG</annotation></phrase> display.</p>
</sidebar>
<p>Word processors and desktop-publishing applications straddle the media domain and the document domain. While they offer a basic set of document-domain objects – pages, paragraphs, tables, and so forth – they use a <phrase><annotation type="concept">WYSIWYG</annotation></phrase> display, which unifies, rather than partitions, writing and formatting. This keeps you thinking mostly in terms of styles and formatting – the concerns of the media domain – and makes it difficult to apply meaningful document-domain constraints or to record which constraints you have followed. This makes it impossible to redistribute formatting complexity. For that you need to move more fully into the document domain.</p>
<p>The document domain allows you to enforce media-domain constraints that are hard to enforce in the media domain itself.<citation type = "idref" value = "fn.docd-1"/> Consider a list. You may want the spacing above the first item of a list to be different from the spacing between other items of the list. This is a media-domain constraint – it is about formatting, not the structure of the document. However, this constraint is hard to enforce in the media domain.</p>
<footnote id ="fn.docd-1">
<p>This illustrates a consistent pattern: we often move to the next domain to enforce – or factor out – constraints in the previous domain.</p>
</footnote>
<p>Most media-domain writing applications create lists by applying styles to ordinary paragraphs. To format a list with an extra space above the first item, you need to create two different styles: a <code>first-item-of-list</code> style and and <code>following-item-of-list</code> style. The result might look like <citation type = "idref" value = "ex.flat-list"/>.</p>
<figure id ="ex.flat-list">
<title>List structure in the media domain</title>
<codeblock>
p{first-item-of-list}: Carrots
p{following-item-of-list}: Celery
p{following-item-of-list}: Onions
</codeblock>
</figure>
<p>This requires you to apply the <code>first-item-of-list</code> style to the first item of a list and the <code>following-item-of-list</code> style to the following items. The word processor does not enforce this constraint. You have to remember it, which creates two problems:</p>
<ol>
<li>
<p>It makes writing a bit harder (and all the bits add up). You need to decide which style to use for every list item, even though the design decision has already been made. And new authors must learn, and remember to apply, this rule.</p>
</li>
<li>
<p>If you get it wrong, the problem may go unnoticed.</p>
</li>
</ol>
<p>Structured writing works by factoring out invariants. Most constraints are invariants – that is, they are rules that apply to all instances of the same content structure. The constraint that all lists must have extra space before the first item is an obvious example. The best way to enforce an invariant constraint is to partition it out altogether.</p>
<p>To do this, we create a list structure – not a styled paragraph, but an structure that is specifically a list. A document-domain list structure looks like <citation type = "idref" value = "ex.docdomain-list"/>:</p>
<figure id ="ex.docdomain-list">
<title>List structure in the document domain</title>
<codeblock language ="SAM">
list:
    list-item: Carrots
    list-item: Celery
    list-item: Onions
</codeblock>
</figure>
<p>A list structure partitions the idea of a list from the physical formatting of a list by creating a container that did not exist before – the <code>list</code> structure. By creating a <code>list</code> structure, you tell the formatting algorithm that this is a list. Since a list is a feature of a document, it is a document-domain structure. The <code>list</code> container has no media-domain analog.</p>
<p>Once you have a <code>list</code> structure, you can create rules – in a separate file – about how lists are formatted. We are familiar with this from <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> and <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase>. <citation type = "idref" value = "ex.html-list"/> shows a list structure in <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> (actually, this is a slightly more specific structure, but we’ll get to that):</p>
<figure id ="ex.html-list">
<title>List structure using HTML</title>
<codeblock language ="HTML">
&lt;ol&gt;
    &lt;li&gt;Carrots&lt;/li&gt;
    &lt;li&gt;Celery&lt;/li&gt;
    &lt;li&gt;Onions&lt;/li&gt;
&lt;/ol&gt;
</codeblock>
</figure>
<p>Now that you have a distinct list object, you can factor out the invariant list formatting rule into a separate file. For HTML, we usually do this with a CSS stylesheet (see <citation type = "idref" value = "ex.css-list"/>):</p>
<figure id ="ex.css-list">
<title>CSS for a list structure</title>
<codeblock language ="CSS">
li:first-child 
{
    padding-top: 5pt;
}
</codeblock>
</figure>
<p>This partitions the spacing-above-lists decision and assigns it to an algorithm, distributing the complexity of content creation by asking the author to express a simple idea in familiar terms – this is a list – instead of a complex set of formatting instructions.</p>
<p>Introducing the concept of a list structure adds to the total complexity of the system and requires authors to manage a little extra complexity. However, in return, a much larger piece of complexity has been partitioned off and assigned to an algorithm, reducing the number of decisions authors must make and ensuring a greater degree of consistency.</p>
<p>But wait! That’s fine if you format all lists exactly the same way, but that is not true. At the very least, some lists are bulleted and some are numbered. And then there are nested lists, which are formatted differently from their parents, and specialized lists, such as lists of ingredients, definitions, or function parameters. How do you make sure each type of list gets formatted appropriately?</p>
<section>
<title>Extensibility</title>
<remark attribution ="RLH">
<p>This section troubles me. I see that you’re getting at the notion that we need extensibility in all three domains. However, you don’t say that directly, and you don’t really provide an answer regarding extensibility in the document domain. You ask the question “How do you make sure each type of list gets formatted appropriately?” in the previous section, but you don’t answer that question here, beyond suggesting ordered and unordered lists. In particular, pretty much all document-domain languages (with the exception of DITA) make it hard to create new document-domain structures. It’s much easier to create new media-domain styles. I’m not sure what to do here, but I suggest that you consider two things: does this section belong here at all (there is a reasonably clean seque if you simply drop this section)? and if it does, can you get more specific about what you mean with extensibility in the document domain?</p>
</remark>
<p>At this point it is worth looking at a very important feature of all structured writing systems: extensibility. In <phrase><annotation type="concept">media-domain</annotation></phrase> word processing and desktop publishing programs, authors may need many different styles to format their documents, and these applications do not attempt to anticipate or provide all the styles every author might need. Some, like Word, come with a basic set of styles that may meet some basic needs, but all these programs let authors define new styles as well. The set of document domain structures in these programs is small and fixed, but the set of media domain styles is extensible – you can create as many as you need.</p>
<p>A word processor or desktop publishing application that supports the definition of styles is essentially creating an extensible media domain environment. Styles are media domain structures that partition out a set of style information that you can attach to a block of text to specify how it will be displayed. Every time you create a new style you are extending your set of media domain structures.</p>
<p>This need for extensibility is another common pattern in structured writing. If you are working in the media domain, you may need to extend your set of styles. If you are working in the document domain, you may need to extend your set of <phrase><annotation type="concept">document domain</annotation></phrase> structures.</p>
<p>How many types do we need? One obvious formatting difference between lists is that some are numbered and some are bulleted. How does a formatting algorithm tell whether to use bullets or numbers to format a given list? One way would be to add a style attribute to specify bullets or numbers, but then the author would be working in the media domain again, breaking the partitioning we had hoped to achieve. To keep the author in the document domain, we need to create document domain structures that expresses different list types at the doc domain level.</p>
<p>The common way to handle bullets vs. numbers is to create two different list structures, the ordered list and the unordered list. Different markup languages call them by different names – <phrase><annotation type="structure" namespace="HTML">ol</annotation></phrase> and <phrase><annotation type="structure" namespace="HTML">ul</annotation></phrase> in HTML, <phrase><annotation type="structure" namespace="DocBook">orderedlist</annotation></phrase> and <phrase><annotation type="structure" namespace="DocBook">itemized-list</annotation></phrase> in DocBook, for example – but they are conceptually the same thing. (Thus the HTML example above is a little more specific than just being a list structure. It is an ordered list structure.)</p>
<p>The choice of the terms “unordered” and “ordered” is important, because it focuses on the <phrase><annotation type="concept">document-domain</annotation></phrase> properties of a list – whether its order matters – rather than on its <phrase><annotation type="concept">media domain</annotation></phrase> properties – bullets or numbers. Whether an ordered list should be formatted with numbers or letters or Roman numerals, belongs entirely to the <phrase><annotation type="concept">media domain</annotation></phrase>. It has been partitioned out of the <phrase><annotation type="concept">document domain</annotation></phrase> structures.</p>
</section>
<section>
<title>Context and structure</title>
<p>Does the need for separate ordered and unordered list objects imply that you need a separate document-domain list structure for every possible way a list might be formatted? No. In fact, that would really just be working in the media domain by proxy. When you work in the document domain, you think in terms of document structures, not formatting, which means that each document-domain object must make sense in the document domain, not the media domain. Otherwise, the partitioning falls apart.</p>
<p>For example, consider nested lists. Items in a nested list are formatted differently from the list that contains them. At a minimum, they are indented more and they usually have different number or bullet styles. In the <phrase><annotation type="concept">media domain</annotation></phrase>, you would need a different style for each level. However, you don’t need a separate nested list structure in the <phrase><annotation type="concept">document domain</annotation></phrase>. Instead, you express nesting by actually nesting one list inside another. For instance, in <citation type = "idref" value = "ex.nested-list"/> one ordered list is nested inside another ordered list:</p>
<figure id ="ex.nested-list">
<title>Nested list structure in HTML</title>
<codeblock language ="HTML">
&lt;ol&gt;
    &lt;li&gt;
        &lt;p&gt;Dogs&lt;/p&gt;
        &lt;ol&gt;
            &lt;li&gt;Spot&lt;/li&gt;
            &lt;li&gt;Rover&lt;/li&gt;
            &lt;li&gt;Fang&lt;/li&gt;
            &lt;li&gt;Fluffy&lt;/li&gt;
        &lt;/ol&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;p&gt;Cats&lt;/p&gt;
        &lt;ol&gt;
            &lt;li&gt;Mittens&lt;/li&gt;
            &lt;li&gt;Tobermory&lt;/li&gt;
        &lt;/ol&gt;
    &lt;/li&gt;
&lt;/ol&gt;
</codeblock>
</figure>
<p>In the <phrase><annotation type="concept">document domain</annotation></phrase> the inner and outer list are both identical <code>ol</code>/<code>li</code> structures. In the <phrase><annotation type="concept">media domain</annotation></phrase>, one will be formatted with Arabic numerals and the other with letters (see <citation type = "idref" value = "ex.nested-list-rendered"/>).</p>
<figure id ="ex.nested-list-rendered">
<title>Nested list rendered</title>
<ol>
<li>
<p>Dogs</p>
<ol>
<li>
<p>Spot</p>
</li>
<li>
<p>Rover</p>
</li>
<li>
<p>Fang</p>
</li>
<li>
<p>Fluffy</p>
</li>
</ol>
</li>
<li>
<p>Cats</p>
<ol>
<li>
<p>Mittens</p>
</li>
<li>
<p>Tobermory</p>
</li>
</ol>
</li>
</ol>
</figure>
<p>Both the inner and outer lists are ordered lists in the document domain, but in the media domain they are formatted differently based on context.</p>
<p>In this case, the algorithm that formats the page distinguishes the inner and outer lists by looking at their parents. For instance, <citation type = "idref" value = "ex.nested-css"/> shows a CSS rule for a list item nested one deep:</p>
<figure id ="ex.nested-css">
<title>CSS for nested list items</title>
<codeblock language ="css">
ol&gt;li&gt;ol&gt;li
{
    list-style-type: lower-alpha;
}
</codeblock>
</figure>
<p>The ability to distinguish structures by context enables you to reduce the number of structures you need to define, particularly in the document and subject domains. It also allows you to name structures more logically and intuitively, since you can name them for what they are, not how they are to be formatted or for where they reside in the hierarchy of the document.</p>
<p>It also points out another important difference between the way media-domain and document-domain writing is usually implemented. The media domain almost always uses a flat structure with paragraphs, tables, etc., following each other in sequence. For instance, Microsoft Word constructs a nested list as a flat sequence of paragraphs with different styles. Inner and outer lists are expressed purely by the indent applied to the paragraphs. (Word tries to maintain auto-numbering across nested list structures, but it does not always get it right.)</p>
<p>Document-domain structures are usually implemented hierarchically. List items are <phrase><annotation type="italic">inside</annotation></phrase> lists. Nested lists are <phrase><annotation type="italic">inside</annotation></phrase> list items. Sections are <phrase><annotation type="italic">inside</annotation></phrase> chapters. Subsections are sections <phrase><annotation type="italic">inside</annotation></phrase> other sections. Where the media domain typically only has before and after relationships (except in tables), the document domain adds inside and outside relationships to the mix. This use of nested, rather than flat, structures helps to create context, which helps to reduce the number of different structures you need. Just as we saw with the basic list structure, nested structures help partition logical document structures.</p>
<p>Some <phrase><annotation type="concept">document-domain</annotation></phrase> languages are more hierarchical than others. <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> is relatively flat. For example, it has six different heading styles <phrase><annotation type="structure" namespace="HTML">H1</annotation></phrase> through <phrase><annotation type="structure" namespace="HTML">H6</annotation></phrase>. <phrase><annotation type="language"><annotation type="standard">Docbook</annotation></annotation></phrase>, a widely used <phrase><annotation type="concept">document-domain</annotation></phrase> structured writing language, is much more hierarchical and has only one element for the same purpose: <code>title</code>. However, DocBook’s <code>title</code> element can occur inside 84 different elements and, therefore, can potentially be formatted in 84 different ways based on context. In fact, it can be formatted in more ways than that, since some of the elements that contain titles can also be nested in other elements, creating a hierarchical structure that provides even more contexts.</p>
<p>There is a balance to be struck here. Hierarchical structures are harder to create and can be harder to understand. They may require you to find just the right place in a hierarchy to insert a new piece of content, which is more difficult than simply starting a new paragraph in a word processor. This introduces complexity, and you need to make sure you don’t introduce more complexity than you take away.</p>
</section>
<section>
<title>Constraining document structure</title>
<p>Another important reason for working in the <phrase><annotation type="concept">document domain</annotation></phrase> is to constrain how documents are structured. For example, suppose you want to make sure that all graphics have a figure number, a title, and a caption. In the <phrase><annotation type="concept">media domain</annotation></phrase>, you can make styles available for figure numbers, titles, and captions, but you can’t enforce a rule that says all graphics must have these elements. In the document domain, you can express these constraints. You can make it illegal to place an image element anywhere in the document structure except within a figure that has a title and caption. A structure to implement this constraint might look like <citation type = "idref" value = "ex.figure-image"/>:</p>
<figure id ="ex.figure-image">
<title>Document-domain structure for a figure</title>
<codeblock language ="SAM">
figure:
    title: Cute kitty
    caption: This is a cute kitten.
    image: images/cute.jpg
</codeblock>
</figure>
<p>If the only way to include an image is to use the image element, and you only allow the image element inside the figure element, and you require the figure element to contain the title and the caption elements, then you can’t add a graphic without a figure, title, and caption. A document without these elements would be rejected by the <phrase><annotation type="algorithm" specifically="conformance algorithm">conformance algorithm</annotation></phrase> (see <citation type = "nameref" value = "chapter.conformance"/>).</p>
<p>This is an example of enforcing a constraint rather than factoring it out. However, it is still a form of partitioning because it constrains where images are allowed, which partitions off design questions about image handling. You still have to decide to use an image, but you only need to make that one decision, after which you have a specific structure that enforces the image constraint.</p>
<remark attribution ="RLH">
<p>I’m not sure you need a second example here. I don’t think the procedure example adds anything that you haven’t already said in the image example. I would drop the next two paragraphs. The HTML discussion is also a bit off target, though I think it’s a useful point. I’ve left the first two paragraphs in, but created a sub-section for the HTML discussion to set it apart some.</p>
</remark>
<p>There are many ways to constrain the structure of a document. In a typical <phrase><annotation type="concept">media-domain</annotation></phrase> application, you can apply paragraph styles in any order. If you want to put a level-two heading between two steps in a procedure, nothing other than common sense stands in the way. A document-domain language usually won’t allow that kind of structure.</p>
<p>Instead, the <phrase><annotation type="concept">document-domain</annotation></phrase> language constrains structures. For example, procedure structures have step structures nested within them, and step structures may appear only inside procedure structures. Steps can contain only a limited set of text elements, such as paragraphs, lists, or code blocks.</p>
<section>
<title>HTML and the document domain</title>
<p>You can see that constraints are important to document-domain languages. Without constraints, it is easy for a language to slip back into the media domain, something that has happened to HTML. Today, structured writing advocates often dismiss HTML as an unstructured language. They compare HTML, unfavorably, to languages such as DocBook or DITA, even though all three are document-domain languages at heart with many similar structures.</p>
<p>With the advent of CSS, HTML has largely become a set of basic document-domain structures that you can hang styles on. In other words, it is now used much like traditional media-domain word processing and desktop publishing applications, with writers taking back into their own hands formatting decisions that were supposed to be removed from them.</p>
<p>Why did this happen? When people write in HTML, they largely do so in WYSIWYG environments, using style-oriented tools that closely mimic traditional word processing. In other words, HTML may be a document-domain language, but people commonly create HTML using media-domain tools. The result is often an HTML document that formats more or less correctly but is coded inconsistently, which makes it hard to edit by hand or manipulate with algorithms.</p>
</section>
</section>
<section>
<title>Extending the document domain</title>
<p>Another factor in HTML’s slide into the media domain is that it provides only a fairly basic set of document-domain structures. As we have seen, enforcing or factoring out media-domain constraints requires document-domain structures. But the possible list of such structures is quite large. There are a few basic features that are common to all documents, such as paragraphs, lists, and titles. But these structures alone are not enough to hang meaningful and useful document-domain constraints on or to fully partition the content of a document from its formatting, which is why extensibility is important.</p>
<p>For example, consider a bibliography. A bibliography is a document structure for listing works cited in a document. It generally consists of the heading “Bibliography” followed by a set of paragraphs listing the cited works. In the media domain, you can easily create such a structure. It is just a sequence of paragraphs with some bold and italic formatting for author names, book titles, etc.</p>
<p>In your media-domain stylesheet, you may have some character styles for things like <code>author-name</code> or <code>book-title</code>. You may even have a paragraph style for bibliography entries, but you typically don’t have much more specific support.</p>
<p>But these few styles can’t cover all the rules your publisher or organization places on bibliographies. You probably have to follow rules that detail how to handle titles, author names, and so forth. These constraints are not enforced by media-domain styles. You have to learn and follow these constraints for yourself. If you want to remove these decisions, you need a document-domain structure for a bibliography. <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> has one (see <citation type = "idref" value = "ex.bib-docbook"/>).</p>
<figure id ="ex.bib-docbook">
<title>DocBook bibliography entry</title>
<codeblock language ="docbook">
&lt;biblioentry id="bib.xsltrec"&gt;
  &lt;abbrev id="bib.xsltrec.abbrev"&gt;REC-XSLT&lt;/abbrev&gt;   
  &lt;editor&gt;
     &lt;firstname&gt;James&lt;/firstname&gt;
     &lt;surname&gt;Clark&lt;/surname&gt;
  &lt;/editor&gt;
  &lt;title&gt;
    &lt;ulink url="http://www.w3.org/TR/xslt"&gt;XSL Transformations
    (XSLT) Version 1.0&lt;/ulink&gt;
  &lt;/title&gt;
  &lt;publishername&gt;W3C Recommendation&lt;/publishername&gt;
  &lt;pubdate&gt;16 November 1999&lt;/pubdate&gt;
&lt;/biblioentry&gt;
</codeblock>
</figure>
<p><citation type = "idref" value = "ex.bib-docbook"/> is in XML, which can be hard to read, so here (<citation type = "idref" value = "ex.bib-sam"/>) is the same structure using the markup notation have used in earlier examples.</p>
<figure id ="ex.bib-sam">
<title>Bibliography entry using simpler markup</title>
<codeblock language ="SAM">
biblioentry:(#bib.xslttrec)
    abbrev:(#bib.xsltrec.abbrev) REC-XSLT
    editor:
        firstname: James 
        surname: Clark
    title: XSL Transformations (XSLT) Version 1.0
    publishername: W3C Recommendation
    pubdate: 16 November 1999
</codeblock>
</figure>
<p>This structure does not just constrain how bibliography entries are presented and formatted, it also factors out many of those constraints by breaking down the components of a bibliography entry into separate labeled fields. Given a <phrase><annotation type="structure" namespace="DocBook">biblioentry</annotation></phrase> structure like this, you could create an algorithm to present and format a bibliography entry almost any way you wanted to. This structure not only partitions the formatting of the bibliography from the presentation of the bibliography, it also partitions the presentation from the underlying bibliographical data. This means you could write an algorithm to extract bibliography information from a document by looking for <phrase><annotation type="structure" namespace="DocBook">biblioentry</annotation></phrase> structures and extracting the desired information from them. For instance, if you want to build a list of authors cited in the document, you could do so by searching the <phrase><annotation type="structure" namespace="DocBook">biblioentry</annotation></phrase> records and extracting the name of the authors from the structures that record them in the bibliography structure.</p>
<p>This begins to hint at the sort of things we can do with our content when we move to the <phrase><annotation type="concept">subject domain</annotation></phrase>.</p>
</section>
</chapter>
