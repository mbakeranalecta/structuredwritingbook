<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.writing">
<title>Writing</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">DITA</annotation></phrase> <phrase><annotation type="language">DocBook</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">HTML</annotation></phrase> <phrase><annotation type="language">XML</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm">composition</annotation></phrase> <phrase><annotation type="algorithm">conformance algorithm</annotation></phrase> <phrase><annotation type="algorithm">conformance</annotation></phrase> <phrase><annotation type="algorithm">content management algorithm</annotation></phrase> <phrase><annotation type="algorithm">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract and merge algorithm</annotation></phrase> <phrase><annotation type="algorithm">extract and merge</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">Content management systems</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase></p>
</annotations>
<p>A comprehensive approach to managing the content creation and delivery process means partitioning and directing the complexity of that process to the right people and processes. While there are parts of that process that are separate from the tasks of the writer, most of the complexity of the content process flows through the writer. And because the writer’s attention is a limited and valuable resource that is indispensable for the creation of quality content, much of the effort in designing the content process should be focused on partitioning and directing complexity away from the writer.</p>
<p>However, because complexity cannot be destroyed, only redirected, it is vital that we don’t drop any of that complexity in the process of directing it away from the writer, because then it falls on the reader. This means that when we move a chunk of complexity out of the writer’s world, we always have to ask the writer to supply enough information to complete the transfer without loss. Thus when we use styles to partition and direct the complexity of document formatting to a designer and and algorithm, we have to ask the writer to apply those styles correctly to the content they create.</p>
<p>Structured writing can partition and redirect a huge amount of the complexity of content creation -- including complexity that you are just not handling now, and which is therefore falling on your readers -- but it all starts with writers creating the right structures as they write.</p>
<p>Structures are the interfaces between the partitions in which we contain the complexity of our processes. Just as software developers partition software complexity behind an API, so information architects and content engineers partition content complexity behind content structure expressed as structured writing markup.</p>
<p>These structures are a system of constraints. They tell writers what is an is not a valid way to structured their writing. Constraints are the substance of partitioning. They tell you both what you cannot do and what you must do both to maintain the integrity of the partition, and to pass the required information into the partition so that it can play its proper part in the overall content system, ensuring that no complexity goes unhandled.</p>
<p>Our structured writing system, therefore, can only be a good as the structured content our writers create. Getting the best possible structure from our writers is key to all of the algorithms and all of the benefits of structured writing. This is not something we can afford to leave to chance. We need to be systematic about it.</p>
<p>All forms of structured writing, even in the <phrase><annotation type="concept">media domain</annotation></phrase> require writers to do something other than simply write. Since writing is an intellectually challenging activity that requires full attention, adding structured writing requirements into the mix necessarily takes away some of the attention that should otherwise be given to content, which obviously has the potential to reduce the quality of the content. Clearly, therefore, we need to make sure that the intrusion of structured writing requirements onto the writing process is a minimal as possible and that it removes more complexity than in introduces.</p>
<p>Quality writing does not result from an writer simply spilling words onto a page or screen in stream of consciousness fashion. Writing is a design activity. It creates a structure of words that conveys complex ideas and information about the real world. It very much matters that the writer says the right things using the right words in the right order. If structured writing techniques can help with this literary design work, they can lessen the intellectual burden on the writer, and thus potentially improve the quality of the content. This is a major area in which structured writing can redirect complexity away from the writer, particularly when the writer is an occasional contributor.</p>
<p>Of course, structured writing can improve <phrase><annotation type="algorithm">content quality</annotation></phrase> in other ways. Most of the algorithms we will look at pertain to content quality in one way or another, such as improved linking or better management of terminology. Still, these algorithms work on the structures that the writers create. If those structures are incorrect or inconsistent, there is a limit to what downstream algorithms can do to improve quality. It really all begins with getting writers to reliably create the required structures as they write.</p>
<p>In media-domain systems like word processors and desktop publishing systems, the writer is asked to think about formatting structures while writing. One of the traditional arguments for structured writing is to relieve the writer of the burden of thinking about (and manipulating) formatting so they can focus on writing. This means moving to the document domain. But in the document domain, the writer has a new set of structures to think about: document domain structures. Is it easier on the writer to think about and manipulate document domain structures rather than media domain structures? In some cases, yes. For instance, writing a blog post or a web page in MarkDown may be less cumbersome for some writers than using a WYSIWYG HTML editor.</p>
<p>However, Markdown does not contain enough structure, or enough constraints on its structure, to enable many of the structured writing algorithms we will be looking at. If we want to support these algorithms, we will need something more structured, and this can easily mean something that requires more of the writer’s attention. If we are proposing to implement management-intensive algorithms, such as <phrase><annotation type="algorithm">reuse</annotation></phrase>, it can mean that writers need to learn and manipulate an entire management system and the management policies that the organization puts in place around it. Depending on how complex these policies are and how foreign they are to the writer’s experience, this can create a burden far greater than that of creating and manipulating formatting according to a style guide.</p>
<p>We could look at this and say, okay, yes, writing is now more difficult and more complex than it was before because of all this additional structure and all that writers need to learn to apply that structure, but we are getting additional advantages as well, such as reuse and content management, so it is worth it overall. The problem is, attention is a finite resource. Writing is a task that takes full attention, so any requirement added to the task takes attention away from writing. As writing get more difficult, writers do all of the component tasks less well. The more of the writer’s attention is required on structure, the less is available for writing, and the quality of the writing suffers. The writer is dealing with more complexity than they are equipped to handle and some of it inevitably falls through to the reader.</p>
<p>As the quality of the writing suffers, the writer becomes frustrated with the system, and becomes more interested in getting their ideas down than in obeying the onerous structural rules that are getting in their way. When that happens, the quality of the structure suffers as well. And if both the quality of the writing and the quality of the structures decline, all of your algorithms become less reliable, compromising all of benefits you hoped to obtain. Too much complexity dumped on any one person or process compromizes all downstream persons and processes.</p>
<p>To look at this another way, the more complex your system becomes, and the more algorithms you are attempting to support, the more important <phrase><annotation type="algorithm">conformance</annotation></phrase> to its constraints becomes. But conformance is fundamentally a human activity. It is that writer who must conform. Good conformance results from creating structures that are easy to conform to. It all begins with writing. Unfortunately, writing is often the last thing people think about in designing content management and structured writing systems. It is the place that complexity get dumped before it eventually gets dumped on readers.</p>
<p>One of the most familiar tropes of the content management industry is that problems with content management systems are not technology problems, they are human problems. The solution, this trope suggests, lies in better change management and more training. The presumption here is that the tools work fine if only you give them correct input. If the input is not correct, that is the fault of the humans who created the input. But this is an argument we would not accept for any other kind of system. For any other kind of system we would say, “this system is too hard to use”, not “the problem is everybody needs to be better trained and more accepting of change”. The real fault here is poor system design. If humans cannot conform to the structures that the system requires, the fault is in the system design. It is not partitioning and distributing complexity correctly. The structures should be redesigned to be easier to conform to. (We will look at this in more detail in <citation type="nameref" value="chapter.conformance"/>.)</p>
<p>How is designing structures for ease of writing consistent with designing them to match the specific constraints that we want to impose for the sake of quality and efficient processing? As we have seen, moving from the <phrase><annotation type="concept">media domain</annotation></phrase> to the <phrase><annotation type="concept">document domain</annotation></phrase> allows us to factor out or impose certain structural constraints, but often require the introduction of the management domain to impose content management constraints. These complexities detract from ease of writing. But we have also seen that by moving to the subject domain we can factor out many of the document domain and management domain structures. Designing structures for writing, therefore, often consists of factoring out complex publishing and content management structures using subject-domain structures that are lucid for writers.</p>
<p>One of the most important consequences of this, both for ease of writing and reliability of data, is that in the subject domain, you are not asking the writer to think, and to structure content, in terms of algorithms. In this sense, the move to the subject domain not only factors out specific constraints from the writer, it factors out the need to think in algorithms at all, leaving the writer free to think in terms of subject matter. This freedom to focus on content is a property I call functional lucidity.</p>
<section>
<title>Functional lucidity</title>
<p>Functional lucidity means the way that you actually use language when you are writing, which is to say the way that you use language when you are in the throes of figuring out what you want to say and how you want to say it. If you are asked to add markup to your content as you write, if you are asked to shape your content according to the constraints that a structured writing language dictates, then the lucidity of that markup and the structures it defines are vital to your success. The names of the structures, the order in which they occur should spring into your mind as readily (if not more so) that the words and phrases and ideas you are trying to record.</p>
<p>As anyone who has struggled to write even a paragraph in a language they are only beginning to learn can attest, writing in a language in which you are not fluent is painful. The effort of finding words and correct grammatical structures takes all of the attention that should be reserved for what you are trying to say. Writing in a markup language where the structures don’t make intuitive sense, where they don’t seem to fit the thoughts you are trying to express, is very much like this. Lucidity is essential to avoid having the markup absorb all of the attention that should be focused on the content.</p>
<p>Functional lucidity is not an absolute property, of course. What is lucid for one writer may be opaque to another. In particular, professional technical writers who have been used to writing in structured <phrase><annotation type="concept">document domain</annotation></phrase> templates in applications like FrameMaker may find a markup language like <phrase><annotation type="language">DocBook</annotation></phrase> functionally lucid, whereas someone not used to thinking in these terms would find it difficult and distracting. On the other hand, those writers used to FrameMaker often find DITA’s structure difficult to get used to because they do not find its approach to topics lucid. To still others it seems very natural.</p>
<p>But while different writers may have different degrees of experience and familiarity with abstract document structures, all writers should have familiarity with the subject matter they are writing about. Thus a well-designed <phrase><annotation type="concept">subject domain</annotation></phrase> language tends to naturally have functional lucidity for everyone who is likely to use it. (Though writers can sometimes disagree about what needs to be said on a subject and how it should be said.)</p>
</section>
<section>
<title>Simplicity and Clarity</title>
<p>One of the biggest benefits of subject domain markup for writers is a much higher degree of functional lucidity compared with a typical document domain language.</p>
<p>While a general document domain language like <phrase><annotation type="language">DocBook</annotation></phrase> needs to have a wide range of document structures, a recipe markup language such as we developed in <citation type="nameref" value="chapter.subject-domain"/>, has only a few simple structures. Better still, there are very few permutations of those structures. Because subject domain languages do not specify document order, we don’t need to allow for many possible document orderings in the language, thus reducing the permutations we have to allow for and deal with.</p>
<p>Because subject domain structure describe the subject matter they contain, they are also much clearer to writers, who may not understand complex document structures (or, more often, the subtle distinctions between several similar document structures), but who do (we hope) understand their subject matter.</p>
<p>The combination of simplicity and clarity mean that in many cases you can get writers to create subject-domain structured content with little or no training. For instance, even if we add some additional fields to our recipe markup, you could still hand a sample like the one below to an writer and ask them to follow it as a template, without giving them any training or any special tools.</p>
<codeblock language="sam">
recipe: Hard Boiled Egg
    introduction:
        A hard boiled egg is simple and nutritious.
    ingredients:: ingredient, quantity
        eggs, 12
        water, 2qt
    preparation:
        1. Place eggs in pan and cover with water.
        2. Bring water to a boil.
        3. Remove from heat and cover for 12 minutes.
        4. Place eggs in cold water to stop cooking.
        5. Peel and serve.
    prep-time: 15 minutes
    serves: 6
    wine-match: champagne and orange juice
    beverage-match: orange juice
    nutrition:
        serving: 1 large (50 g)
        calories: 78
        total-fat: 5 g
        saturated-fat: 0.7 g
        polyunsaturated-fat: 0.7 g    
        monounsaturated-fat: 2 g    
        cholesterol: 186.5 mg    
        sodium: 62 mg    
        potassium: 63 mg    
        total-carbohydrate: 0.6 g    
        dietary-fiber: 0 g    
        sugar: 0.6 g    
        protein: 6 g    
</codeblock>
<p>Of course, the downside is that recipe markup is only good for one thing: recipes. Complexity is never destroyed, only moved somewhere else. So this approach moves complexity away from the writer to the person who has to design and maintain these structures and the algorithms that process them. (Information Architect and Content Engineer are both titles sometimes used for the person with this responsibility.)</p>
<p>This can seen scary because we are not used to partitioning complexity in this way. But then, we also recognize that the way we have partitioned complexity in the past has not been as successful as we would like -- that it has, in fact, left much of the complexity of content creation unhandled, resulting in that complexity being dumped on our readers. If a new partitioning of the complexity of the content creation process is required, we have to accept that some of these new methods of partitioning will be unfamiliar. They are the place where previously unhandled complexity that used to get dumped on the reader is now being handled.</p>
</section>
<section>
<title>Mechanical vs conceptual complexity</title>
<p>This seems like a good place to make an important point about complexity in the content system. The complexity of the content structuring task has two parts: mechanical complexity and conceptual complexity.</p>
<p>Mechanical complexity arises from the manipulation of the tools themselves. XML is more mechanically complex than Markdown, for instance. FrameMaker is more mechanically complex than Notepad.</p>
<p>Conceptual complexity arises when the operation you are performing is itself complex, regardless of the tools you use to do it. Content reuse is conceptually complex -- there are a number of factors to consider and a number of things you have to get right in order for content to be reusable and to reuse it correctly.</p>
<p>Processes that are conceptually complex often tend to be mechanically complex as well. Conceptually complex operations often involve making many choices. The conceptual complexity lies in how difficult those choices are to make and how interdependent they are. But there mere presence of choices as well as the need to track their dependencies makes for complex interfaces, and therefore for mechanical complexity in tools.</p>
<p>Many tools are advertised as making complex systems easy to use are really only trying to address mechanical complexity. Such tools will advertize what they will often call a “Word-like” intreface over conceptually complex systems like DITA or DocBook, providing buttons to insert complext markup structures and managing things like includes and IDs. But while such interfaces can reduce the mechnaical complexity somewhat (particulary the mechanical complexity of ealing with XML tags) they remain mechanically complex because of the conceptual complexity underneath. Indeed, in some cases they can actually make the conceptual complexity worse by hinding the structurs underneath. Thus certain editing operations can become more complex because the writer cannot see exactly which structure they have cut or identify exactly which location in the document structure they can legally paste the structures they are moving. Editor have to introduce new mechanical complexity to help authors deal with this problem (though many authors do not attempt to do complex structurual edits in the editors graphical view but switch to the raw XML view where they can see the structures they are dealing with.)</p>
<p>The best way to reduce the complexity of the authoring task, therefore, is not to attack the mechancial complexity but to attack the conceptual complexity of what the writer is being asked to do. And becasue much of the mechanical complexity of a tool arises from the the conceptual complexity of the format, attacking conceptual complexity kills two birds with one stone. In the following chapters we will see have the right techiques (usually in the subject domain) can reduce the concpetual complexity of many structured writing algorithsm. And becasue such techniques also reduce mecahnical complexity significantly, they have the capacity to produce significant savings in tool costs, as well as significant improvements in quality.</p>
</section>
</chapter>
