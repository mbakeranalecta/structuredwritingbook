<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.blocks">
<title>Blocks, fragments, paragraphs, and phrases</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="process">conformance</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforming</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> <phrase><annotation type="process">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<p>I said that the structure of a structured writing document is made up of nested blocks. The question is, how do I design a content structure as a set of nested blocks. To begin we should look at the different types of blocks you might create, their purpose, and how they relate to each other. While most markup systems don’t make a high-level distinction between different types of blocks (in XML, they are all elements, for instance), from a language design point of view it is useful to break down blocks into different types, each of which requires a different kind of design focus.</p>
<section>
<title>Semantic blocks</title>
<p>If we asked a writer to describe the things that make up a document, they would probably name things like paragraphs, tables, and lists. If we asked about a particular type of document, such as a recipe, they would probably say things like introduction, ingredients, and preparation steps. A structured writing language will typically be much more fine grained than this. A table, for instance, may be made up of dozens of smaller structures like rows, cells, and cell contents. But tables, procedures, and list are the units that have meaning to writers independent of how they are constructed internally. Without knowing anything about the mechanics of structured writing, a writer could design the rhetorical structure of a piece of content as a set of such blocks. They might say, for instance, that a recipe consists of an three main blocks: introduction, ingredients, and preparation, without thinking about markup languages at all.</p>
<p>At the risk of adding further burden to an already overloaded term, I am going to call these recognizable objects “<phrase><annotation type="concept">semantic blocks</annotation></phrase>” because they are blocks that mean something in whichever domain they belong to. Higher level markup design is essentially a matter of defining semantic blocks and the ways they go together.</p>
<p>An easy example of a semantic block is a list. (Note that I am not using “semantic” to mean subject domain; blocks have semantics in all domains.) A list is a semantic block because “list” is an idea with meaning in the document domain independent of its exact internal structure. A writer can say to themselves, “I want a list here”, independent of any specifics of markup. If a structure has a name like this in the real world, the block that implements it (in the terminology I am coining for this purpose) is a semantic block.</p>
<p>Semantic blocks generally contain other blocks that we might not talk about independently if we did not need to describe the detailed construction of a semantic block. I will call these “structural blocks”. Structural blocks are the construction details of a structured document. By analogy, if a window were a semantic block in architectural terms, the lintel, sash, and jamb are structural blocks.</p>
<p>Don’t think of the distinction between a semantic block and a structural block as being hard and fast. The distinction has more to do with design intent that any concrete characteristic. The main point of making the distinction is to encourage you to think of markup design first in terms of semantic blocks. Blocks, with whatever internal structure you require, that will capture the structure of something that is real and meaningful to you. Don’t get bogged down in the precise internal structure of semantic blocks until you figure out which semantic blocks you need.</p>
<p>Different markup languages often construct the same semantic block differently. <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>, <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase>, and <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> all define lists, and each of them defines the internals of a list differently. Nonetheless we recognize that each of them is an implementation of the idea of a list and for most purposes you could markup your content with any one of them without any loss of functionality.</p>
<p>A list is made up of structural blocks that build the shape of a list. I’ll illustrate this with XML since it makes the blocks explicit:</p>
<codeblock language="xml">

&lt;ol&gt;
    &lt;li&gt;
        &lt;p&gt;This is the first item.&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;p&gt;This is the second item.&lt;/p&gt;
    &lt;/li&gt;
&lt;/ol&gt;
</codeblock>
<p>Here the semantic block is the ordered list bounded by the <code>ol</code> tags. The <code>li</code> and <code>p</code> tags inside are structural blocks that together implement the structure of an ordered list. (Since we would tend to regard paragraphs as semantic blocks, albeit relatively simple ones, this illustrates that a semantic block can also be a structural block for a larger semantic structure.)</p>
<p>Other <phrase><annotation type="concept">document domain</annotation></phrase> examples of semantic blocks include <phrase><annotation type="structure">tables</annotation></phrase> and <phrase><annotation type="structure">procedures</annotation></phrase>. (Again you will find that DocBook, DITA, and HTML, not to mention S1000D, and <phrase><annotation type="language">reStructuredtext</annotation></phrase>, all have tables, all with different internal structures, and that both DocBook and DITA have procedures, again internally different. It is possible to disagree greatly about how to structure a semantic block while still recognizing different implementations as examples of the same semantic block.)</p>
<p>In the subject domain, examples of semantic blocks would include the ingredients list from the recipe example we have been using:</p>
<codeblock language="sam">

ingredients:: ingredient, quantity, unit
    eggs, 3, each
    salt, 1, tsp
    butter, .5, cup
</codeblock>
<p>and the parameter description from an API reference:</p>
<codeblock language="sam">

parameter: string
    required: yes
    description:
        The string to print.
</codeblock>
<p>One characteristic of semantic blocks is that they often tend to repeat as a unit, as this example does in an API reference entry:</p>
<codeblock language="sam">

function: print
    return-value: none
    parameters:
        parameter: string
            required: yes
            description:
                The string to print.
        parameter: end
            required: no
            default: '\n'
            description:
                The characters to output after the {string}(parameter).
</codeblock>
<p>They may also be used as a unit in different places in a markup language, or in different markup languages. For instance, the ordered list semantic block may be allowed in more than one place in a document domain language, such as in a section or in a table cell.</p>
<p>In fact, if you have multiple markup languages in your content system, particularly multiple subject domain languages, then it makes a lot of sense to define a common set of semantic blocks for use across all of these languages. Thus if you have five subject-domain languages that all require lists, you use the same list structure across all five of those languages.</p>
<p>This means that you can define the structure of a list once, and define all of the algorithms that work on lists once, and reuse them for all of the subject-domain languages that share those structures. It also means that your authors only have to learn one definition for each semantic structure, which makes it much easier for them to learn several different subject domain languages, since many of the details are the same.</p>
<p>This means that each subject domain language only has to define, and provide processing algorithms for, those structures that are unique to the subject matter. All the other structures you need to create content in your environment are already defined, tested, and ready to use. This makes it much quicker and simpler to design and implement a new subject domain language when you need one.</p>
<p>Designing in terms of semantic blocks not only helps keep markup design and processing simpler, it also improves <phrase><annotation type="concept">functional lucidity</annotation></phrase>. Present the markup language to the writer as a set of familiar objects like lists or tables, or logical structures like ingredient list or parameter description, rather than a sea of tags, and the task becomes easier to understand (and the tags easier to remember).</p>
<p>Semantic blocks also make things easier for tools. An XML editor that implements a WYSIWYG interface to XML authoring may provide tool bar buttons for inserting semantic blocks such as lists or tables. This allows the author to enter these blocks as complete structures rather than having to enter all the tags that comprise them separately.</p>
<p>The structure of a semantic block can be strict or loose. A strict semantic block has one basic structure with few options. A loose one allows a much wider variety of structure inside, sometimes to the point that it acts more as a semantic wrapper than a defined semantic block.</p>
<p><phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> is an example of a language with very loose semantic blocks. DocBook has the same high-level semantic blocks as any other generalized document domain markup language, but so many tags are allowed in so many places that none of these objects are simple and easy to understand. This supports DocBook’s goal of being able to describe almost any document structure you might want to create, but at the expense of functional lucidity and constraint.</p>
<p>How do you balance flexibility with functional lucidity and constraint in creating semantic blocks? Sometimes it is best to have more than one implementation of a particular semantic block. For instance, both DITA and DocBook have two tables model, as simple model and a more complex one based on the CALS table model.</p>
</section>
<section>
<title>Information typing blocks</title>
<p>We have looked at examples of <phrase><annotation type="concept">semantic blocks</annotation></phrase> whose semantics are in the <phrase><annotation type="concept">document domain</annotation></phrase> (lists and tables) and in the <phrase><annotation type="concept">subject domain</annotation></phrase> (ingredients list and parameter description). There is another way in which some structured writing systems divide content into blocks, which is according to the type of information they contain. I’m going to call these information typing block, since the practice of dividing content into such blocks is commonly called “information typing” (though this is obviously not the only thing the words “information typing” could refer to, since all structured writing assigns information to types).</p>
<p>An information typing block is a type of semantic block, but information typing blocks introduce a degree of abstraction not found with most semantic blocks. Unless they have been trained in an information typing system such as Information Mapping or DITA, most writers are not going to naturally describe the rhetorical structure of their content in terms of information typing blocks.</p>
<p><phrase><annotation type="tool">Information Mapping</annotation></phrase> is a structured writing system which views all content as being made up of just six types of information block: Procedure, Process, Principle, Concept, Structure, and Fact. These are information typing blocks. They don’t directly describe a physical or logical element of document structure (except for procedure), nor are they specific to any one subject. They describe the kind of idea that the content conveys – they are actually based on a theory about how humans receive information.</p>
<p>Which structured writing domain do information typing blocks belong to? Clearly they are not <phrase>media</phrase>, <phrase>subject</phrase>, or <phrase><annotation type="concept">management domain</annotation></phrase> structures. Are they a kind of <phrase><annotation type="concept">document domain</annotation></phrase> structure or something else again? I believe it is more useful to regard them as document domain structures than to invent another domain. Information mapping is a theory about the construction of documents to make them more effective. It regards a document as a mapping of information typing blocks, so Information Mapping’s information typing blocks are components of documents, and therefore in the document domain.</p>
<p><phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> also adopted this idea of documents being made up of information typing blocks. In DITA’s case, these blocks are named topics, which leads to some confusion since the word topic can be used to refer to both information typing block, and also to a complete document (as in a “help topic” for instance).</p>
<p>DITA has popularized the idea that all content (or all technical content, at least) is made up of just three information typing blocks: concept, task, and reference.<citation type = "idref" value = "1"/> (DITA actually defines more topic types than this today.) This idea is appealing because it is simple and it is easy to see a correspondence between these three types and the reader activities of learning (concept), doing (task), and looking stuff up (reference). The question is whether it provides adequate or appropriate constraints for your content, and whether it is useful for partitioning the complexity of your content system.</p>
<footnote id="1">
<p>There is evidence that DITA is moving away from this vision of information typing. In DITA 1.3, the technical committee puts the emphasis on topic and map as the core types, rather than concept, task and reference.</p>
<blockquote>
<citation type = "citation" value = "http://docs.oasis-open.org/dita/dita-1.3-why-three-editions/v1.0/cn01/dita-1.3-why-three-editions-v1.0-cn01.html#focus-of-dita"/>
<p>The DITA Technical Committee wants to emphasize that topic and map are the base document types in the architecture.</p>
<p>Because DITA was originally developed within IBM as a solution for technical documentation, early information about DITA stressed the importance of the concept, task, and reference topics.</p>
<p>Many regarded the topic document type as nothing more than a specialization base for concept, task, and reference.</p>
<p>While this perspective might still be valid for technical content, times have changed. DITA now is used in many other contexts, and people developing content for these other contexts need new specializations. For example, nurses who develop evidence-based care sheets might need a topic specialization that has sections for evidence, impact on current practices, and bibliographic references.</p>
</blockquote>
<p>The fact that the example of evidence-based care sheets clearly would include information from more than one of the abstract types, and that it is proposed as a specialization of topic rather than of concept, task, or reference, suggests a significant shift in thinking on this point, and that may indicate a shift away from abstract information typing towards a more concrete subject-domain approach.</p>
</footnote>
<p>This simple triptych is also appealing because it promises (though it does not necessarily deliver) easy <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> for <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase>. Some people also maintain that it makes content easier to access for readers, though others (myself included) criticizes it on the ground that it tends to break content down too finely for be useful and robs content of its narrative thread. Also, since neither Information Mapping nor DITA provide any mechanism for constraining how information typing blocks go together to form documents, they do not provide much support of creating and maintaining repeatable rhetorical structures. (This does not mean that authors can’t create such structures, but the complexity of doing so falls entirely on them, with the added complexity of having to construct the rhetorical structure out of jigsaw puzzle of abstract information typing blocks.) DITA, however, does allow you to create much more specific content types. See <citation type = "nameref" value = "chapter.extensible"/> for more details.</p>
<p>This abstract information typing is entirely distinct from the subject-based information typing of the subject domain. <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> and <phrase><annotation type="tool">Information Mapping</annotation></phrase>’s approaches are broad and analytical, trying to find commonalities across many different kinds of information. The subject domain is very much specific and synthetic, concerned which how specific pieces go together to successfully describe a particular subject. Both approaches break content up into blocks, and the subject-specific blocks of the subject domain can probably be categorized according to the information typology of either <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> or <phrase><annotation type="tool">Information Mapping</annotation></phrase>.</p>
<p>From a design point of view, the question is whether is is easier to arrive at a concrete structure for describing a particular subject by simply observing in concrete terms the particular pieces of information that are required to describe that subject, or by first identifying its abstract type and then deriving a specific type by extension or specialization of the abstract type. This is probably an area in which it depends on the designer’s habits of mind. For me, defining specific types in concrete terms based on observed information needs is simple and more straightforward, but the result matters more than the process in these things and you should take which ever approach works for you.</p>
</section>
<section>
<title>Rhetorical blocks</title>
<p>Neither semantic blocks nor information typing blocks constitute a complete piece of content suitable for the reader to read. That unit is the unit that is rhetorically complete: that accomplishes the information transfer to the reader. I will call it the rhetorical block. Rhetorical structure is the structure of the rhetorical block. The structure of a rhetorical block is made of up smaller semantic and structural blocks, but it is the structure of the rhetorical block that provides control over the completeness and repeatability of a content type. The question is, does the rhetorical block have a consistent repeatable structure that we can successfully model and control?</p>
<p>Part of the attraction of information typing theory is that you can divide everything you write into information typing blocks. (It does not matter if your information typing system has three, six, or thirty types, everything fits because there is always one type in the system that is effectively “everything else”.) And because maps are not constrained in an information typing system, there are no limits on how you can put information typing blocks together to form rhetorical blocks. You can apply information mapping to everything you write. You can apply out-of-the-box DITA (with more or less struggle) to everything you write.</p>
<p>The question is, does doing this enable you to better partition and distribute the complexity of content creation in your organization leading to better content being delivered to your readers? Or would that complexity be better partitioned and distributed by a system that constrained the rhetorical block? As we have seen, there are many advantages to constraining the rhetorical block, but the key advantage is <phrase><annotation type="algorithm">repeatability</annotation></phrase>. This is not simply because repeatability allows you to produce quality content more quickly and reliably. It is also because it makes content quality testable in a repeatable manner. You don’t just test the quality of an individual piece, but of a repeatable pattern.</p>
<p>Do all rhetorical blocks have a repeatable pattern? Certainly not. This book is a rhetorical block, but it does not have a repeatable pattern that one could define as a specific data structure. (Hopefully there is a structure to its rhetoric, but it is not one that lends itself to modeling as a set of nested blocks.) Much as this book encourages the use of the <phrase><annotation type="concept">subject domain</annotation></phrase> for structured writing, it was not written in the subject domain. It was written in <phrase><annotation type="language">SAM</annotation></phrase> syntax in a small constrained document domain language with a number of subject-domain annotations for things like markup languages, markup concepts, and processing tools.</p>
<p>But not all physical books constitute a single rhetorical block. Many books, such as cookbooks, are collections of related rhetorical blocks, such as recipes. Not only can you define a repeatable rhetorical block for a recipe, doing so provides significant benefits for most of the structured writing algorithms and allows you to effectively partition and direct the content complexity of a cookbook publisher or a magazine publisher that inserts recipes into many different publications.</p>
<p>Where you can reasonably define repeatably structured rhetorical blocks in your content, there are good reasons to do so. This can mean one of two things. It can mean taking the rhetorical blocks that you produce now, identifying those that could be repeatably structured, and developing a structured to contain and constrain them. This may involve moving some content around, since the applications of a repeatable structure will inevitably reveal that some content is in the wrong place, some is missing, and some is superfluous. But overall, this is reasonably straightforward process.</p>
<p>On the other hand, it can mean taking material that is currently in long discursive rhetorical blocks (like text books) and moving it to much shorter and more structured rhetorical blocks (like recipes or encyclopedia articles). Breaking material into smaller rhetorical units is not a new idea. It has been practiced in encyclopedias and periodicals for centuries and it has greatly accelerated in the age of the Web, which has not only improved our access to information, it has radically changed how we seek and use information, creating a style called <phrase><citation type = "citation" value = "https://www.nngroup.com/articles/information-scent/">information snacking</citation></phrase> in which we reach for discrete pieces of information as and when we need them, confident that we will always be able to rapidly find and read what we need when the time arises.<citation type = "idref" value = "2"/> In other words, people prefer to consume content in shorter rhetorical blocks (not because they need to know less, but because they need to know less at a time), so it makes sense to refactor your content and its architecture into a collection of smaller rhetorical blocks.</p>
<footnote id="2">
<p>I discuss this change of information seeking and consuming habits in my book, <phrase><annotation type="citetitle">Every Page is Page One: Topic-based Writing for Technical Communication and the Web</annotation></phrase>.</p>
</footnote>
<p>This transformation to shorter rhetorical blocks is often called “topic-based writing” but that term has become quite confusing because it is also used to mean a system in which instead of writing in long rhetorical blocks, individual writers write independent information typing blocks which are then compiled into long rhetorical blocks, often by somebody else. The confusion caused by giving these two very different approach the same name is that some people have started to think that topic-based writing means writing information typing blocks and then publishing them separately as if they were rhetorical blocks. This confusions is compounded by <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>’s decision to call their information typing blocks “topics” (Information Mapping calls them “blocks”) and by the fact publishing each information typing block separately is the default behavior when you publish a DITA map to the web.</p>
<p>But while a single information typing block may sometimes be a rhetorical block all by itself, this is often not the case. Whether one believes in the usefulness of information typing theory or not, it is clear that most useful rhetorical blocks contain more than one type of information.</p>
<p>I have attempted to distinguish topics as complete rhetorical blocks from topics as information typing blocks by coining the term “Every Page is Page One topic.” Why “Every Page is Page One”? Because a complete rhetorical block, regardless of its length, is a block that an information snacking reader will consume independently of any larger work or collection in which it is embedded. It is page one for that reader. And since information snacking readers use search to dive directly down to the individual page they want, every rhetorical block in your collection is going to be page one for some reader. I explore the design of Every Page Is Page One topics in my book <phrase><annotation type="citetitle">Every Page is Page One: Topic-based Writing for Technical Communication and the Web</annotation></phrase>.</p>
<p>But does an Every Page is Page One topic have any more reason to follow a constrained rhetorical block structure than a book? Yes, and, as I explore in <phrase><annotation type="citetitle">Every Page is Page One</annotation></phrase>, there is a broad tendency for topics to demonstrate a consistent rhetorical pattern once they become smaller and are accessed in an Every Page is Page One fashion. This makes the information in these topics more accessible to the information snacking reader, both because it makes them easier to find and recognize, and because it ensures that they do the job they are supposed to do more completely and consistently.</p>
<p>Additionally, as I explored in <citation type = "nameref" value = "chapter.architecture"/>, Every Page is Page One topics are part of the way you create a bottom-up information architecture (one in which readers enter by search or following a link and navigate the information set from the point they arrived). Building and maintaining a bottom-up information architecture is much much easier if you do it algorithmically using subject-domain linking and information architecture algorithms. Thus creating subject-domain rhetorical block types for as much of your content as will fit a repeating pattern is key to creating and managing a bottom-up information architecture.</p>
<p>Deciding if you want to model and constrain your rhetorical blocks is therefore one of the most important decisions you will make in designing your content system and demeriting how complexity will be partitioned and directed in that system.</p>
<section>
<title>Granularity</title>
<p>There can be a conflict between ease of authoring and ease of <phrase><annotation type="process">content management</annotation></phrase>. Content management may want to manage content down to a fine level of granularity, especially for purposes of <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase>. This content management algorithm may be best served by managing fairly small chunks of content – semantic units rather than rhetorical units. But for the writer, something less than a rhetorical unit can be difficult. It can be difficult for the writer to get a sense of how the semantic block they are writing will meet the reader’s needs when they don’t see the rhetorical block it will fit into. It is hard to create parts rather than wholes unless the parts are really well defined. A writer might carry the whole of an essay in their head, for instance, and be able to structure it well on that basis. But if they are making only parts and cannot see the wholes that will be created, it is hard to correctly structure a part without very clear and explicit guidance.</p>
</section>
</section>
<section>
<title>Fragments</title>
<p>Another division of content that can occur, mostly in relationship to the management domain, is the fragment. By fragment I mean a chunk of text that is not either a semantic block, an information typing block, or a rhetorical block, but is a block that you want to manage independently of the surrounding text.</p>
<p>For example, in a <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> scenario, you might want to make an item in a list conditional based on which of the list items applies to different versions of a product.</p>
<p>Individual list items are not semantic blocks. They are just structural blocks of a list. When you make list items conditional, what you are actually doing is creating multiple separate lists with some items in common, and recording them as a single list. You might be able to attach reasonably informative metadata to any one of those lists as a whole, but there is usually not a lot you can say about list items individually. They are fragments of a list. When you apply conditions to them, you are applying those conditions to fragments.</p>
<p>In some <phrase><annotation type="algorithm">reuse</annotation></phrase> systems, including <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> and <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase>, it is possible to apply conditions to arbitrary bits of text – three words in sentence for instance. The block that sets off those three words in a fragment.</p>
<p>Some reuse systems also allow you to reuse arbitrary bits of text from other parts of the content set, simply because the text is the same in each case. Those bits of text would be fragments.</p>
<p>In some cases, you turn an existing structural block into a fragment by attaching <phrase><annotation type="concept">management domain</annotation></phrase> metadata to it. In other cases, you have to introduce additional markup into the document to delineate the fragment.</p>
<p>Fragments definitely solve some problems. They are also inherently unstructured and unconstrained. It is very easy to get into trouble with fragments. It is easy to create relationships and dependencies that are hard to manage because they don’t follow any structural logic. You should approach their use with great caution and restraint.</p>
</section>
<section>
<title>Paragraphs and phrases</title>
<p>Paragraphs are the thing that make structured content the most different from other computable data sets. This is not really because of the paragraph structure per se, but because of the phrases within the paragraphs that we want to annotate. It is rare in any other data set to see a structure floating within the value of another structure. But that is exactly what happens when we annotate phrases in a paragraph.</p>
<codeblock language="sam">

In {Rio Bravo}(movie), {the Duke}(actor "John Wayne") 
plays an ex-Union colonel.
</codeblock>
<p>In this examples, the annotation on the phrases “Rio Bravo” and “the Duke” float in the middle of the paragraph block. Here is the same thing in XML:</p>
<codeblock language="xml">

&lt;p&gt;In &lt;movie&gt;Rio Bravo&lt;/movie&gt;, 
&lt;actor name="John Wayne"&gt;the Duke&lt;/actor&gt; 
plays an ex-Union colonel.&lt;/p&gt;
</codeblock>
<p>Here the <code>movie</code> and <code>actor</code> elements float in the content of the <code>p</code> element. In XML parlance, this is called mixed content. If fact, XML breaks the structure of elements down into three kinds:</p>
<ll>
<li>
<label>element content</label>
<p>Elements that contain only other elements.</p>
</li>
<li>
<label>data content</label>
<p>Elements that contain only text data.</p>
</li>
<li>
<label>mixed content</label>
<p>Elements that contain both text data and elements.</p>
</li>
</ll>
<p>Mixed content is the reason that most traditional data format are not a good fit for content. They may be able to model element content and data content, but they lack an elegant way to model mixed content.</p>
<p>Even conventional programming languages have trouble with mixed content. In fact most libraries for XML processing invent an additional wrapper around each string of characters in a mixed content element, effectively representing it as if it were written like this (without mixed content):</p>
<codeblock language="xml">

&lt;p&gt;&lt;text&gt;In &lt;/text&gt;&lt;movie&gt;Rio Bravo&lt;/movie&gt;&lt;text&gt;, 
&lt;/text&gt;&lt;actor name="John Wayne"&gt;the Duke&lt;/actor&gt;&lt;text&gt; 
plays an ex-Union colonel.&lt;/text&gt;&lt;/p&gt;
</codeblock>
<p>But while this makes the content palatable to conventional languages, it is clearly false to the actual structure of the document. Structured writing is essentially about reflecting the structure of thought or presentation in a narrative, and narratives have a structure that is not shared with other data. Indeed, we might say that all other data formats exist as an attempt to extract information from the narrative format to make it easier to process.</p>
<p>Thus we are taught in school that if we are presented a problem in this format:</p>
<blockquote>
<p>John had 4 apples and Mary had 5 apples. They place their apples in a basket. Bill eats 2 apples. How many apples are left in the basket?</p>
</blockquote>
<p>You solve it by first extracting the data from the narrative:</p>
<codeblock>

4 + 5 - 2 =
</codeblock>
<p>But in content processing, we cannot extract the data from the narrative because narrative is the output we are creating. Thus we have to call out the data (to make it processable by structured writing algorithms) while leaving the narrative intact.</p>
<p>When you move content to the <phrase><annotation type="concept">subject domain</annotation></phrase>, you will, in some cases, break down paragraphs and isolate the data. This may be done with the intention of recreating paragraphs algorithmically on output, or of switching from a narrative to a data-oriented reporting of the subject matter. Either way, it makes the data easier for algorithms to handle, and thus makes most of the structured writing algorithms work better. (You may have noticed that the subject domain provides the most constrained and elegant solution to many structured writing algorithms.)</p>
<p>Even so, it is rarely possible to do a complete breakdown of all paragraphs in refactoring content to the subject domain. Most subject domain markup languages make considerable use of paragraphs and other basic text structures, and annotate phrases within the paragraphs were necessary. Only narrative is capable of expressing the full variety and subtlety of the real world relationships between things, and only narrative is capable of conveying these things effectively to most human readers. (We noted in <citation type = "nameref" value = "chapter.metadata"/> that data is created by metadata and that metadata can only every finally be defined by narrative.) Even things that can be fully described to algorithms with fielded data must be described to most audiences with narrative, and even though companies like <phrase><annotation type="company">Narrative Science</annotation></phrase> are working on how to turn data into narrative, they are far from producing a general solution – and it is hard to see how you would get one if all data is created by metadata and all metadata is defined, ultimately, by narrative.</p>
<p><phrase><annotation type="concept">Subject-domain</annotation></phrase> structured writing extends the reach of more conventional algorithms into the world of narrative to enable specific structured writing algorithms and to provide rhetorical constraints to improve the quality of the writing. Unlike <phrase><annotation type="concept">ontologies</annotation></phrase>, subject domain structured writing does not attempt to capture the whole semantics of a narrative, just to discipline and structures narrative to achieve specific content creation objectives – a particular partitioning of content complexity.</p>
<p>Every domain needs to annotate phrases. <phrase><annotation type="concept">Media domain</annotation></phrase> structured writing needs to annotate phrases to describe formatting. The <phrase><annotation type="concept">document domain</annotation></phrase> needs to annotate phrases to describe their role in the document. The <phrase><annotation type="concept">management domain</annotation></phrase> needs to annotate phrases to assign conditions or extract content for reuse. The <phrase><annotation type="concept">subject domain</annotation></phrase> needs to annotate phrases to describe the subject the phrase refers to.</p>
<p>In planning your markup structures, therefore, it is important to think about which structures in your language need to be mixed content and which do not. Finding ways to avoid mixed content without violating the spirit of the essentially narrative nature of writing can pay dividends in an improved ability to express constraints and to execute virtually all the structured writing algorithms.</p>
<p>On the other hand, some of the most important subject matter that you need to model and make available to algorithms cannot effectively be factored out of paragraphs, particularly while maintaining <phrase><annotation type="concept">functional lucidity</annotation></phrase>. Be prepared, therefore, to think seriously about the types of phrases that you will need to annotate below the paragraph level and exactly which domain those annotations should be in.</p>
</section>
</chapter>
