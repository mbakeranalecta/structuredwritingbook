<?xml version="1.0" encoding="UTF-8"?>
<chapter name ="chapter.mechanical-structure">
<title>Mechanical Structure</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">DITA</annotation></phrase> <phrase><annotation type="language">DocBook</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">HTML</annotation></phrase> <phrase><annotation type="language">XML</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm">composition</annotation></phrase> <phrase><annotation type="algorithm">conformance algorithm</annotation></phrase> <phrase><annotation type="algorithm">conformance</annotation></phrase> <phrase><annotation type="algorithm">content management algorithm</annotation></phrase> <phrase><annotation type="algorithm">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract and merge algorithm</annotation></phrase> <phrase><annotation type="algorithm">extract and merge</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">Content management systems</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase></p>
</annotations>
<p>Mechanical structure is the way we record, encode, and enforce the rhetorical structure, of a formal content model. While the rhetorical structure is concerned with how the content fulfills it purpose, the mechanical structure has to deal with specific representational issues and get the nuts and bolts of content recording right – without dropping any complexity in the process.</p>
<p>However detailed you may have been in delineating the rhetorical structures your want to achieve, you will find there is more detailed work to do when it comes to the specifics of the mechanical structure, and particularly with the mechanics of factoring out structures in order to partition and transfer content system complexity.</p>
<p>The mechanical structure of structure writing is a computer data structure. However, conventional computer data structures like relational database tables do not work well for content because they are too regular to fit the shape of content. Creating structures that are regular enough for algorithms to deal with yet irregular enough to fit written language is an interesting problem to which more than one solution has been proposed.</p>
<p>Raw text is just a stream of characters. Inside that stream of characters, there are rhetorical structures like headings, bibliographical entries, bold text, chapters, ingredient lists, links, wine matches, tables, function signatures, and labeled lists. The question is, how do you express these various structures within the raw stream of characters?</p>
<p>The most common answer is that you divide the text up into a series of blocks, and divide those blocks into smaller blocks until all the structures you want to capture are contained in blocks. This is not the only way to do it. Some file formats, such as WordPerfect, use independent stop and start markers to delineate structures, meaning the the boundaries of structures can overlap. But while this kind of structured can work for the media domain, it is very difficult for many structured writing algorithms to work with. Therefore most structured writing today uses the nested block approach.<citation type = "idref" value = "1"/></p>
<footnote id ="1">
<p>Is is technically possible to implement independent stop and start markers even in languages that are mainly block based. You simply define empty blocks for the start and stop markers. Both DITA and DocBook do this for things like delineating arbitrary bits of content for reuse and defining arbitrary spans of content for indexing. Both of these uses strike me as a really bad idea and I would recommend against their use in any content that has any lifespan beyond its first publication.</p>
</footnote>
<insert item ="../graphics/blocks.svg" type ="image"/>
<p>There are definitely cases in which the use of non-overlapping blocks for the mechanical structure of content does not fit with the rhetorical structures that we find in our content. This is more of an issue for the academic study of texts than for structured writing as a means of partitioning and redirecting complexity in the content system, but it can occur in both fields. Allowing overlapping fields, however, adds complexity to many of the structured writing algorithms, meaning it is almost never a worthwhile approach to partitioning our content.</p>
<p>For our purposes, therefore, I am going to deal with the mechanical structure of content strictly in terms of nested non-overlapping blocks.</p>
<section>
<title>Flat vs. hierarchical structures</title>
<p>Even when we decided on the nested blocks approach we are still left with some fundamental choices about mechanical structure. The first is flat vs. hierarchical structure.</p>
<p>We noted in <citation type = "nameref" value = "chapter.document-domain"/> that in HTML, you have six levels of heading (<code>h1</code> through <code>h6</code>) whereas in DocBook you have only <code>title</code>. In DocBook, you can divide a document up into sections and nest sections inside sections. You can then print the titles of sections inside sections in a smaller font that the titles of first level sections. You get to have differences in heading size without having six different heading tags.</p>
<p>But the DocBook model assumes that the real structure of a document is  a hierarchy of nested sections and that the size of titles announces the steps up and down that hierarchical tree. HTML makes no such assumption. It will let you put a <code>&lt;h4&gt;</code> immediately after an <code>&lt;h1&gt;</code> if you want to. It treats documents as essentially flat structures punctuated by headings of various sizes as and where appropriate.</p>
<p>Which model of a document is correct? Which corresponds best to the rhetorical structure of the document? You can think of a document as being organized hierarchically, with major ideas expressed in sections, sub-ideas supporting the major ideas in subsections, etc. There are many documents that fit that model. But you can also think of documents as being more like a journey in which headings function more like road signs. A city gets a big sign, a hamlet a small sign, and a town a medium sign. But the town is not inside the city, not the hamlet inside the town, and there is no guarantee that on leaving the city you will come to the town before you come to a hamlet.</p>
<p>Studies by Peter Flynn indicate that most authors think of the documents they are writing much more in terms of a punctuated linear model than a hierarchical model.</p>
<blockquote>
<citation type = "nameref" value = "Flynn2009"/><p>The classical theory, derived from computer science and graph theory, is that the document is a hierarchical tree (actually inverted: a root-system) and that all necessary actions can be seen in terms of navigation around the tree, and of insertion into and withdrawal from the the nodes which form the branches and leaves.</p>
<p>The conventional writer, however — and we expressly exclude the markup expert, as well as the experienced technical authors who responded to the survey — is by repute probably only marginally aware of this tree; but we have been unable to measure this at present. In this view, the document is seen as a continuous linear narrative, broken into successive divisions along semantic lines, and interspersed with explanatory material in the form of figures, tables, lists, and their derivatives.</p>
</blockquote>
<p>And as Flynn’s research illustrates, there is a good chance that the author is not thinking of their argument as consisting of a strict hierarchy of points either, but as a sequence of points with the occasional insertion of headings to break up the text or perhaps signal a change in emphasis or subject matter.</p>
<p>Clearly defining the rhetorical structure of a document demands dividing it up into blocks such as introduction, ingredients, and preparation. As we have noted, treating these parts of the rhetorical structure as blocks is essential to establishing the context in which our block names are defined and by which our processing rules tell the difference between one type of block and another. This clearly involves asking the author to think a little bit more hierarchically than they might otherwise, which means imposing a little bit of complexity on them for the sake of all the partitioning and redirection of complexity we need to do for the content system overall. Some semantic and rhetorical blocks are going to be naturally more hierarchical than others as well. But there is no need to do any more of this than the needs of our partitioning system demand.</p>
<p>If the <phrase>constraints</phrase> that we want to express in structured writing demand hierarchy, while <phrase>functional lucidity</phrase> demands more of a punctuated linear model, how do we reconcile these two opposing requirements in markup language design?</p>
<p>This is of greatest concern in the design of <phrase><annotation type="concept">document domain</annotation></phrase> languages. The structure of <phrase><annotation type="concept">media domain</annotation></phrase> languages is largely dictated by the shape and relationship of the media-domain object they are modeling. In the <phrase><annotation type="concept">subject domain</annotation></phrase>, we have abstracted content out of strict document order. Hierarchy in the <phrase><annotation type="concept">subject domain</annotation></phrase> tend to match the hierarchy of relationship in the subject matter itself.<citation type = "idref" value = "2"/> In the <phrase><annotation type="concept">document domain</annotation></phrase>, however, it is a real concern. The document domain consists of abstractions of document structures and the nature of their relationship to the structure of thought in the text is not obvious.</p>
<footnote id ="2">
<p>Though this is not universal. Addresses, for instance, which are based on hierarchal locations, are modeled as flat ordered lists. The order reflect the hierarchy, but the nesting of city inside country and of street within city is not reflected in the structure of an address record.</p>
</footnote>
<p>The options available are:</p>
<ul>
<li>
<p>Create a really flat document domain language. Examples are HTML and Markdown. The problem here is that they impose few constraints, and the lack of context-setting hierarchy makes it hard to model different types of document structures without creating hundred of tags – which would negate any <phrase>functional lucidity</phrase> that you gained by keeping the language flat.</p>
</li>
<li>
<p>Create a hierarchical language that has a really permissive structure, so that you can put boxes inside boxes in lots of different ways. An example of this is DocBook. The problem here is that the possible permutations make writing algorithms difficult and you often need to impose additional constraints on your authors that are not expressed or enforced by the markup itself. This again diminishes <phrase>functional lucidity</phrase>, and compromises <phrase><annotation type="algorithm">conformance</annotation></phrase>. (An interesting property of this approach is that the flexibility of the language means that authors can choose to create documents that are very hierarchical or very flat. This is not really a virtue, however, as it is not clear how this choice contributes to improved content quality.)</p>
</li>
<li>
<p>Define a smaller, stricter document domain language that is appropriate to the particular types of documents you want to write, possibly as restricted subset of an existing language like DocBook. The main difficulty with this approach is that it involves you in having to do your own language design, which many organization try to avoid. In other words, it involves transferring complexity to an information architect or content engineer. Once you have decided to go this route, going to the <phrase><annotation type="concept">subject domain</annotation></phrase> instead may be no more expensive while providing better <phrase>functional lucidity</phrase> and <phrase><annotation type="algorithm">conformance</annotation></phrase>.</p>
</li>
<li>
<p>Define a strict hierarchical document domain language that expresses the constraints you need and make people learn it. This works if you are able to recoup the expense of training your authors. It does not work if you want to include occasional authors in your pool of contributors.</p>
</li>
<li>
<p>Move content creation to the <phrase><annotation type="concept">subject domain</annotation></phrase>.</p>
</li>
</ul>
</section>
<bibliography>
<entry name ="Flynn2009">
<p>Flynn, Peter. “Why writers don’t use XML: The usability of editing software for structured documents.” Presented at Balisage: The Markup Conference 2009, Montréal, Canada, August 11 - 14, 2009. In Proceedings of Balisage: The Markup Conference 2009. Balisage Series on Markup Technologies, vol. 3 (2009). doi:10.4242/BalisageVol3.Flynn01.</p>
</entry>
</bibliography>
<section>
<title>Annotating blocks</title>
<p>Every block is annotated to tell us, and algorithms, what it means, which is to say, what constraints it meets. The most basic of these annotations is the name of the block, which describes it basic type. The name of a table block is “table”, which tells us that its type is table. Blocks may also have other annotations that either refine its type of provide additional information about the block.</p>
<p>These additional annotations don’t have to be in the same domain as the block name. We saw and example of this in <citation type = "nameref" value = "chapter.subject-domain"/>:</p>
<codeblock language ="xml">
&lt;section publication="Wine Weenie"&gt;
    &lt;title&gt;Wine match&lt;/title&gt;
    &lt;p&gt;Pinot Noir&lt;/p&gt;
&lt;/section&gt;
&lt;section publication="The Teetotaler's Trumpet"&gt;
    &lt;title&gt;Suggested beverage&lt;/title&gt;
    &lt;p&gt;Lemonade&lt;/p&gt;
&lt;/section&gt;
</codeblock>
<p>Here the <code>section</code> element defines a block in the document domain, and the <code>publication</code> attribute adds an annotation is in the management domain.</p>
</section>
<section>
<title>Agreeing on names</title>
<p>For structured writing to work, it is essential that everyone involved understands and agrees on what the names and annotations mean. These annotations tell downstream people and processes what constraints each block obeys. If the names and the values of the other attributes don’t mean what we have all agreed they are to mean, communication between the partitions of the content system breaks down and complexity leaks out of the seems and descends on the reader.</p>
<p>Confusion and disagreement about what the names and annotations of a particular language mean are not uncommon. Large document domain languages like <phrase><annotation type="language">DocBook</annotation></phrase> and <phrase><annotation type="language">DITA</annotation></phrase> have large vocabularies, and many of the names they offer are quite abstract. Questions about the right way to tag certain passages are common in the communities around these languages, and opinions can vary considerably in some cases. These disagreements don’t only affect low-level structures. In <phrase><annotation type="language">DITA</annotation></phrase>, for example, it is common to debate if a topic that is operational but not procedural is a concept or a task. Some writers choose to use only generic topics because they don’t feel the models of the task, concept, and reference topics fit the content they are creating.</p>
<p>Having precise definition of terms is important, therefore, in developing a structured writing language. But it is equally important that the language be <phrase>functionally lucid</phrase>. The <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> requires that creating structure should not come at the detriment of the writing itself. This requirement is not met if writers are constantly having to puzzle out or debate the right way to mark something up. As we have seen, conformance is chiefly served by designing structures that are easy to conform to. This does not only mean defining what the names mean, but choosing the structures that are it is easiest for authors to name correctly.</p>
<p>In the software world, meta models and abstraction are powerful tools for modeling systems. They provide clear high-level rules for the design of specific structures and create opportunities to reuse code for objects with a shared base model. But these tools can also lead to very abstract naming schemes and even to abstract structures. In the content world, such abstract names and structures can be formally correct but lack the kind of <phrase>functional lucidity</phrase> required for effective authoring.</p>
<p>The problem of defining a mechanical structure to express a rhetorical structure is not only one of defining a correct representation of the content. We also have to design and name structures that can be written by our intended set of authors without imposing a heavy burden on their attention. In other words, designing content structures, at least those intended for use by authors, is as much about interface design as it is about data structure design. And interface design is all about partitioning and distributing complexity.</p>
<p>Clear concrete and specific names, and an organization of blocks that intuitively fits the subject matter, all make for easier authoring. There is no reason that such structures cannot be derived from abstract models, or that they cannot be mapped to abstract models after the fact, but it is important not to let the abstractions intrude into the world of the author.</p>
</section>
<section>
<title>Different rules for intermediate languages</title>
<p>Of course, functional lucidity only matters for the formats that authors actually write in. As we have seen, the <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> typically consists of multiple steps, and each one of those steps can create a format that is closer to the media domain than the one before it. It is perfectly possible to design a document domain structure for the sole purpose of of serving as a step in the publishing chain. Separate authoring formats are created for authors to actually write in (perhaps <phrase><annotation type="concept">subject domain</annotation></phrase> formats or simplified highly constrained ad-hoc document domain formats). Content is transformed from these formats to the document domain format by the <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> and then the document domain format is translated in to various different media domain languages by the <phrase>formatting routine</phrase>. An arrangement like this eliminates the need to compromise between different demands in designing a single language, generally making each language in the chain simpler and more constrained, which in turn makes it each one easier to <phrase>validate</phrase> and to process.</p>
<section>
<title>Secondary structures of interpretation</title>
<p>Under normal circumstance, the structures that constrain the content also constrain its interpretation. But there are cases in which annotations are added to structures to constrain a different interpretation of the content from the one specified by the structure that contains it, and not only of individual fields, but of a structure as a whole.</p>
<p>Consider these <phrase><citation type = "citation" value = "https://en.wikipedia.org/wiki/Microformat">examples of HTML Microformats from Wikipedia</citation></phrase>. The first example shows an address formatted as a list.</p>
<codeblock language ="HTML">
&lt;ul&gt;
   &lt;li&gt;Joe Doe&lt;/li&gt;
   &lt;li&gt;The Example Company&lt;/li&gt;
   &lt;li&gt;604-555-1234&lt;/li&gt;
   &lt;li&gt;
     &lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt;
   &lt;/li&gt;
&lt;/ul&gt;
</codeblock>
<p>Here the phrase “The Example Company” is contained in <code>li</code> tags. This is part of a list structure delineated by <code>ul</code> tags, so the markup is largely structural in the document domain. The <code>li</code> does not really tell you anything about what the content itself is about. It does not tell you anything useful beyond what document structure it belongs to.</p>
<p>The second example adds vCard microformat markup:</p>
<codeblock language ="HTML">
&lt;ul class="vcard"&gt;
  &lt;li class="fn"&gt;Joe Doe&lt;/li&gt;
  &lt;li class="org"&gt;The Example Company&lt;/li&gt;
  &lt;li class="tel"&gt;604-555-1234&lt;/li&gt;
  &lt;li&gt;
    &lt;a class="url" href="http://example.com/"&gt;
       http://example.com/
    &lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</codeblock>
<p>This example adds subject domain metadata in the form of the class attributes. For example, it says that the phrase “The Example Company” is a reference to an organization (<code>org</code>). This annotation is not modifying or refining the constraint expressed by the <code>li</code> tag. It is saying something else entirely.</p>
<p>But this is not just about suggesting a different way of interpreting <code>The Example Company</code> (as an organization name, as well as as a list item).  There is actually a complex <phrase><annotation type="concept">subject domain</annotation></phrase> structure being expressed by the vCard markup. Not only is the list item <code>The Example Company</code> annotated as <code>org</code>, the list that contains it is annotated as <code>vcard</code>. The constraint of interpretation provided by <code>org</code> is actually dependent on it being part of a <code>vcard</code> structure.</p>
<p>In other words, the secondary structure created by the annotations in the sample above is equivalent to pure subject domain markup like this:</p>
<codeblock language ="SAM">
vcard:
   fn: Joe Doe
   org: The Example Company
   tel: 604-555-1234
   url: http://example.com/
</codeblock>
<p>The microformats are overlaying a second structure on the list structure. In the world of HTML, this makes sense. HTML needs to be a standardized <phrase><annotation type="concept">document domain</annotation></phrase> language so that browsers can display it for human reading. Humans don’t need the vCard annotations to recognize that the content is an address, but algorithms do. (This is part of dumbing it down for robots, as we discussed in <citation type = "nameref" value = "chapter.quality"/>.) So the microformat adds a second, hidden, <phrase><annotation type="concept">subject domain</annotation></phrase> structure to the document for readers who are algorithms rather than people.</p>
<p>Structured writing constrains both the creation and the interpretation of content. In the normal case we expect that the creation of the content would be just as constrained as the interpretation. After all, it is hard to rely on the interpretation of structure if the creation of the structure is not constrained. However in this case the interpretation of the data is more constrained than the creation.</p>
<p>Authoring our content this way would obviously be inefficient and error prone. But this is only a problem if the content is actually authored in this format. If the content is authored in a format in which its creation is constrained to the same extent as we wish the output to be constrained, it does not actually matter that the resulting output constrains interpretation more than it constrains creation. Our concern as content creators is simply to make sure that any content we produce that promises to abide by a constraint actually does so, whether the format we deliver it in actually imposes that constraint or merely annotates it.</p>
<p>So, we can confidently produce this information using subject domain markup and then deliver it as HTML with hCard annotation markup using a presentation algorithm something like this (as with all example algorithms in this book, this is pseudocode):</p>
<codeblock language ="pseudo">
match vcard
    create ul
        attribute class = "vcard"
        continue

match fn
    create li
        attribute class = "fn"
        continue

match org
    create li
        attribute class = "org"
        continue

match tel
    create li
        attribute class = "tel"
        continue

match url
    create li
        create a
            attribute class = "url"
            attribute href = contents
            continue
</codeblock>
</section>
<section>
<title>Child blocks vs. additional annotations</title>
<p>As noted above, sometimes the name of a block is not sufficient to fully describe the constraints it meets. In these cases, we can add additional annotations to a block. But we can also achieve much the same thing by adding child blocks to the block. A child block belongs to the main block, so it is part of it and can constrain the interpretation of the main block just as much as an additional annotation does. One of the issues in designing mechanical structures for content, therefore, is when to use additional annotation on a block and when to use child blocks.</p>
<p>Different markup languages have different levels of support for additional annotation on blocks, so this issue is affected by the markup language you choose. SAM, for instance, only supports a limited fixed set of additional annotation on blocks, and therefore any additional constraint of interpretation you want to do in a SAM-based markup language has to be done with child blocks.</p>
<p>In XML, though, there is broad (though not unlimited) support for additional annotations on blocks in the form of attributes. In the XML world, therefore, there is considerable choice, and considerable debate, about when and where you should use elements vs. attributes in your content models.</p>
<p>Consider, for example, this XML element that contains no content but two attributes:</p>
<codeblock language ="xml">
&lt;author-name first="Mark" last="Baker"&gt;
</codeblock>
<p>the element is named <code>author-name</code> and it has two attributes named <code>first</code> and <code>last</code> that contain my first and last name respectively.</p>
<p>Why is this marked up like this and not like this:</p>
<codeblock language ="xml">
&lt;author-name&gt;
    &lt;first&gt;Mark&lt;/first&gt;
    &lt;last&gt;Baker&lt;/first&gt;
&lt;/author-name&gt;
</codeblock>
<p>Both these constructs express the same information in a way that clearly constrains how author names are to be written and how the markup of author names is to be interpreted by algorithms.</p>
<p>Is one of these options correct and the other incorrect? When should you use attributes and when should you use elements?</p>
<p>Consider our vcard example. It could be written this way, using just elements:</p>
<codeblock language ="XML">
&lt;vcard&gt;
   &lt;fn&gt;Joe Doe&lt;/fn&gt;
   &lt;org&gt;The Example Company&lt;/org&gt;
   &lt;tel&gt;604-555-1234&lt;/tel&gt;
   &lt;url&gt;http://example.com/&lt;/url&gt;
&lt;/vcard&gt;
</codeblock>
<p>Or it could be written this way, using attributes:</p>
<codeblock language ="XML">
&lt;vcard
   fn="Joe Doe"
   org="The Example Company"
   tel="604-555-1234"
   url="http://example.com/"
/&gt;
</codeblock>
<p>The first says that <code>fn</code>, <code>org</code>, <code>tel</code>, and <code>url</code> are independent structures that belong as members to a <code>vcard</code> structure. The second says that the <code>vcard</code> structure has a number of data fields – annotations – that complete its meaning.</p>
<p>Does this distinction matter terribly? Both allow you to get at the information you want. Both constrain the creation and the interpretation of data. There are limits to the version that uses attributes. You can’t have more than one attribute with the same name, whereas you could have more than one member elements of the same name (multiple tel elements for someone with more than one telephone number for instance). Also, XML specifies that attributes are unordered, so can’t restrain either the order in which writers create them or the order in which the parser reports them to a processing application.</p>
<p>Given this, you may be wondering why people bother with attributes, since you can do the same things with elements and have both more flexibility and more capacity to impose constraints. Yet people continue to use attributes extensively when designing markup languages in XML.  When people create XML document types for representing data, rather than for writing document, they almost always use the attribute format, perhaps because it is slightly less verbose and slightly easier to read, or perhaps because as programmers they are accustomed to representing data as key/value pairs linked with <code>=</code> signs.</p>
<p>But for documents it is more complex. To understand why XML even has attributes, and why other languages, such as SAM or reStructuredText, also have similar mechanisms for adding annotations to blocks, we need to go back to the original concept of markup as something written onto a manuscript after the fact. In this view, markup is an addition to the text, not part of it. The content of an element is part of the underlying text. Anything you want to add, therefore, cannot be element content, since that would be adding to the text. Everything else has to be added to element definitions as attributes.</p>
<p>This view is reinforced by the academic interest in markup as a way to prepare texts for study. Again, here, the text is preexisting and canonical. The markup is external to it and so everything that is external to the original text must be contained in the markup itself (as attributes) and nothing that is internal to the original text must be removed or replaced by markup. (This is a form of partitioning in its own right, to serve a particular purpose.) Thus in this fragment of a Shakespeare play marked up by John Bosek we see that the original text is kept perfectly intact:</p>
<codeblock language ="xml">
&lt;ACT&gt;
&lt;TITLE&gt;ACT I&lt;/TITLE&gt;
&lt;SCENE&gt;
&lt;TITLE&gt;SCENE I. Rousillon. The COUNT's palace.&lt;/TITLE&gt;
&lt;STAGEDIR&gt;
Enter BERTRAM, the COUNTESS of Rousillon, HELENA, and LAFEU, 
all in black
&lt;/STAGEDIR&gt;
&lt;SPEECH&gt;
&lt;SPEAKER&gt;COUNTESS&lt;/SPEAKER&gt;
&lt;LINE&gt;
In delivering my son from me, I bury a second husband.
&lt;/LINE&gt;
&lt;/SPEECH&gt;
&lt;SPEECH&gt;
&lt;SPEAKER&gt;BERTRAM&lt;/SPEAKER&gt;
&lt;LINE&gt;And I in going, madam, weep o'er my father's death&lt;/LINE&gt;
&lt;LINE&gt;anew: but I must attend his majesty's command, to&lt;/LINE&gt;
&lt;LINE&gt;whom I am now in ward, evermore in subjection.&lt;/LINE&gt;
&lt;/SPEECH&gt;
</codeblock>
<p>Had this markup employed the normal refactoring of text into markup that we have seen in our discussions of the <phrase><annotation type="concept" specifically="document domain">document</annotation></phrase> and <phrase><annotation type="concept" specifically="subject domain">subject</annotation></phrase> domains, then the number and title of scenes would have been factored out so that instead of:</p>
<codeblock language ="xml">
&lt;SCENE&gt;
    &lt;TITLE&gt;SCENE I. Rousillon. The COUNT's palace.&lt;/TITLE&gt;
</codeblock>
<p>we might have factored out the scene number and the work ‘SCENE’ like this:</p>
<codeblock language ="xml">
&lt;SCENE&gt;
    &lt;TITLE&gt;Rousillon. The COUNT's palace.&lt;/TITLE&gt;
</codeblock>
<p>Going further, we might have noted that the introduction of a scene is invariable the name of its location, so we might have done this:</p>
<codeblock language ="xml">
&lt;SCENE&gt;
    &lt;LOCATION&gt;Rousillon. The COUNT's palace.&lt;/LOCATION&gt;
</codeblock>
<p>or even this:</p>
<codeblock language ="xml">
&lt;SCENE location="Rousillon. The COUNT's palace."&gt;
</codeblock>
<p>And similarly, we might have replaced:</p>
<codeblock language ="xml">
&lt;SPEECH&gt;
    &lt;SPEAKER&gt;BERTRAM&lt;/SPEAKER&gt;
</codeblock>
<codeblock language ="xml">
&lt;SPEECH SPEAKER="BERTRAM"&gt;
</codeblock>
<p>Making a few changes like this in the markup would leave us with only the words actually spoken by the actors as the “text” of the play and everything else expressed as elements or attributes.</p>
<p>This actually makes quite a lot of sense, because all of the stage directions and attribution of speakers in a play is actually metadata annotating the speeches of the actors which are the only things the audience is actually supposed to hear.</p>
<p>So is the right way to markup a play to preserve the original printed text – which includes all of the playwright’s metadata – or is it better to separate the playwrights metadata from the speeches which are the ‘real’ play?</p>
<p>But while these question may be important for the scholarly study of text, they are not nearly so important for structured writing. Our concern is to partition the task of content creation, so we can simply choose the format that does that in the most functionally lucid way while ensuring that all the information required by the next partition is accurately captured. The fact that such question exist, however, help us to understand both why a markup language like XML is structured the way it is, and why so many texts are marked up the way they are – and why so many markup languages are designed the way they are.</p>
<p>The way we, as practitioners of structured writing, settle these matters is by asking ourselves which approach best supports the structured writing algorithms that we want to implement, and always remembering that the reliability of every other algorithm depends on how well the conformance algorithms works, and that the conformance algorithm depends to a large extent on how the authoring algorithm designs for conformance and for functional lucidity.</p>
<p>In none of this are we in the least concerned about preserving the canonical nature of a preexisting text. There is no preexisting text. We are all about creating new texts. Because of this we have every reason to prefer to use sub-structures rather than annotations on existing structures, to express things like our vCard example. In fact, SAM, which is designed specifically for structured authoring, only supports this format:</p>
<codeblock language ="SAM">
vcard:
   fn: Joe Doe
   org: The Example Company
   tel: 604-555-1234
   url: http://example.com/
</codeblock>
<p>SAM only supports a very limited set of annotations on blocks, all of which have predefined meetings. You could, in fact, eliminate annotations on blocks altogether, and use child blocks for everything, but I have supported a limited set of common <phrase><annotation type="concept">management-domain</annotation></phrase> block annotations in SAM, mostly to improve functional lucidity.</p>
<p>In summary, when defining the mechanical structure of your structured writing, don’t get hung up on what is text and what is markup. In each domain, text and markup together form a body of constrained content which can be successfully created by an author and successfully processes by one or more algorithms. Only when you resolve the content all the way to the media domain do you finally have to sort our exactly which characters appear in which order and decoration to represent that content to a particular audience. When we choose to create content in the other domains it is precisely because we want to exercise more control over these things, and to use algorithms to help us create and manage them. Whether some idea or constraint is expressed by text of markup in those domains should be based solely on what works best in those domains. (Which is precisely why attempting to do structured writing using a WYSIWYG editor is so counter productive, and why it is so important to ensure the functional lucidity of your markup as markup.)</p>
</section>
</section>
</chapter>
