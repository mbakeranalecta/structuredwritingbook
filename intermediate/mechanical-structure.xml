<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.mechanical-structure">
<title>Content as data</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="process">conformance</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforming</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> <phrase><annotation type="process">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<p>Structured writing represents content as data in order to make it accessible to algorithms. Conventional computer data structures such as relational database tables do not work well for content because they are too regular to fit the shape of content. Creating structures that are regular enough for algorithms to deal with yet irregular enough to fit the rhetorical patterns of written language is a challenging problem.</p>
<p>Fundamentally, a document is just a stream of characters. However, that stream of characters contains rhetorical structures such as headings, bibliographical entries, bold text, chapters, ingredient lists, links, wine matches, tables, function signatures, and labeled lists. In addition you may need to annotate <phrase><annotation type="concept">subject affinities</annotation></phrase> and attach management metadata. The question is, how do you express these various structures within the raw stream of characters?</p>
<p>The most common answer is to divide the text into a series of blocks, divide those blocks into smaller blocks, and continue dividing until all the structures you need are contained in blocks. This is not the only way to do it. Some file formats, such as <phrase>WordPerfect</phrase>, use independent stop and start markers to delineate structures, meaning that the boundaries of structures can overlap. But while this kind of structure can work in the media domain, it is difficult for structured writing algorithms to work with such structures. Therefore most structured writing today uses the nested block approach.<citation idref="1"/></p>
<footnote id="1">
<p>It is technically possible to implement independent stop and start markers, even in languages that are mainly block based. You simply define empty blocks for the start and stop markers. Both DITA and DocBook do this to delineate arbitrary bits of content for reuse and to define arbitrary spans of content for indexing. I recommend against this practice in content that has a lifespan beyond its first publication.</p>
</footnote>
<p>There are cases where non-overlapping block structure is inadequate for some rhetorical structures. This is more of an issue for the academic study of texts than for structured writing, but it can occur in both fields. However, allowing overlapping fields adds complexity to many of the structured writing algorithms, and it is rarely a worthwhile approach to partitioning content.</p>
<p>For our purposes, therefore, I am going to deal with the mechanical structure of content strictly in terms of nested, non-overlapping blocks, such as shown in <citation nameref="fig.block-structure"/>.</p>
<figure name="fig.block-structure">
<title>Nested block structure of a recipe</title>
<insert item="../graphics/blocks.svg" type="image"/>
</figure>
<section>
<title>Flat vs. hierarchical structures</title>
<p>Even using a strictly nested blocks approach requires some fundamental choices about mechanical structure. The first is flat vs. hierarchical structure.</p>
<p>As noted in <citation nameref="chapter.document-domain"/>, HTML has six levels of heading (<code>h1</code> through <code>h6</code>), whereas <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> has only <code>title</code>. DocBook lets you divide a document into sections and nest sections inside sections. You can then print the titles of sections inside sections in a smaller font than the titles of first-level sections. You can render headings in different sizes without having six different heading tags.</p>
<p>But the DocBook model assumes that the real structure of a document is a hierarchy of nested sections and that the size of titles announces the steps up and down that hierarchical tree. HTML makes no such assumption. It will let you put an <code>&lt;h4&gt;</code> immediately after an <code>&lt;h1&gt;</code> if you want to. It treats documents as essentially flat structures punctuated by headings of various sizes.</p>
<p>Which model of a document is correct? Which corresponds best to the rhetorical structure of the document? You can think of a document as being organized hierarchically, with major ideas expressed in sections, sub-ideas supporting the major ideas in subsections, etc. There are many documents that fit that model. But you can also think of documents as being more like a journey in which headings function like road signs. A city gets a big sign, a hamlet a small sign, and a town a medium sign. But the town is not inside the city, the hamlet is not inside the town, and there is no guarantee that on leaving the city you will come to a town before you come to a hamlet.</p>
<p>Studies by Peter Flynn indicate that most authors think of documents much more in terms of a punctuated linear model (a journey) than a hierarchical model.</p>
<blockquote>
<citation nameref="Flynn2009"/>
<p>The classical theory, derived from computer science and graph theory, is that the document is a hierarchical tree (actually inverted: a root-system) and that all necessary actions can be seen in terms of navigation around the tree, and of insertion into and withdrawal from the the nodes which form the branches and leaves.</p>
<p>The conventional writer, however — and we expressly exclude the markup expert, as well as the experienced technical authors who responded to the survey — is by repute probably only marginally aware of this tree; but we have been unable to measure this at present. In this view, the document is seen as a continuous linear narrative, broken into successive divisions along semantic lines, and interspersed with explanatory material in the form of figures, tables, lists, and their derivatives.</p>
</blockquote>
<p>And as Flynn’s research illustrates, there is a good chance that authors don’t think of their arguments as consisting of a strict hierarchy of points. Rather, they think of them as a sequence of points with the occasional insertion of headings to break up the text or perhaps signal a change in emphasis or subject matter.</p>
<p>To clearly define the rhetorical structure of a document, you have to divide it into blocks such as introduction, ingredients, and preparation. And, as previously noted, treating these parts of the rhetorical structure as blocks is essential to establishing a context where blocks can be identified and processed by algorithms.</p>
<p>Some semantic and rhetorical blocks are naturally more hierarchical than others. Even so, structured writing forces authors to think more hierarchically than they might otherwise, which means imposing a little bit of complexity on them to support all the partitioning and redirection of complexity needed for the content system overall. However, there is no need to do any more of this than the partitioning system demands.</p>
<p>If the structured writing <phrase><annotation type="concept">constraints</annotation></phrase> that you need to express demand hierarchy, while <phrase><annotation type="concept">functional lucidity</annotation></phrase> demands a more punctuated linear model, how do you design a markup language that reconciles these two opposing requirements?</p>
<p>This is of greatest concern in the design of <phrase><annotation type="concept">document-domain</annotation></phrase> languages. The structure of <phrase><annotation type="concept">media-domain</annotation></phrase> languages follows the shape of the media they are modeling, which is largely flat. In the <phrase><annotation type="concept">subject domain</annotation></phrase>, content has been abstracted out of strict document order, which means that hierarchy in the <phrase><annotation type="concept">subject domain</annotation></phrase> tends to match the hierarchy of relationships in the subject matter itself.<citation idref="2"/> In the <phrase><annotation type="concept">document domain</annotation></phrase>, however, this is a real concern. The document domain consists of abstractions of document structures and the nature of their relationship to the structure of thought in the text is not obvious.</p>
<footnote id="2">
<p>This is not universal. For example, addresses, which are based on hierarchical locations, are typically modeled as flat ordered lists. The order reflects the hierarchy, but the structure does not nest city inside country and street inside city.</p>
</footnote>
<p>Outside of the <phrase><annotation type="concept">media domain</annotation></phrase> the options available are:</p>
<ul>
<li>
<p>Use a flat <phrase><annotation type="concept">document-domain</annotation></phrase> language. Examples are HTML and Markdown. The problem here is that a flat language imposes few constraints, and the lack of context-setting hierarchy makes it hard to model different types of document structures without creating hundred of tags – which negates any <phrase><annotation type="concept">functional lucidity</annotation></phrase> that you gain by keeping the language flat.</p>
</li>
<li>
<p>Use a hierarchical <phrase><annotation type="concept">document-domain</annotation></phrase> language that has a permissive structure, so you can put blocks inside blocks in lots of different ways. An example of this is <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase>. The problem here is that the permutations make writing algorithms difficult, and you often need to impose additional writing constraints that go beyond those expressed or enforced by the markup itself. This again diminishes <phrase><annotation type="concept">functional lucidity</annotation></phrase> and compromises <phrase><annotation type="process">conformance</annotation></phrase>. (An interesting property of this approach is that the flexibility of the language means that writers can create documents that are very hierarchical or very flat. However, this is not really a virtue, because it is not clear how this choice contributes to improved content quality.)</p>
</li>
<li>
<p>Create a smaller, stricter document-domain language that fits the types of documents you want to write. The main difficulty with this approach is that you have to design your own language, which many organizations try to avoid. (In some cases you can reduce this effort by using a restricted subset of an existing language such as <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase>, something we will look at in <citation nameref="chapter.extensible"/>.)</p>
</li>
<li>
<p>Move content creation to the <phrase><annotation type="concept">subject domain</annotation></phrase>. This also involves creating your own languages, but it can provide additional support for rhetoric and process while improving functional lucidity.</p>
</li>
</ul>
</section>
<bibliography>
<entry name="Flynn2009">
<p>Flynn, Peter. “Why writers don’t use XML: The usability of editing software for structured documents.” Presented at Balisage: The Markup Conference 2009, Montréal, Canada, August 11 - 14, 2009. In Proceedings of Balisage: The Markup Conference 2009. Balisage Series on Markup Technologies, vol. 3 (2009). doi:10.4242/BalisageVol3.Flynn01.</p>
</entry>
</bibliography>
<section>
<title>Annotating blocks</title>
<p>When treating content as data, you annotate every block to identify – to people and algorithms – what constraints it meets. The most basic annotation is the name of the block, which describes its type. The name of a table block is <code>table</code>, which tells us that the block is a table. Blocks may also have other annotations that either refine its type or provide additional information.</p>
<p>These additional annotations don’t have to be in the same domain as the block name. <citation idref="fig.mechanical-wine"/> repeats an example of this from <citation nameref="chapter.subject-domain"/>.</p>
<figure id="fig.mechanical-wine">
<title>Conditional text markup (XML)</title>
<codeblock language="xml">
&lt;section publication="Wine Weenie"&gt;
    &lt;title&gt;Wine match&lt;/title&gt;
    &lt;p&gt;Pinot Noir&lt;/p&gt;
&lt;/section&gt;
&lt;section publication="The Teetotaler's Trumpet"&gt;
    &lt;title&gt;Suggested beverage&lt;/title&gt;
    &lt;p&gt;Lemonade&lt;/p&gt;
&lt;/section&gt;
</codeblock>
</figure>
<p>In <citation idref="fig.mechanical-wine"/>, the <code>section</code> element defines a block in the document domain, and the <code>publication</code> attribute adds an annotation in the management domain.</p>
</section>
<section>
<title>Agreeing on names</title>
<p>For structured writing to work, everyone involved must understand and agree on what the names and annotations mean. Annotations tell people and processes what constraints each block obeys. If the names and annotations don’t mean what we have all agreed to, communication between the partitions of the content system breaks down and both process and rhetoric suffer.</p>
<p>Confusion and disagreement about the meaning of names and annotations are not uncommon. Large document-domain languages such as <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> and <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> have large vocabularies, and many of the names they offer are quite abstract. Questions about the right way to tag certain passages are common in the communities around these languages, and opinions can vary considerably in some cases.</p>
<p>These disagreements don’t affect just low-level structures. In <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>, for example, it is common to debate whether a topic that contains operational information, but is not procedural, is a concept or a task. And some writers use only generic topics because they don’t think DITA’s task, concept, and reference topics fit their content.</p>
<p>Therefore, you must define terms precisely when developing a structured writing language. But it is equally important that the language be <phrase><annotation type="concept">functionally lucid</annotation></phrase>. <phrase><annotation type="concept">Functional lucidity</annotation></phrase> requires you to create structures that do not detract from writing. This requirement is not met if writers must constantly puzzle out or debate the right way to mark something up. This means not only defining what the names mean, but also choosing structures that are easy to name correctly. As I describe in <citation nameref="chapter.conformance"/>, the best way to achieve conformance is to design structures that are easy to conform to.</p>
</section>
<section>
<title>Different rules for intermediate languages</title>
<p>Of course, functional lucidity only matters for the formats that writers actually write in. As we have seen, the <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> typically consists of multiple steps, and each one of those steps can create a format that is closer to the media domain than the one before it. It is perfectly possible to design a document-domain structure just to serve as a step in the publishing chain. Separate authoring formats are created for writers to actually write in (perhaps <phrase><annotation type="concept">subject-domain</annotation></phrase> formats or simplified highly constrained ad-hoc document domain formats). Content is transformed from these formats to the document-domain format by the <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> and then the document-domain format is translated into various different media-domain languages by the <phrase>formatting software</phrase>. An arrangement like this eliminates the need to compromise between different demands in designing a single language, generally making each language in the chain simpler and more constrained, which in turn makes each one easier to <phrase><annotation type="algorithm">validate</annotation></phrase> and process.</p>
</section>
<section>
<title>Secondary structures of interpretation</title>
<p>Under normal circumstance, the structures that constrain content also constrain the interpretation of that content. In other words, the markup that tells the writer what to write also tells the algorithm (or other downstream user) what the content means. But there are cases where annotations are added to document-domain structures to tell downstream processes what the content means. These structures don’t constrain writers, which means they don’t guide them either. Writers must know exactly how to create this kind of annotation without any guidance or prompting.</p>
<p>Consider these <phrase><citation value="https://en.wikipedia.org/wiki/Microformat">examples of HTML microformats from Wikipedia.</citation></phrase> <citation idref="fig.mechanical-address"/> shows an address formatted as a list.</p>
<figure id="fig.mechanical-address">
<title>HTML microformat markup for an address</title>
<codeblock language="HTML">
&lt;ul&gt;
   &lt;li&gt;Joe Doe&lt;/li&gt;
   &lt;li&gt;The Example Company&lt;/li&gt;
   &lt;li&gt;604-555-1234&lt;/li&gt;
   &lt;li&gt;
     &lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt;
   &lt;/li&gt;
&lt;/ul&gt;
</codeblock>
</figure>
<p>In <citation idref="fig.mechanical-address"/>, the phrase “The Example Company” is contained in <code>li</code> tags. This is part of a list structure delineated by <code>ul</code> tags, so the markup is largely structural in the document domain. The <code>li</code> does not tell you what the content itself is about. It does not tell you anything useful beyond what document structure it belongs to.</p>
<p>The second example, <citation idref="fig.mechanical-vcard"/>, adds vCard microformat markup:</p>
<figure id="fig.mechanical-vcard">
<title>vCard microformat markup for an address</title>
<codeblock language="HTML">
&lt;ul class="vcard"&gt;
  &lt;li class="fn"&gt;Joe Doe&lt;/li&gt;
  &lt;li class="org"&gt;The Example Company&lt;/li&gt;
  &lt;li class="tel"&gt;604-555-1234&lt;/li&gt;
  &lt;li&gt;
    &lt;a class="url" href="http://example.com/"&gt;
       http://example.com/
    &lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</codeblock>
</figure>
<p><citation idref="fig.mechanical-vcard"/> adds subject-domain metadata in the form of the class attributes. For example, it says that the phrase “The Example Company” is a reference to an organization (<code>org</code>). This annotation does not modify or refine the constraint expressed by the <code>li</code> tag. It is saying something else entirely.</p>
<p>But this is not just about suggesting a different way of interpreting “The Example Company” (as an organization name, as well as as a list item).  The <phrase>vCard</phrase> markup expresses a complex <phrase><annotation type="concept">subject-domain</annotation></phrase> structure. Not only is the list item <code>The Example Company</code> annotated as <code>org</code>, the list that contains it is annotated as <code>vcard</code>. The interpretation of <code>org</code> actually depends on that annotation being part of a <code>vcard</code> structure.</p>
<p>In other words, the secondary structure created by the annotations in the <citation idref="fig.mechanical-vcard"/> is equivalent to pure subject-domain markup like <citation idref="fig.mechanical-subject"/>.</p>
<figure id="fig.mechanical-subject">
<title>Subject-domain markup for an address</title>
<codeblock language="SAM">
vcard:
   fn: Joe Doe
   org: The Example Company
   tel: 604-555-1234
   url: http://example.com/
</codeblock>
</figure>
<p>The microformats overlay a second structure on the list structure. In the world of HTML, this makes sense. HTML needs to be a standardized <phrase><annotation type="concept">document-domain</annotation></phrase> language so that browsers can display it for human reading. Humans don’t need the vCard annotations to recognize that the content is an address, but algorithms do. So the microformat adds a second, hidden, <phrase><annotation type="concept">subject-domain</annotation></phrase> structure to the document for readers that are algorithms rather than people.</p>
<p>Structured writing constrains both the creation and the interpretation of content. In the normal case you expect that the creation of the content would be just as constrained as the interpretation. After all, it is hard to rely on the interpretation of structure if the creation of the structure is not constrained. However in this case the interpretation of the data is more constrained than the creation.</p>
<remark attribution="RLH">
<p>Oops, I missed something in the paragraph below. It’s not obvious to me what you mean by “Authoring our content this way...” By “this way,” do you mean using microformats that overlay a second structure or something else? Please take a look at the previous paragraph and this one, and see if you can take another shot at explaining what you mean.</p>
</remark>
<remark attribution="MB">
<p>Done.</p>
</remark>
<p>Asking writers to add unconstrained <phrase><annotation type="concept">subject domain</annotation></phrase> metadata to <phrase><annotation type="concept">document domain</annotation></phrase> structures like this would obviously be inefficient and error prone. But this is only a problem if the content is actually authored in this format. If the content is authored in a format in which its creation is constrained to the same extent as we wish the output to be constrained, it does not actually matter that the resulting output constrains interpretation more than it constrains creation. Our concern as content creators is simply to make sure that any content we produce that promises to abide by a constraint actually does so, whether the format we deliver it in actually imposes that constraint or merely annotates it.</p>
<p>So, you can confidently produce this information using subject-domain markup and then deliver it as HTML with vCard annotation markup using a presentation algorithm something like (*fig.mechanical-subject-2) (as with all example algorithms in this book, this example is pseudocode):</p>
<figure id="fig.mechanical-subject-2">
<title>Pseudocode to convert subject-domain address markup to vCard format</title>
<codeblock language="pseudo">
match vcard
    create ul
        attribute class = "vcard"
        continue

match fn
    create li
        attribute class = "fn"
        continue

match org
    create li
        attribute class = "org"
        continue

match tel
    create li
        attribute class = "tel"
        continue

match url
    create li
        create a
            attribute class = "url"
            attribute href = contents
            continue
</codeblock>
</figure>
</section>
<section>
<title>Child blocks vs. additional annotations</title>
<p>As noted above, sometimes the name of a block is not sufficient to fully describe the constraints it meets. In these cases, you can add additional annotations to a block. But you can also achieve much the same thing by adding child blocks. A child block belongs to the main block, so it is part of it and can constrain the interpretation of the main block just as much as an annotation does. One of the issues in designing data structures for content, therefore, is deciding when to use additional annotations and when to use child blocks.</p>
<p>Different markup languages have different levels of support for additional annotation on blocks, so this issue is affected by the markup language you choose. SAM, for instance, supports only a limited, fixed set of additional annotations on blocks. Therefore, if you want to add constraints on interpretation, you have to use child blocks.</p>
<p>In XML, however, there is broad (though not unlimited) support for additional annotations on blocks in the form of attributes. In the XML world there is considerable choice, and considerable debate, about when and where to use elements vs. attributes in your content models.</p>
<p>Consider, for example, this XML element that contains two attributes but no content:</p>
<codeblock language="xml">
&lt;author-name first="Mark" last="Baker"&gt;
</codeblock>
<p>The element is called <code>author-name</code>, and it has two attributes, <code>first</code> and <code>last</code>, which contain my first and last name respectively.</p>
<p>Why is this marked up like this and not like this:</p>
<codeblock language="xml">
&lt;author-name&gt;
    &lt;first&gt;Mark&lt;/first&gt;
    &lt;last&gt;Baker&lt;/first&gt;
&lt;/author-name&gt;
</codeblock>
<p>Both of these constructs express the same information, and both clearly constrain how you mark up an author’s name and how algorithms should interpret that markup.</p>
<p>Is one of these options correct and the other incorrect? When should you use attributes and when should you use elements?</p>
<p>Consider our vcard example. You could write it this way, using just elements:</p>
<codeblock language="XML">
&lt;vcard&gt;
   &lt;fn&gt;Joe Doe&lt;/fn&gt;
   &lt;org&gt;The Example Company&lt;/org&gt;
   &lt;tel&gt;604-555-1234&lt;/tel&gt;
   &lt;url&gt;http://example.com/&lt;/url&gt;
&lt;/vcard&gt;
</codeblock>
<p>Or you could write it this way, using attributes:</p>
<codeblock language="XML">
&lt;vcard
   fn="Joe Doe"
   org="The Example Company"
   tel="604-555-1234"
   url="http://example.com/"
/&gt;
</codeblock>
<p>The first says that <code>fn</code>, <code>org</code>, <code>tel</code>, and <code>url</code> are independent structures that belong as members to a <code>vcard</code> structure. The second says that the <code>vcard</code> structure has a number of data fields – annotations – that complete its meaning.</p>
<p>Does this distinction matter terribly? Both allow you to get at the information you want. Both constrain the creation and the interpretation of data. There are limits to the version that uses attributes. In XML markup, you can’t have more than one attribute with the same name, whereas you could have more than one child block with the same name (multiple <code>tel</code> elements for someone with more than one telephone number for instance). Also, XML specifies that attributes are unordered, so you can’t restrain either the order in which writers create them or the order in which the parser reports them to a processing application.</p>
<p>Given this, you may be wondering why people bother with attributes, since you can do the same things with elements and have both more flexibility and more capacity to impose constraints. Yet people continue to use attributes extensively when designing markup languages in XML.  When people create XML document types for representing data, rather than for writing documents, they almost always use the attribute format, perhaps because it is slightly less verbose and slightly easier to read or, perhaps, because as programmers they are accustomed to representing data as key/value pairs linked with <code>=</code> signs.</p>
<p>But for documents it is more complex. To understand why XML even has attributes and why other languages, such as SAM or reStructuredText, also have similar mechanisms for adding annotations to blocks, you need to go back to the original concept of markup as something written onto a manuscript after the fact. In this view, markup is an addition to the text, not part of it. The content of an element is part of the underlying text. Anything you want to add, therefore, cannot be element content, since that would be adding to the text. Everything else has to be added to element definitions as attributes.</p>
<p>This view is reinforced in the way academics use markup to prepare texts for study. Again, here, the text is preexisting and canonical. The markup is external to the text, and therefore, everything that is external to the original text must be contained in the markup itself (as attributes) and nothing that is part of the original text can be removed or replaced by markup. (This is a form of partitioning in its own right, to serve a particular purpose.) Thus in this fragment (<citation idref="fig.mechanical-Shakespeare"/>) of Shakespeare’s <phrase><annotation type="italic">All's Well That Ends Well</annotation></phrase>, marked up by John Bosak, you can see that the original text is kept perfectly intact.</p>
<figure id="fig.mechanical-Shakespeare">
<title>Fragment of Shakespeare’s <phrase><annotation type="italic">All's Well That Ends Well</annotation></phrase> marked up in XML</title>
<codeblock language="xml">
&lt;ACT&gt;
  &lt;TITLE&gt;ACT I&lt;/TITLE&gt;
  &lt;SCENE&gt;
    &lt;TITLE&gt;SCENE I. Rousillon. The COUNT's palace.&lt;/TITLE&gt;
    &lt;STAGEDIR&gt;
      Enter BERTRAM, the COUNTESS of Rousillon, HELENA, and LAFEU, 
      all in black
    &lt;/STAGEDIR&gt;
    &lt;SPEECH&gt;
      &lt;SPEAKER&gt;COUNTESS&lt;/SPEAKER&gt;
      &lt;LINE&gt;In delivering my son from me, I bury a second husband.&lt;/LINE&gt;
    &lt;/SPEECH&gt;
    &lt;SPEECH&gt;
      &lt;SPEAKER&gt;BERTRAM&lt;/SPEAKER&gt;
        &lt;LINE&gt;And I in going, madam, weep o'er my father's death&lt;/LINE&gt;
        &lt;LINE&gt;anew: but I must attend his majesty's command, to&lt;/LINE&gt;
        &lt;LINE&gt;whom I am now in ward, evermore in subjection.&lt;/LINE&gt;
    &lt;/SPEECH&gt;
    …
</codeblock>
</figure>
<p>Had this markup employed the normal refactoring of text into markup described in the discussions about the <phrase><annotation type="concept" specifically="document domain">document</annotation></phrase> and <phrase><annotation type="concept" specifically="subject domain">subject</annotation></phrase> domains, then the number and title of scenes would have been factored out so that instead of:</p>
<codeblock language="xml">
&lt;SCENE&gt;
    &lt;TITLE&gt;SCENE I. Rousillon. The COUNT's palace.&lt;/TITLE&gt;
</codeblock>
<p>you might have factored out the scene number and the word “SCENE” like this:</p>
<codeblock language="xml">
&lt;SCENE&gt;
    &lt;TITLE&gt;Rousillon. The COUNT's palace.&lt;/TITLE&gt;
</codeblock>
<p>Going further, you might have noted that the introduction of a scene is invariably the name of its location and done this:</p>
<codeblock language="xml">
&lt;SCENE&gt;
    &lt;LOCATION&gt;Rousillon. The COUNT's palace.&lt;/LOCATION&gt;
</codeblock>
<p>or even this:</p>
<codeblock language="xml">
&lt;SCENE location="Rousillon. The COUNT's palace."&gt;
</codeblock>
<p>And similarly, you could replace:</p>
<codeblock language="xml">
&lt;SPEECH&gt;
    &lt;SPEAKER&gt;BERTRAM&lt;/SPEAKER&gt;
</codeblock>
<p>with the following:</p>
<codeblock language="xml">
&lt;SPEECH SPEAKER="BERTRAM"&gt;
</codeblock>
<p>Making a few changes like this in the markup would leave you with only the words actually spoken by the actors as the text of the play and everything else expressed as elements or attributes.</p>
<p>This actually makes quite a lot of sense, because the stage directions and identification of speakers in a play are metadata that annotates the actor’s words, which are the only things the audience is supposed to hear.</p>
<p>So is the right way to markup a play to preserve the original printed text – which includes all of the playwright’s metadata – or is it better to separate the playwright’s metadata from the speeches that are the ‘real’ play?</p>
<p>While these questions may be important for the scholarly study of text, they are not nearly as important for structured writing. Our concern is to partition the task of content creation, which means you can simply choose the format that does that in the most functionally lucid way while ensuring that all the information required by the next partition is accurately captured. The fact that such questions exist, however, helps explain why a markup language like XML is structured the way it is and why so many texts are marked up the way they are – and why so many markup languages are designed the way they are.</p>
<p>The way we, as practitioners of structured writing, settle these matters is by asking ourselves which approach best supports the structured writing algorithms that we want to implement, always remembering that the reliability of every other algorithm depends on how well writers conform to constraints, which in turn depends on how well the authoring markup language supports conformance and functional lucidity.</p>
<p>In none of this is there any reason to be in the least concerned about preserving the canonical nature of a preexisting text. There is no preexisting text. Therefore, there is every reason to prefer sub-structures rather than annotations to express things such as our vCard example. In fact, SAM, which is designed specifically for structured authoring, supports only this format:</p>
<codeblock language="SAM">
vcard:
   fn: Joe Doe
   org: The Example Company
   tel: 604-555-1234
   url: http://example.com/
</codeblock>
<p>SAM supports a limited set of annotations on blocks, all of which have predefined meanings. You could, in fact, eliminate annotations on blocks altogether and use child blocks for everything, but I have supported a limited set of common <phrase><annotation type="concept">management-domain</annotation></phrase> block annotations in SAM, mostly to improve functional lucidity.<citation idref="fn.xslt"/></p>
<footnote id="fn.xslt">
<p>It is worth noting that <phrase>XSLT</phrase>, the language most commonly used to process <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase>, implicitly assumes that element content in an XML document is the text of the output document and that attributes are not, thus the text of elements passes through to output automatically unless you catch it and suppress it, whereas the text of attributes is ignored unless you catch and output them.</p>
</footnote>
<p>In summary, when defining the mechanical structure of your structured writing, don’t get hung up on what is text and what is markup. In each domain, text and markup together form a body of constrained content that can be successfully created by an author and successfully processed by one or more algorithms. Only when you resolve the content all the way to the media domain do you finally have to sort our exactly which characters appear in which order and which decorations you need to represent that content to a particular audience. When we choose to create content in the other domains, it is precisely because we want to exercise more control over these things and to use algorithms to help us create and manage them. Whether some idea or constraint is expressed by text of markup in those domains should be based solely on what works best in those domains.</p>
</section>
</chapter>
