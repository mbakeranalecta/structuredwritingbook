<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.publishing">
<title>Publishing</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">DITA</annotation></phrase> <phrase><annotation type="language">DocBook</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">HTML</annotation></phrase> <phrase><annotation type="language">XML</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm">composition</annotation></phrase> <phrase><annotation type="algorithm">conformance algorithm</annotation></phrase> <phrase><annotation type="algorithm">conformance</annotation></phrase> <phrase><annotation type="algorithm">content management algorithm</annotation></phrase> <phrase><annotation type="algorithm">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract and merge algorithm</annotation></phrase> <phrase><annotation type="algorithm">extract and merge</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">Content management systems</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase></p>
</annotations>
<index>
<row>
<type>concept</type>
<term>publishing algorithm</term>
</row>
</index>
<p>All structured writing must eventually be published. Publishing structured content means transforming it from the domain in which it was created (<phrase><annotation type="concept">subject domain</annotation></phrase>, <phrase><annotation type="concept">document domain</annotation></phrase>, or the abstract end of the <phrase><annotation type="concept">media domain</annotation></phrase>) to the most concrete end of the media domain spectrum: dots on paper or screen.</p>
<p>Publishing is a complex process, particularly in an environment where you may be practicing single sourcing, content reuse, or many of the other structured writing algorithms we have looked at. The best way to handle that complexity is to partition and distribute it to appropriate people and processes.</p>
<p>In this chapter, I am going to describe a partitioning of the publishing process into four basic algorithms which I have mentioned in passing in earlier chapters: the synthesis, presentation, formatting, and encoding algorithms. These four stages are formalized in the <phrase><annotation type="tool">SPFE architecture</annotation></phrase>, which I will talk about later, but I think they are a fair representation of what goes on in most publishing tool chains, even if those tool chains donâ€™t divide responsibilities exactly as I describe them here, or make such clear separation between them as I do.</p>
<p>We have noted that the successful partitioning of a process depends on the ability to communicate everything that is needed for a partition to do its job, and that one hallmark of a successful partitioning is how clear and functional the required communication is. In partitioning of the publication process that I will describe here, each step deals with a different concern and each step produces an output, in the form of a structured document or set of documents, that is structured in terms of the concern it deal with. This then becomes the input to the next step. The structures that these steps produce and consume are stages along the path from the subject to document to media domains. In other words, the publication process is structured to move content through the domains, just as we described in <citation type="nameref" value="chapter.three-domains"/>.</p>
<section>
<title>The Rendering Algorithm</title>
<p>There is actually a fifth algorithm in the publishing chain, which we can call the rendering algorithm. The rendering algorithm is the one responsible for actually placing the right dots on the right surface, be that paper, screen, or a printing plate. But this is a low-level device-specific algorithm and no one in the structured writing business is likely to be involved in writing rendering algorithms. The closest we ever get is the next step up, the encoding algorithm.</p>
<p>The rendering algorithm requires some form of input to tell it where to place the dots. In writing, this usually comes in the form of something called a <phrase><annotation type="tool">page description language</annotation></phrase>. Like it sounds, this is a language for describing what goes where on a page, but in higher level terms that describing where each dot of ink or pixel of light is placed. A page description language deals in things like lines, circles, gradients, margins, and fonts.</p>
<insert item="../graphics/rendering.xml" type="image"/>
<p>One example of a page description language is <phrase><annotation type="language">PostScript</annotation></phrase>. Here is the PostScript code for drawing a circle:</p>
<codeblock language="PostScript">
100 100 50 0 360 arc closepath
stroke
</codeblock>
<p>This code is basically moving a virtual pen over a virtual output device; the equivalent of a hand guiding a pen over paper. But it is a much lower-level operation than we need to worry about in structured writing.</p>
</section>
<section>
<title>The Encoding Algorithm</title>
<p>Since most writers are not going to write directly in a page description language, the page descriptions for your publication are almost certainly going to be created by an algorithm. I call this the encoding algorithm since it encodes your content in the page description language.</p>
<p>While it is possible that someone responsible for a highly specialized publishing tool chain may end up writing a specialized encoding algorithm, most encoding algorithms are going to be implemented by existing tools that translate formatting languages into page descriptions languages.</p>
<p>There are several formatting languages that are used in content processing. They are often called typesetting languages as well. <phrase><annotation type="language">XSL-FO</annotation></phrase> (XSL - Formatting Objects) is one of the more commonly used in structured writing projects. <phrase><annotation type="tool">TeX</annotation></phrase> is another.</p>
<insert item="../graphics/encoding.xml" type="image"/>
<p>Here is an example of XSL-FO that we looked at in <citation type="nameref" value="chapter.single-sourcing"/>:</p>
<codeblock language="XSL-FO">
&lt;fo:block space-after="4pt"&gt;
   &lt;fo:wrapper font-size="14pt" font-weight="bold"&gt;
     Hard Boiled Eggs
   &lt;/fo:wrapper&gt;
&lt;/fo:block&gt;
</codeblock>
<codeblock>
</codeblock>
<p>You process XSL-FO using an XSL-FO processor such as <phrase><annotation type="tool">Apache FOP</annotation></phrase>. Thus the XSL-FO processor runs the encoding algorithm, producing a page description language such as <phrase><annotation type="language">PostScript</annotation></phrase> or <phrase><annotation type="language">PDF</annotation></phrase> as an output.</p>
<p>Writers are not likely to write in XSL-FO directly, though it is not entirely impossible to do so. In fact some boilerplate content such as front matter for a book does sometimes get written and recorded directly in XSL-FO. (I did this myself on one project.) But when you are constructing a publishing tool chain, you will need to select and integrate the appropriate encoding tools as part of your process.</p>
<p>The job of the encoding algorithm is to take a high level description of a page or a set of pages, their content and their formatting, and turn it into a page description language that lays out each page precisely. For publication on paper, or any other fixed-sized media, this involves a process called <phrase><annotation type="concept">pagination</annotation></phrase>: figuring out exactly what goes on each page, where each line breaks, and when lines should be bumped to the next page.</p>
<p>It is the pagination function, for instance, that figures out how to honor the keep-with-next formatting in an application like Word or FrameMaker. It also has to work out how to deal with complex figures such as tables: how to wrap text in each column, how to break a table across pages, and how to repeat the header rows when a table breaks to a new page. Finally, it has to figure out how to number each page and then fill in the right numbers for any references that include a particular page number.</p>
<p>This is all complex and exacting stuff and depending on your requirements you may have to pay some attention to make sure that you are using a formatting language that is capable of doing all this the way you want it done.</p>
<p>Also, you are going to have to think about just how automatic you want all of this to be. In a high-volume publication environment you want it to be fully automatic, but this could involve accepting some compromises. For example, in book publishing it is not uncommon for writers and editors to make slight edits to the actual text of a document in order to make pagination work better. This is very easy to do when you are working in the <phrase><annotation type="concept">media domain</annotation></phrase> in an application like <phrase><annotation type="tool" specifically="Microsoft Word">Word</annotation></phrase> or <phrase><annotation type="tool">FrameMaker</annotation></phrase>. If you end up with the last two words of a chapter at the top of a page all by itself, for instance, it is usually possible to find a way to edit the final paragraph to reduce the word count just enough to pull the end of the chapter back to the preceding page. This sort of thing gets much harder to do when you are writing in the <phrase><annotation type="concept">document domain</annotation></phrase> or the <phrase><annotation type="concept">subject domain</annotation></phrase>, particularly if you are <phrase><annotation type="algorithm">single sourcing</annotation></phrase> content to more than one publication or <phrase><annotation type="algorithm" specifically="content reuse">reusing content</annotation></phrase> in many places. An edit that fixes one pagination problem could cause another, and a major reason for writing in those domains it to take formatting concerns off the authorâ€™s plate.</p>
<p>For Web browsers and similar dynamic media viewers, such as E-Book readers or help systems, the whole pagination process takes place dynamically when the content is loaded into the view port, and it can be redone on the fly if the reader resizes their browser or rotates their tablet. This means the publisher has very little opportunity to tweak the pagination process. They can guide it by providing rules such as keep-together instructions through things like <phrase><annotation type="language">CSS</annotation></phrase>, but they obviously cannot hand tweak the text to make it fit better each time the view port is resized.</p>
<p>The formatting language for these kinds of media is typically <phrase><annotation type="tool">Cascading Style Sheets</annotation></phrase> (CSS).</p>
</section>
<section>
<title>The Formatting Algorithm</title>
<p>The job of the formatting algorithm it to generate the formatting language that drives the encoding and pagination process. The formatting algorithm produces the <phrase><annotation type="concept">media domain</annotation></phrase> representation of the content from content in the <phrase><annotation type="concept">document domain</annotation></phrase>.</p>
<insert item="../graphics/formattingpub.xml" type="image"/>
<p>In the case of HTML output, the formatting algorithm generates HTML (with connections to the relevant CSS, JavaScript, and other formatting resources). This is the end of the publishing process for the Web, since the browser will perform the encoding algorithm internally and the computer operating system will likely take care of the rendering. In the case of paper output, the formatting algorithm generates a formatting language such as <phrase><annotation type="tool">TeX</annotation></phrase> or <phrase><annotation type="language">XSL-FO</annotation></phrase> which is then fed to the encoding algorithm as implemented by a TeX or XSL-FO processor.</p>
<p>In some cases, organizations use word processing or desktop publishing applications to tweak the formatting of the output by having the formatting algorithm generate the input format of those applications (typically <phrase><annotation type="language">RTF</annotation></phrase> for Word and <phrase><annotation type="language">MIF</annotation></phrase> for FrameMaker). This allows them to exercise manual control over pagination, but with an obvious loss in process efficiency. In particular, any tweaks made in these applications are not routed back to the source content, so they will have to be done again by hand the next time the content is published.</p>
<p>This algorithm is usually the province of publication designers. One of the most elementary structured writing algorithms is to <phrase>separate content from formatting</phrase> (<citation type="nameref" value="chapter.separating"/>) which means removing formatting as one of the writerâ€™s concerns. Almost every structured writing implementation will involve writing formatting algorithms, however. Even if you use off-the-shelf languages like DITA or DocBook, you will have to write or modify formatting algorithms to get the specific formatting you want. We looked at some examples of basic formatting algorithms in <citation type="nameref" value="chapter.processing"/>.</p>
</section>
<section>
<title>The Presentation Algorithm</title>
<p>The job of the presentation algorithm is to determine exactly how the content is going to be organized as a document. A pure document domain document is a representation of the presentation of the content. The job of the <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> is to produce a pure <phrase><annotation type="concept">document domain</annotation></phrase> version of the content. This may mean producing the entire presentation from purely <phrase><annotation type="concept">subject domain</annotation></phrase> content, or simply handling the occasional subject domain structure in a largely document domain file.</p>
<insert item="../graphics/presentation.xml" type="image"/>
<p>The organization of content involves several things:</p>
<ll>
<li>
<label>Ordering</label>
<p>At some level, content forms a simple sequence in which one piece of information follows another. Authors writing in the document domain typically order content as they write, but if they are writing in the subject domain, they can choose how they order subject domain information in the document domain.</p>
</li>
<li>
<label>Grouping</label>
<p>At a higher level, content is often organized into groups. This may be groups on a page or groups of pages. Grouping includes breaking content into sections or inserting subheads, inserting tables and graphics, and inserting information as labeled fields. Authors writing in the document domain typically create these groupings as they write, but if they are writing in the subject domain, you may have choices about how you group subject domain information in the document domain.</p>
</li>
<li>
<label>Blocking</label>
<p>On a page, groups may be organized sequentially or laid out in some form of block pattern. Exactly how blocks are to be laid out on the displayed page is a media domain question, and something that may even be  done dynamically. In order to enable the media domain to do this, however, the document domain must clearly delineate the types of blocks in a document in a way that the formatting algorithm can interpret and act on reliably.</p>
</li>
<li>
<label>Labeling</label>
<p>Any grouping of content requires labels to identify the groups. This includes things like titles and labels on data fields. Again, these are typically created by authors in the <phrase><annotation type="concept">document domain</annotation></phrase>, but are almost always factored out when authors write in the <phrase><annotation type="concept">subject domain</annotation></phrase> (most labels indicate the place of content in the subject domain, so inserting them is a necessary part of reversing the factoring out of labels that occurs when you move to the subject domain).</p>
</li>
<li>
<label>Relating</label>
<p>Ordering, grouping, blocking, and labeling cover organization on a two dimensional page or screen. But information is related to other information in complex ways which we can express by creating non-linear relationships between pieces of content. This includes hypertext links and cross references.</p>
</li>
</ll>
</section>
<section>
<title>Differential presentation algorithms</title>
<p>As we saw in <citation type="nameref" value="chapter.single-sourcing"/>, the organization of content is an area where the <phrase><annotation type="concept">document domain</annotation></phrase> cannot ignore the differences between different media. Although the fact that a relationship exists is a pure document domain issue, how that relationship is expressed, and even whether it is expressed or not, is affected by the media and its capabilities. Following links in online media is very cheap. Following references to other works in the paper world is expensive, so document design for paper tends to favor linear relationships where document design for the web favors <phrase><annotation type="concept">hypertext</annotation></phrase> relationships. This is an area, therefore, in which you should expect to implement <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> and use different presentation algorithms for different media.</p>
<insert item="../graphics/differentialpub.xml" type="image"/>
</section>
<section>
<title>Presentation sub-algorithms</title>
<p>Many other structured writing algorithm, are executed as part of the presentation algorithm. Among them:</p>
<section>
<title>The linking algorithm</title>
<p>How content is linked or cross-referenced is a key part of how it is organized in different media, and a key part of differential single sourcing. We looked at the <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> in detail in <citation type="nameref" value="chapter.linking"/>.</p>
</section>
<section>
<title>The information architecture algorithm</title>
<p>Part of the presentation of a document or document set is creating the table of contents, index, and other navigation aids. Creating these is part of the presentation process. Because these algorithms create new resources by extracting information from the rest of the content, it is often easier to run these algorithm in serial after the main presentation algorithm has run. This also makes it easier to change the way a TOC or index is generated without affecting your other algorithms. For more on the information architecture algorithm, see <citation type="nameref" value="chapter.architecture"/>.</p>
</section>
</section>
<section>
<title>The Synthesis Algorithm</title>
<p>The job of the synthesis algorithm is to determine exactly what content will be part of a content set. It passes a complete set of content on to the presentation algorithm to be turned into one or more document presentations.</p>
<p>Among other things, the synthesis domain resolves all management domain structures in the content (unless some are to be retained for downstream post-publication algorithms to work with). This means that it processes all inclusions and evaluates all conditions. The result is document domain or subject domain content with all of the management structures removed and replaced with the appropriate document or subject domain structures and content.</p>
<p>In the case of document domain content, processing the management domain structures yields a document-domain structure which may then be a pass-through for the presentation algorithm (that is, the document domain markup may already express the desired presentation).</p>
<p>In the case of the subject domain content, processing management domain structures yields a definitive set of subject domain structures which can be passed to the presentation algorithm for processing to the document domain.</p>
<insert item="../graphics/synthesis.xml" type="image"/>
</section>
<section>
<title>Differential synthesis</title>
<p>We noted above that you can use differential presentation to do <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> were two publications contain the same content but organized differently. If you want two publications in different media to have differences in their content, you can do this by doing differential synthesis and including different content in each publication.</p>
<insert item="../graphics/differential-synthesis.xml" type="image"/>
</section>
<section>
<title>Synthesis sub-algorithms</title>
<p>A number of structured writing algorithms are executed at the synthesis stage. In order to keep things well partitioned, it is often advisable to execute each one as a separate sub step in the synthesis stage.</p>
<section>
<title>The reuse algorithm</title>
<p>Pulling in reused content is part of the synthesis process. We looked at the reuse algorithm in <citation type="nameref" value="chapter.reuse"/>.</p>
</section>
<section>
<title>The extraction algorithm</title>
<p>In some cases you may wish to extract information from external sources to create content. This can include data created for other purposes, such as application code or data created and maintained as a canonical source of information, such as a database of features for different models of a car. Extraction is part of the synthesis process. See <citation type="nameref" value="chapter.extract"/>.</p>
</section>
<section>
<title>The merge algorithm</title>
<p>In one sense, every structured writing algorithm is a merge algorithm. As we saw in <citation type="nameref" value="chapter.processing"/>, most algorithms consist of factoring into content information or metadata that was factored out as we moved the point of recording from the <phrase><annotation type="concept">media domain</annotation></phrase> to the <phrase><annotation type="concept">document domain</annotation></phrase> and the <phrase><annotation type="concept">subject domain</annotation></phrase>. But it is also possible, and often useful, to combine information from different sources to create a new set of content. Merging content is done at the synthesis stage of publication. See <citation type="nameref" value="chapter.merge"/>.</p>
</section>
</section>
<section>
<title>Deferred synthesis</title>
<p>For static presentation, all synthesis happens before the material is presented. But if you are presenting content on the web, you can defer parts of the synthesis algorithm to the browser, which can synthesize and present content by making calls to web services or other back-end data source, or by making a request to code running on the server to synthesize and present part of the page. We looked at this in <citation type="nameref" value="chapter.active"/>.</p>
<!--  more? -->
</section>
<section>
<title>Combining algorithms</title>
<p>As we have seen, structured writing algorithms are usually implemented as sets of rules that operate on structures as they encounter them in the flow of the content. Since each algorithm is implemented as a set of rules, it is possible to run two algorithms in parallel by adding the two sets of rules together to create a single combined set of rules that implements both algorithms at once.</p>
<p>Obviously, care must be taken to avoid clashes between the two sets of rules. If two set of rules act on the same structure, you have to do something to get the two rules that address that structure to work together. (Different tools may provide different ways of doing this.)</p>
<p>In other cases, though, one algorithm needs to work with the output of a previous algorithm, in which case, you need to run them in serial.</p>
<p>In most cases, the major algorithms (synthesis, presentation, formatting, encoding, and rendering) need to be run in serial, since they transform an entire content set from one domain to another (or from one part of a domain to another). In many cases the sub-algorithms of these major algorithms can be run in parallel by combining their rule sets since they operate on different content structures.</p>
</section>
<section>
<title>Architecture of a publishing tool chain</title>
<p>Overall the architecture of a publishing tool chain should be designed to facilitate the partitioning and distribution of complexity in the content system. Almost all of the structured writing algorithms we have talked about are executed at some point in the publishing process. (The exceptions are those that are concerned with aspects of conformance, which operate on the content store independent of any publishing events.)</p>
<p>The partitioning of the system needs to make sure that information is passed from one partition to another (whether the task of that partition is executed by a person or an algorithm). This means that the execution of that partition needs to happen at the right time and place â€“ the time and place in which the information it needs is available, and before the time and place where the information it produces is needed. The SPFE structure â€“ Synthesis, Presentation, Formatting, Encoding â€“ seems to provide a good general framework into which the various algorithms and their timing fit reasonably well. However, you should not get hung up on either the names or the order of operations that this architecture describes. The goal is to partition and distribute the complexity of your content system so that none of the complexity goes unhandled and no one person or process is asked to handle more of the complexity than they have the time and resources to manage. Any architecture that accomplishes that for you particular content system is a good architecture.</p>
<p>A significant chunk of the complexity of the content system is the complexity of the publishing process itself, and the creation and management of all its working parts. The creation of reliable code to implement each of the structured writing algorithms is a complex task, and the partitioning and distribution of that complexity should be a major design and/or tool selection consideration.</p>
<p>Two keys to partitioning the complexity of code are to keep code units small and simple, and to reuse code when you can. It is a sound principle that each piece of code should do one thing and one thing only. Taking a pieces of content written in the subject domain or the document domain, particularly with some management domain added in, is a complex business. As we have seen, it involved the execution of many algorithms. Writing a single program to execute all of those algorithms at once would be complex and would violate the principle of simplicity and would leave little room for the reuse of code.</p>
<p>Every step in a content publishing chain reads in one or more structured content files and produces one or more structured content files in a different domain, or, at least, nearer to the media domain and dots on a page than the input file. There are two ways to separate the algorithms of your publishing chain.</p>
<ul>
<li>
<p>If two algorithms work on non-overlapping structures in the content file, you can run the two sets of rules in parallel. If you use tools that implement the rule-based model of content processing that is described in this book (tools such as XSLT) then you can simply include the two rule sets in one program and run the program on the source file. The output of this process should be a new structured content file nearer to the <phrase><annotation type="concept">media domain</annotation></phrase>.</p>
</li>
</ul>
<ul>
<li>
<p>If an algorithm works on the whole source file, create a single program and run it on the source file, creating a structured content file that will be the input to the next algorithm.</p>
</li>
</ul>
<p>The implication of this is that different algorithms work on content at different points on the continuum from the subject domain to the media domain, which is, of course, the case. But as we have noted in many of the algorithms we have looked at, there is a way to execute the algorithm in any of the structured writing domains. As far as processing goes, the linking algorithm for subject domain content is different from the linking algorithm for document domain content. But if you use subject annotation rather than link markup in your content, this does not mean you use the subject domain linking algorithm instead of the document domain linking algorithm. It means you use the subject domain linking algorithm and the document domain linking algorithm, one after the other. At least, if you create a layers publishing architecture like the one I have outlined here, the subject domain linking algorithm create document domain linking markup as an output, which is then processed by document domain linking markup to produce media-appropriate links in the media domain. (Which means you donâ€™t need several media-specific versions of the subject domain linking algorithm.)</p>
<p>In <citation type="nameref" value="chapter.processing"/> we saw examples of algorithms that moved subject domain content to the document domain, and other algorithms that then moved that same content from the document domain to the media domain for publishing. This is the template of all publishing processes. In the real world, though, you may have more than one intermediate stage in the journey. This architecture is sometimes referred to as a publishing pipeline. Each step in the publishing process is kept simple by only doing one job and then passing the content on to the next step in the pipeline.</p>
<p>This architecture means that each individual program you have to write is relatively simple and straightforward, which makes it much easier to design, write, debug, and maintain. Many small self-contain programs operating as a pipeline will usually be both cheaper to create and maintain and more robust than a single monolithic program that tries to do everything in one step.</p>
<p>The pipeline approach also allows for a great deal of reuse of existing code. For example, if your content is written in the subject domain, you need to get it all the way to the media domain for publication. But along that road to the media domain, it passes through the document domain. There are a number of robust document-domain publishing tool chains available: <phrase><annotation type="language">DocBook</annotation></phrase>, <phrase><annotation type="language">DITA</annotation></phrase>, <phrase>reStructuredText</phrase>, <phrase>LaTeX</phrase>. You could write a <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> to transform each of your subject domain structures into any one of these format and then simply use their existing tool chains for the rest of your publishing pipeline.</p>
<p>Other opportunities exist for code reuse at a more granular level. For instance, all of your <phrase><annotation type="concept">subject domain</annotation></phrase> structures are going to need paragraphs and lists and other basic text structures, as well as their individual subject-specific structures, and the same <phrase>subject annotations</phrase> are likely to occur across your whole content set. You can use the same definitions of basic text structures and subject annotations across your entire content set, and write just one rule set for those text structures and subject annotations that is used everywhere, greatly reducing the amount of code you have to write.</p>
</section>
</chapter>
