<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.linking">
<title>Linking</title>

<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept">affordances</annotation></phrase> <phrase><annotation type="concept">AI</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">apps</annotation></phrase> <phrase><annotation type="concept" specifically="block-and-map architecture">block and map architecture</annotation></phrase> <phrase><annotation type="concept">block-and-map architecture</annotation></phrase> <phrase><annotation type="concept" specifically="bottom-up information architecture">bottom-up architecture</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content engineering</annotation></phrase> <phrase><annotation type="concept">content hygiene</annotation></phrase> <phrase><annotation type="concept">content plan</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">curse of knowledge</annotation></phrase> <phrase><annotation type="concept">desktop publishing system</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">Duplication</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">filtering</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept" specifically="information architecture">information architectures</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information scent</annotation></phrase> <phrase><annotation type="concept">information snacking</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept" specifically="information snacking">information-snacking</annotation></phrase> <phrase><annotation type="concept">information-typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept" specifically="management domain">management domains</annotation></phrase> <phrase><annotation type="concept" specifically="management domain">Management domains</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept" specifically="management domain">management-domain</annotation></phrase> <phrase><annotation type="concept" specifically="markup language">markup languages</annotation></phrase> <phrase><annotation type="concept">markup language</annotation></phrase> <phrase><annotation type="concept">markup</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept" specifically="media domain">media-domain</annotation></phrase> <phrase><annotation type="concept" specifically="media domain">media domains</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">namespace</annotation></phrase> <phrase><annotation type="concept">natural language processing</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">out-of-band communication</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">profiling</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical quality</annotation></phrase> <phrase><annotation type="concept">rhetorical structure</annotation></phrase> <phrase><annotation type="concept" specifically="rhetoric">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">schema language</annotation></phrase> <phrase><annotation type="concept" specifically="schema">Schemas</annotation></phrase> <phrase><annotation type="concept" specifically="schema">schemas</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">social networks</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">stop list</annotation></phrase> <phrase><annotation type="concept">structural block</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style guide</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">Subject</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology management</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">vector graphics</annotation></phrase> <phrase><annotation type="concept">web publishing</annotation></phrase> <phrase><annotation type="concept">Wikipedia</annotation></phrase> <phrase><annotation type="concept">workflow</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase> <phrase><annotation type="concept">glyphs</annotation></phrase> <phrase><annotation type="concept" specifically="hierarchical information architecture">hierarchical information architectures</annotation></phrase></p>
<p>Markup Languages</p>
<p><phrase><annotation type="markup-language">ASCIIDOC</annotation></phrase> <phrase><annotation type="markup-language"><annotation type="standard">CommonMark</annotation></annotation></phrase> <phrase><annotation type="markup-language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="markup-language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="markup-language">GitHub flavored Markdown</annotation></phrase> <phrase><annotation type="markup-language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="markup-language"><annotation type="standard">HTML5</annotation></annotation></phrase> <phrase><annotation type="markup-language">JavaDoc</annotation></phrase> <phrase><annotation type="markup-language">LaTeX</annotation></phrase> <phrase><annotation type="markup-language">Lightweight DITA</annotation></phrase> <phrase><annotation type="markup-language">Markdown</annotation></phrase> <phrase><annotation type="markup-language">mathml</annotation></phrase> <phrase><annotation type="markup-language">reStructuredText</annotation></phrase> <phrase><annotation type="markup-language">SAM</annotation></phrase> <phrase><annotation type="markup-language"><annotation type="standard">SGML</annotation></annotation></phrase> <phrase><annotation type="markup-language">TeX</annotation></phrase> <phrase><annotation type="markup-language">vCard</annotation></phrase> <phrase><annotation type="markup-language">Wiki markup</annotation></phrase> <phrase><annotation type="markup-language">XLIFF</annotation></phrase> <phrase><annotation type="markup-language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="markup-language"><annotation type="standard">XHTML</annotation></annotation></phrase></p>
<p>Schema languages</p>
<p><phrase><annotation type="schema-language">XSD</annotation></phrase> <phrase><annotation type="schema-language" specifically="XSD">XML schema</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="programming-language">cascading style sheets</annotation></phrase> <phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase> <phrase><annotation type="language-language">XSL-FO</annotation></phrase> <phrase><annotation type="programming-language">XSLT</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm" specifically="assemble from pieces">Assemble from Pieces</annotation></phrase> <phrase><annotation type="algorithm" specifically="assemble from pieces">assemble from pieces</annotation></phrase> <phrase><annotation type="algorithm" specifically="auditing algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="auditing algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm" specifically="auditing algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm" specifically="auditing algorithm">audits</annotation></phrase> <phrase><annotation type="algorithm" specifically="auditing algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm" specifically="avoiding duplication">avoids duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm" specifically="collaboration">collaborate</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="algorithm">conformance-checking algorithm</annotation></phrase> <phrase><annotation type="process">conformance</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforming</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> <phrase><annotation type="algorithm">content generation algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content generation algorithm">content generation</annotation></phrase> <phrase><annotation type="algorithm" specifically="content management algorithm">content management algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content management algorithm">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content generation algorithm">content-generation algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content generation algorithm">Generating content</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">eliminating duplication</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extraction algorithms</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extraction algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting algorithms</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="separating content form formatting">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm" specifically="separating content form formatting">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm" specifically="separating content from formatting">separation of content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool" specifically="API documentation tool">API documentation tools</annotation></phrase> <phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="component content management system">CCMS</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">component content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool" specifically="desktop publishing system">desktop publishing application</annotation></phrase> <phrase><annotation type="tool" specifically="desktop publishing system">desktop publishing programs</annotation></phrase> <phrase><annotation type="tool" specifically="desktop publishing system">desktop publishing</annotation></phrase> <phrase><annotation type="tool">desktop publishing system</annotation></phrase> <phrase><annotation type="tool">DITA CMS</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool" specifically="formatting language">formatting languages</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting software</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">GitHub</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Jekyll</annotation></phrase> <phrase><annotation type="tool">Liquid</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool" specifically="search engine">Search engines</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">SPFE Open Tool Kit</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool" specifically="static site generator">static site generators</annotation></phrase> <phrase><annotation type="tool">structured editor</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">validator</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool" specifically="Microsoft Word">Word</annotation></phrase> <phrase><annotation type="tool">WordPerfect</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool" specifically="XML editor">XML editors</annotation></phrase> <phrase><annotation type="tool">XML editor</annotation></phrase> <phrase><annotation type="tool" specifically="wiki">wikis</annotation></phrase> <phrase><annotation type="tool" specifically="wiki">Wikis</annotation></phrase> <phrase><annotation type="tool" specifically="word processor">Word processors</annotation></phrase> <phrase><annotation type="tool">word processor</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role" specifically="content engineer">content engineers</annotation></phrase> <phrase><annotation type="role">content strategist</annotation></phrase> <phrase><annotation type="role" specifically="content strategist">content strategists</annotation></phrase> <phrase><annotation type="role">document designer</annotation></phrase> <phrase><annotation type="role" specifically="document designer">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role" specifically="information architect">information architects</annotation></phrase> <phrase><annotation type="role">prepress operator</annotation></phrase> <phrase><annotation type="role">publication designer</annotation></phrase> <phrase><annotation type="role" specifically="publication designer">publication designers</annotation></phrase> <phrase><annotation type="role" specifically="subject matter expert">subject matter experts</annotation></phrase> <phrase><annotation type="role" specifically="terminologist">terminologists</annotation></phrase> <phrase><annotation type="role">terminologist</annotation></phrase> <phrase><annotation type="role">typesetter</annotation></phrase> <phrase><annotation type="role">webmaster</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>People <phrase><annotation type="person">Donald Knuth</annotation></phrase> <phrase><annotation type="person">Gutenberg</annotation></phrase> <phrase><annotation type="person">Henry Ford</annotation></phrase> <phrase><annotation type="person">John Gruber</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">fragment</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">map</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure" specifically="rhetorical block">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">tables of contents</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure" specifically="table">tables</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure" specifically="topic">topics</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">books</annotation></phrase> <phrase><annotation type="media">CD-ROM</annotation></phrase> <phrase><annotation type="media">ebooks</annotation></phrase> <phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Interactive Electronic Technical Manuals</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase></p>
</annotations>
<index>
<record>
<type>concept</type>
<term>linking</term>
</record>
<record>
<type>concept</type>
<term>linking algorithm</term>
</record>
</index>
<p>A large part of the complexity of content is that readers do not read in a straight line. Numerous studies<citation idref="1"/> have shown that readers often read opportunistically, looking for one piece of information or the answer to a particular question. Their behavior can best be described as <phrase><annotation type="concept">information foraging</annotation></phrase>. They are sniffing for the scent of the information they want and will follow its trail as long as the scent gets stronger and the trail is easy to follow.</p>
<footnote id="1">
<p>For a discussion of these studies and their implications for how we write, see my book <phrase><annotation type="citetitle">Every Page is Page One: Topic-based Writing for Technical Communication and the Web</annotation></phrase>.</p>
</footnote>
<p>The best way to support this information foraging behavior is with a <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> (as described in <citation nameref="chapter.architecture"/>). Linking is key to building a bottom-up information architecture. But as we discussed in <citation nameref="chapter.single-sourcing"/>, different media often require different rhetoric and a difference in linking strategy is a big part of that difference. This makes linking a complex problem.</p>
<p>Linking is at the heart of a <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase>. In a bottom-up architecture, a page is not simply a leaf on a tree: the prize you find at the end of the search. It is a junction point in the exploration of an information space and the quest to understand a subject.</p>
<p>For example, while reading your content, readers may discover new subjects they need to understand and new options they need to consider. Readers may discover that what they thought they knew is wrong or that what they thought they wanted to do was not the right choice. They may find that their search or navigation has led them to the wrong place, or they may discover new worlds to explore. On a more mundane level, they may discover that they need additional information, such as reference data, to complete a task.</p>
<p>These are all pointers to some next page that a reader may need. However, even the most prescient writer cannot make every possibility the next page in a linear narrative. To serve readers, writers need to pave all of the possible paths, and the way to do that is with <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase>.</p>
<p>This means that linking is not something that happens at arbitrary points where the writer feels like adding a link. Linking must be planned for as part of the <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase>. Whether you specify hard links in the <phrase><annotation type="concept">media domain</annotation></phrase> or the <phrase><annotation type="concept">document domain</annotation></phrase>, manage links with keys in the <phrase><annotation type="concept">management domain</annotation></phrase>, or generate them from <phrase><annotation type="structure">subject annotations</annotation></phrase> in the <phrase><annotation type="concept">subject domain</annotation></phrase>, links should be created in a disciplined and consistent manner according to a deliberate plan.</p>
<p>The trail a reader follows through an information set has junction points, places where the reader can decide to keep going straight through the current document or turn aside to look at a different document. While a reader can decide to switch documents at any point and for any reason, the most common reason for switching is because they want more information about, or are simply more interested in, a subject mentioned in the current document.</p>
<p>Even if each document describes just one subject, it still mentions many other subjects in the course of describing its own subject. Thus, a movie review mentions actors, directors, and other movies; a recipe mentions cooking techniques such as whisking and grilling; and a programming topic mentions functions, libraries, and data structures.</p>
<section id="sect.linking-subject-affinities">
<title>Subject affinities</title>

<index>
<record>
<type>concept</type>
<term>subject affinities</term>
</record>
</index>
<p>I call the points where a document mentions related subjects <phrase><annotation type="italic"><annotation type="concept">subject affinities</annotation></annotation></phrase>. Subject affinities are the junction points where the subjects of different pieces of content intersect, the points were the reader may choose to turn or to go straight on.</p>
<p>Suppose you are reading a recipe and come across the instruction “sweat the onions,” but you don’t know how to do that. You can’t continue without that knowledge, so you turn aside in search of it. The words “sweat the onions” are a point of subject affinity between the recipe and the cooking technique of sweating vegetables. Your decision to turn in search of additional information at this point is not arbitrary. It follows from the relationship between the task of making the dish and a cooking technique used in that task. Writers can anticipate that some readers will need to make this turn at this point of subject affinity.</p>
<p>This particular subject affinity, between a recipe and a cooking technique, is neither arbitrary nor unique. The subject affinity between recipes and basic cooking techniques applies universally and can be modeled using structured writing techniques.</p>
<p>The need to seek more information on a subject or task is part of the complexity of information seeking. The goal of information delivery is to make information seeking simpler. If you don’t make it possible for your readers to find this information when they need it, you are dumping the complexity of navigating the subject affinity onto them. Managing subject affinities, therefore, is an important part of managing the overall complexity of the content system. Making sure that every part of the complexity of the content system is handled by a person or process that has the skill, time, and resources to handle it extends to the reader. You don’t want to give readers any navigational complexity that they are not fully equipped to handle. Indeed, you want to make it as easy as you can for them to navigate subject affinities.</p>
<p>The most obvious, and generally the most powerful, way of handling subject affinities is to create links from the point in the text where the affinity occurs to a suitable resource that provides the needed information. If you force readers to use search, go to a table of contents, or consult an index when you could easily provide a direct link, you are dumping complexity on them.</p>
<p>But linking is not the only way to handle subject affinities, nor is linking an option in all media. You can use footnotes, cross references, sidebars, or parenthetical statements to provide additional information. You can even attempt to anticipate and forestall a reader’s information need by using data about that individual to dynamically reorder the content. A discussion of linking, therefore, needs to consider other ways of handling subject affinities that may be appropriate in particular circumstances.</p>
<p>If you <phrase><annotation type="algorithm">single-source</annotation></phrase> content between different media, you might want to handle subject affinities differently between paper and hypertext outputs. For example, you might want to include a chunk of explanatory content in a sidebar in paper documents but link to a single copy of it in <phrase><annotation type="media">hypertext</annotation></phrase>. Linking, in other words, is a kind of <phrase><annotation type="algorithm">reuse</annotation></phrase> that avoids duplication by referencing content rather than copying it.</p>
<p>Thus, you should not think solely in terms of managing links. Instead, you should think about managing <phrase><annotation type="concept">subject affinities</annotation></phrase> and supporting them in a way that works best with each of your output formats.</p>
<p>One of the biggest problems with link management is that it’s complex and often time-consuming. As a result, many organizations do not link their content adequately, nor do they provide alternative ways to handle subject affinities. They just dump the complexity of finding the next piece of information right back on the reader.</p>
<p>However, there are ways to partition the complexity of link management and subject affinity management that make it much easier and more economical for writers to provide good subject affinity support. To understand how to do this, it is useful to look at how link and subject affinity management works in each of the <phrase><annotation type="concept">structured writing domains</annotation></phrase>.</p>
</section>
<section>
<title>Subject affinities in the media domain</title>

<p>In the <phrase><annotation type="concept">media domain</annotation></phrase>, you simply record the various devices used to express subject affinities: cross references, tables, links, etc. For example, in HTML a link specifies a page to load:</p>
<codeblock language="html">
&lt;p&gt;In Rio Bravo, 
&lt;a href="https://en.wikipedia.org/wiki/John_Wayne"&gt;the Duke&lt;/a&gt; 
plays an ex-Union colonel out for revenge.&lt;/p&gt;
</codeblock>
<p>The phrase “the Duke” is a subject affinity. The reader may not know who “the Duke” is or may want more information about him. The link allows the reader to navigate the subject affinity and find the information needed.</p>
<p>But if the page is printed, the link is lost. The phrase “the Duke” is still a subject affinity, and the reader may still want more information. The reader can still get more information by doing a search for “the Duke” or asking a friend what the phrase means. But the printed version doesn’t support the reader’s need. It dumps the complexity of the search back on the reader.</p>
<p>If the content had been written for paper, the subject affinity might be supported in a different way. For example, it might be supported by adding an explanation in parentheses:</p>
<blockquote>
<p>In Rio Bravo, the Duke (John Wayne) plays an ex-Union colonel out for revenge.</p>
</blockquote>
<p>Or it might be handled with a footnote:</p>
<codeblock language="text">
In Rio Bravo, the Duke* plays 
an ex-Union colonel out for revenge.
        
...
        
* "The Duke" is the nickname of the actor John Wayne.
</codeblock>
<p>Clearly, this is a case where you would like to do <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> and handle the subject affinity differently in different media. To accomplish this, you need to move the content out of the <phrase><annotation type="concept">media domain</annotation></phrase>.</p>
</section>
<section>
<title>Subject affinities in the document domain</title>

<p>Moving to the <phrase><annotation type="concept">document domain</annotation></phrase> is about factoring out the formatting specific structures of the media domain. But a link is not really a piece of formatting, so conventional refactoring into abstract document structures doesn’t apply. For this reason, people working in the <phrase><annotation type="concept">document domain</annotation></phrase> often enter hypertext links exactly the way they would in the media domain – by specifying a URL. Thus, in <phrase><annotation type="markup-language"><annotation type="standard">DITA</annotation></annotation></phrase> you might enter a link as:</p>
<codeblock language="DITA">
&lt;p&gt;In Rio Bravo, 
  &lt;xref href="https://en.wikipedia.org/wiki/John_Wayne" 
        format="html"&gt;The Duke&lt;/xref&gt; 
  plays an ex-Union colonel out for revenge.
&lt;/p&gt;
</codeblock>
<p>The difference from <phrase><annotation type="markup-language"><annotation type="standard">HTML</annotation></annotation></phrase> is slight. The link element is <code>&lt;xref&gt;</code> rather than <code>&lt;a&gt;</code>. But the meaning of <code>&lt;xref&gt;</code> is bit more general. The HTML <code>&lt;a&gt;</code> element says, “create a hypertext link to this address.” The DITA <code>&lt;xref&gt;</code> element says, “create some sort of reference to this resource.” (As you will see in a moment, DITA is capable of linking to things other than HTML pages, which is why it requires the <code>format</code> attribute to specify that in this case the target is an HTML page.) This gives you a little more leeway in processing. From this markup, you can create usable print output that looks like this:</p>
<blockquote>
<p>In Rio Bravo, the Duke (see: https://en.wikipedia.org/wiki/John_Wayne) plays an ex-Union colonel out for revenge.</p>
</blockquote>
<p>This is not the way you would handle the subject affinity if you were designing for paper, but it is a definite improvement from a <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> point of view. At least the link is now visible to readers.<citation idref="2"/></p>
<footnote id="2">
<p>Technically you could do this from the HTML markup as well, but that would be cheating. The HTML markup doesn’t really give you permission to do this. It says create a hypertext link and nothing else. The problem with cheating is that you are basing your algorithm on constraints that are not promised or enforced, and this can fail in ways you may not expect or catch. Some cheats are more reliable than others, but you probably don’t want to get into the habit. It’s better to create content in a format that doesn’t require cheating to get the output you want.</p>
</footnote>
<p>Fundamentally, though, this is not a satisfactory <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> solution. Unless there is no alternative (such as when you are citing a specific source), you would not normally direct someone reading paper to the web or vice versa. Linking to an already published file, such as an HTML page, means linking to the address where the published file resides. It commits you to a particular format for the link target. If, instead of linking to the published address, you link to the address of the unpublished source file, or to an identifier for that file, you gain the freedom to link to any format of that content that you choose to publish.</p>
<p>In DITA, you can link to another DITA file (this is the default format, so you don’t need to use the <code>format</code> attribute):</p>
<codeblock language="html">
&lt;p&gt;In Rio Bravo, &lt;xref href="John_Wayne.dita"&gt;The Duke&lt;/xref&gt; 
plays an ex-Union colonel out for revenge.&lt;/p&gt;
</codeblock>
<p>You don’t yet know if that content will be published to paper or the web, what the address of the published topic will be, or if that topic will stand alone or be assembled into a larger page or document for publication. This means that the publishing system is taking on responsibility for both ends of the link. It has to make sure that the target page is published in a way the source page can link to and that the source page links to the right address. But transferring this responsibility to an algorithm gives you the leeway to publish this link as you see fit.</p>
<p>If you publish as a printed book and the target resource ends up as part of a chapter in that book, you can render the <code>xref</code> as a cross reference to the page that resource appears on. And you can format that cross reference in line or as a footnote. These are all legitimate interpretations of the <code>xref</code>’s instruction to create a reference to a resource.</p>
<p>If you publish to a help system and the target resource ends up as a topic in the same help system, you could render the <code>xref</code> as a hypertext link to that topic.</p>
<p>This is a big step forward, but it still does not let you do this:</p>
<blockquote>
<p>In Rio Bravo, the Duke (John Wayne) plays an ex-Union colonel out for revenge.</p>
</blockquote>
<p>In other words, you can render the <code>xref</code> as a cross reference, a link, or a footnote, but you can only handle the subject affinity as a reference to that specific resource. You can’t decide to link to a different resource or render it as a sidebar instead. If you want those capabilities, you need to turn to the <phrase><annotation type="concept">management domain</annotation></phrase>.</p>
</section>
<section>
<title>Subject affinities in the management domain</title>

<p>Linking to a source file rather than to an address gives you more latitude about how the link or cross reference is published, but you are still linking to the same resource. If you are doing <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase>, this is a problem, because you do not know if the same resource will be available everywhere you reuse your topic. You need to be able to link to different resources when your topic is used in different places.</p>
<p>To accommodate this, you can factor out the file name and replace it with an ID or a key. IDs and keys are <phrase><annotation type="concept" specifically="management domain">management-domain</annotation></phrase> structures that I discussed in <citation nameref="chapter.reuse"/>. They allow you to refer to resources indirectly. Using IDs lets you use an abstract identifier rather than a file name to identify a resource. Using keys lets you remap the resources you point to, which is a more efficient way to address this problem. So instead of referring to a specific resource on John Wayne, you refer to the key <code>John_Wayne</code>. In DITA this would look like the following:</p>
<codeblock language="DITA">
&lt;p&gt;In Rio Bravo, &lt;xref keyref="John_Wayne"&gt;The Duke&lt;/xref&gt; 
plays an ex-Union colonel out for revenge.&lt;/p&gt;
</codeblock>
<p>Somewhere in the <phrase><annotation type="concept">DITA map</annotation></phrase> for each publication, the key <code>John_Wayne</code> points to a topic. Publications link the <code>keyref</code> to the resource pointed to by that key in each of their DITA maps. This allows you to link to different resources in each publication.</p>
</section>
<section>
<title>The problem with IDs and keys</title>

<p>However, there is still a problem with linking based on IDs and keys. Keys let you vary which resource a <code>keyref</code> resolves to, but what happens when the resource doesn’t exist? The <code>xref</code> demands that a reference to a resource be created, but there is no resource to link to. You have a broken link and fixing it is not easy. You can’t simply go in and remove the <code>xref</code> from the source for one publication, because it defeats the purpose of <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> if you have to edit the content every time you reuse it. Removing the key reference would fix the broken link in one publication, but that would result in the link being removed from all publications, even where the resource does exist and the link ought to be created.</p>
</section>
<section>
<title>Relationship tables</title>

<index>
<record>
<type>concept</type>
<term>relationship tables</term>
</record>
</index>
<p>One solution to this problem is to use a relationship table. In a conventional linking approach, the source page contains an embedded link that points to the target page. The source knows it is pointing to the target, but the target does not know it is being pointed to (see <citation idref="fig.linking-simplelink"/>).</p>
<figure id="fig.linking-simplelink">
<title>A simple link</title>

<insert item="../graphics/simplelink.xml" type="image"/>
</figure>
<p>Because the target resource does not know it is being pointed to, it does not have to do anything in order for other resources to point to it. This is fundamental to the rapid growth of the web. If the target resource had to participate in the link process, every link would require negotiation between page owners, and the owner of the target resource would have to edit that resource to accept the link. It would have been impossible for the web to grow as explosively and organically as it has under those conditions.</p>
<p>A relationship table takes this one step further. When you create a link using a relationship table, you factor the link out of the source document and place it in a separate table. The relationship table in <citation idref="fig.linking-linktable"/> says resource A links to resource B, but neither resource A nor resource B knows anything about it.</p>
<figure id="fig.linking-linktable">
<title>A relationship table</title>

<insert item="../graphics/linktable.xml" type="image"/>
</figure>
<p>Once the links are factored out of a piece of content, you can reuse it anywhere you like. If there is a suitable resource available to link to, you enter it in a relationship table for that build and have the presentation algorithm create the link at build time. If no suitable resource is available for a different publication, no entry is made in the relationship table for that publication, and the presentation algorithm does not create a link.</p>
</section>
<section>
<title>The problem with relationship tables</title>

<index>
<record>
<type>concept</type>
<term>relationship tables, problems with</term>
</record>
</index>
<p>The problem with relationship tables is that they separate the link from the subject affinity it supports. The link was created to serve a subject affinity in the content – a point where readers might encounter something they don’t understand or might need more information – but the relationship table does not record the subject affinity, it simply says that there is some connection between topic A and topic B. And it does not say where in topic A the subject affinity is located. Therefore, there is no way to insert a link at the point where the subject affinity occurs. Links generated by relationship tables end up in a block, usually at the end of the page.<citation idref="3"/></p>
<footnote id="3">
<p>It is not impossible to imagine a markup system in which you could markup the source of the subject affinity in topic A and then have the relationship table reference that point by ID, thus allowing you to insert a link at the subject affinity. But this would be cumbersome for writers, and it would complicate the management task. I don’t know of any systems that work this way.</p>
</footnote>
<p>The fundamental problem here is that links exist as a way to service subject affinities in content. If we lose sight of this and think only in terms of managing links between resources, it makes sense to pull links out of the content and manage them separately. However, this ignores the reason links exist in the first place, which is to provide readers with support at a point of subject affinity. Using relationship tables is a classic case of partitioning that focuses on one part of the problem without adequate regard for the complexity that is being redirected. Moving the link away from the subject affinity simplifies link management but makes it harder for readers to find supporting information – a classic case of sacrificing rhetoric in the name of process efficiency.</p>
<p>The other problem with the relationship table approach is that it is time consuming. You have to rewrite the links for each content set, and because the <phrase><annotation type="concept">subject affinities</annotation></phrase> are not recorded in the content source, you have to figure out the appropriate links each time. This goes against the spirit of recording something once and using it many times. A mechanism intended to help you reuse content ends up forcing you to rework links for each publication you create. In other words, this mechanism does not partition the complexity of link management very well.</p>
</section>
<section>
<title>Conditional linking</title>

<index>
<record>
<type>concept</type>
<term>linking, conditional</term>
</record>
</index>
<p>Before leaving the management domain, it is worth mentioning a management-domain approach that could address the differential single sourcing problem and handle subject affinities for both online and print publishing. This approach uses conditional structures to include content for both options in the source file. With a <phrase><annotation type="concept" specifically="DITA specialization">specialization</annotation></phrase> to support <code>media</code> as a conditional attribute, you could do this in DITA as shown in <citation idref="fig.linking-dita"/>..</p>
<figure id="fig.linking-dita">
<title>Conditional linking in DITA</title>

<codeblock language="DITA">
&lt;p&gt;In Rio Bravo,
&lt;ph media="online"&gt;&lt;xref keyref="John_Wayne"&gt;The Duke&lt;/xref&gt;&lt;/ph&gt;
&lt;ph media="print"&gt;The Duke (John Wayne)&lt;/ph&gt;
plays an ex-Union colonel out for revenge.&lt;/p&gt;
</codeblock>
</figure>
<p>In <citation idref="fig.linking-dita"/>, the DITA <code>&lt;ph&gt;</code> element delineates a phrase in the content that you want to apply management-domain attributes to. There are two versions of the phrase “the Duke,” one for print that uses a parenthetical expression and one for online that uses a link. The <code>media</code> attribute identifies the version. The <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> chooses the appropriate version of the phrase for each publication based on the conditions set for the build.</p>
<p>There are obvious problems with this approach. It doubles the writer’s job and it doubles the cost of maintenance. This approach also flies in the face of creating formatting-independent content.</p>
<p>Unfortunately, in a general purpose <phrase><annotation type="concept">document-domain</annotation></phrase> markup language with <phrase><annotation type="concept" specifically="management domain">management-domain</annotation></phrase> support, it is nearly impossible to support differential single sourcing and content reuse without forcing  writers to do things like this. And, in practice, writers do end up using conditional markup like this, which can lead to tangles of conditions that are hard to maintain and debug.</p>
<p>The <phrase><annotation type="concept" specifically="management domain">management-domain</annotation></phrase> approach does a poor job of partitioning the complexity of links and handling subject affinities:</p>
<ul>
<li>
<p>Management-domain link structures are artificial. They don’t correspond to things in the writer’s everyday world, which makes them harder to learn and use. They introduce complexity into the writer’s world, which leads writers to severely limit the links they create.</p>
</li>
<li>
<p>You can’t link to a key or an ID that does not exist. This means that as you develop a set of content, the first pages have few other pages to link to. You cannot enter links to content that has not been written yet. This introduces the complexity of system dependencies into the writer’s world.</p>
</li>
<li>
<p>In <phrase><annotation type="algorithm">reuse</annotation></phrase> scenarios, the use of <phrase><annotation type="structure">IDs</annotation></phrase> and <phrase><annotation type="structure">keys</annotation></phrase> does not solve the whole problem because you cannot guarantee that the resource that an ID or key refers to will be present in the final publication. You can use relationship tables to address this problem, but they create additional complexity for writers and don’t correctly handle subject affinities in the middle of the content.</p>
</li>
<li>
<p>Unless you resort to ugly conditional structures, you can’t use differential single sourcing to handle subject affinities differently for different media.</p>
</li>
</ul>
</section>
<section>
<title>Subject affinities in the subject domain</title>

<p>As described in <citation nameref="chapter.reuse"/>, you can often eliminate the need for management-domain structures by moving content to the <phrase><annotation type="concept">subject domain</annotation></phrase>. The same is true with subject affinities. In the subject domain, you can mark up subject affinities as subject affinities. This means that you can move away from managing links and manage subject affinities instead. <citation idref="fig.linking-duke-xml"/> and <citation idref="fig.linking-duke-sam"/> show what this looks like in <phrase><annotation type="markup-language"><annotation type="standard">XML</annotation></annotation></phrase> and <phrase><annotation type="markup-language">SAM</annotation></phrase>.</p>
<figure id="fig.linking-duke-xml">
<title>Subject-domain subject affinity markup in XML</title>

<codeblock language="xml">
&lt;p&gt;In &lt;movie&gt;Rio Bravo&lt;/movie&gt;, 
&lt;actor name="John Wayne"&gt;the Duke&lt;/actor&gt; 
plays an ex-Union colonel out for revenge.&lt;/p&gt;
</codeblock>
</figure>
<figure id="fig.linking-duke-sam">
<title>Subject-domain subject affinity markup in SAM</title>

<codeblock language="sam">
In {Rio Bravo}(movie), 
{the Duke}(actor "John Wayne") 
plays an ex-Union colonel out for revenge.
</codeblock>
</figure>
<p>This markup clarifies that “the Duke” (a subject affinity) refers to the actor John Wayne (its subject). It specifies both the type of the subject (actor) and its value (John Wayne).</p>
<p>This is <phrase><annotation type="structure">subject annotation</annotation></phrase>, not link markup. Unlike <phrase><annotation type="concept">document-domain</annotation></phrase> <code>xref</code> markup, it does not insist that a reference should be created nor does it specify any resource to link to. Instead, it simply states what the subject of the text is. Specifically, it clarifies that the phrase “the Duke” refers to the actor named John Wayne (and not the Duke of Wellington or the Duke of Earl) and that the phrase “Rio Bravo” refers to the movie (and not the city in Texas or the nature reserve in Belize).</p>
<p>Given this markup, you can easily render the subject affinity in a manner that works for print by having the <phrase><annotation type="concept">presentation algorithm</annotation></phrase> take the value of the <code>specifically</code> attribute (as this annotation is called in <phrase><annotation type="markup-language">SAM</annotation></phrase>) and output it between parentheses, as shown in <citation idref="fig.linking-duke-html"/>.</p>
<figure id="fig.linking-duke-html">
<title>Subject affinity rendered for print</title>

<codeblock language="html">
&lt;p&gt;In Rio Bravo, The Duke (John Wayne) plays an 
ex-Union colonel out for revenge.&lt;/p&gt;
</codeblock>
</figure>
<p>Marking up a phrase as a subject affinity does not oblige the publishing algorithm to create a link. If you decide to have the publishing algorithm create a link on the web and a cross reference on paper, nothing in the markup obliges you to use any particular formatting or target any particular resource. I’ll describe how to create a link from a subject annotation later in this chapter.</p>
<p>In all the previous examples, mentions of <phrase><annotation type="italic">Rio Bravo</annotation></phrase> were not marked up, even though the names of movies are clearly subject affinities in a movie review. This reflects the writer’s decision not to create a link to support this subject affinity. But what if you want to make a different choice later? By marking up <phrase><annotation type="italic">Rio Bravo</annotation></phrase> with a subject annotation, you keep your options open by transferring the information needed to make the decision to a different partition. You can tell the <phrase><annotation type="concept">presentation algorithm</annotation></phrase> to create links on the names of movies if you want to, but you don’t have to.</p>
<p>There are additional reasons to annotate <phrase><annotation type="italic">Rio Bravo</annotation></phrase> as a subject, because that annotation can be used for other purposes as well.</p>
<ul>
<li>
<p>The subject annotation says that <phrase><annotation type="italic">Rio Bravo</annotation></phrase> is the title of a movie. In the media domain, the titles of movies are commonly printed in italics. You can use the <phrase><annotation type="concept">subject-domain</annotation></phrase> <code>movie</code> tags to generate <phrase><annotation type="concept" specifically="media domain">media-domain</annotation></phrase> italic styling.</p>
</li>
<li>
<p>You could use this subject annotation to generate <phrase><annotation type="concept">document-domain</annotation></phrase> index markers, so you can automatically build an index of all mentions of movies in a work.</p>
</li>
</ul>
<p>Subject annotation thus serves multiple purposes and, correspondingly, reduces the amount of markup required to support all these publishing functions. This is an important characteristic of subject-domain markup. Because subject-domain markup is not directly tied to specific document-domain or media-domain structures, you can generate multiple document-domain and media-domain structures from the same subject-domain markup.</p>
<figure id="fig.linking-docbook">
<title>DocBook markup generated from subject-domain markup</title>

<codeblock language="DocBook">
&lt;para&gt;
    In 
    &lt;indexterm&gt;
       &lt;primary&gt;Rio Bravo&lt;/primary&gt;
       &lt;secondary&gt;Movies&lt;/secondary&gt;
    &lt;/indexterm&gt;
    &lt;citetitle pubwork="movie"&gt;Rio Bravo&lt;/citetitle&gt;,
    &lt;indexterm&gt;
        &lt;primary&gt;John Wayne&lt;/primary&gt;
        &lt;secondary&gt;Actors&lt;/secondary&gt;
    &lt;/indexterm&gt;
    &lt;ulink url="https://en.wikipedia.org/wiki/John_Wayne"&gt;
        The Duke
    &lt;/ulink&gt;
    plays an ex-Union colonel out for revenge.
&lt;/para&gt;                
</codeblock>
</figure>
<p>For example, you could generate the DocBook document-domain markup shown in <citation idref="fig.linking-docbook"/> from subject-domain markup. <citation idref="fig.linking-docbook"/> contains index markers, movie title formatting, and links on the actor’s name, all generated from subject annotations. It should be clear how much less work it takes to create the <phrase><annotation type="concept">subject-domain</annotation></phrase> version of this content than the <phrase><annotation type="markup-language"><annotation type="standard">DocBook</annotation></annotation></phrase> version, how many fewer decisions writers have to make, and how much less knowledge and skill they have to possess. Yet the same publishing capabilities are supported by both versions.</p>
<p>Generating links from subject annotations has a number of other advantages:</p>
<ul>
<li>
<p>In a <phrase><annotation type="algorithm">reuse</annotation></phrase> scenario, you never have to worry about broken links or creating relationship tables. The <phrase><annotation type="concept">presentation algorithm</annotation></phrase> generates appropriate links to whatever topics are available.</p>
</li>
<li>
<p>In a <phrase><annotation type="concept">differential single sourcing</annotation></phrase> scenario, you are never tied to one mechanism for handling the subject affinity. You can generate any mechanism you like in whatever media you like.</p>
</li>
<li>
<p>You don’t have to worry about maintaining links in your content because your source content does not contain any links. The subject annotations in your content are objective statements about your subject matter, so they don’t change. All the links in the published content are generated by the linking algorithm, so no management is required.</p>
</li>
<li>
<p>Writers can create subject annotations to content that has not been written yet. The subject annotation refers to the subject matter, not a resource. Links to content that is written later will appear once that content becomes available to link to.</p>
</li>
<li>
<p>Writers do not have to find content to link to or manage complex link tables or keys. They just create subject annotations when the text mentions a significant subject. This requires no knowledge of the publishing or content management system. It does not even require knowledge of other resources in the content set. It only requires knowledge of the subject matter, which the writer already has, and the format of subject annotations, which is easy to learn.</p>
</li>
</ul>
</section>
<section>
<title>Finding resources to link to</title>

<p>The <phrase><annotation type="concept">subject-domain</annotation></phrase> approach represents a radically different partitioning of the complexity of linking and handling <phrase><annotation type="concept">subject affinities</annotation></phrase>. Most notably, it partitions and redirects away from writers the responsibility for finding content to link to.</p>
<p>Partitioning always introduces new complexity to replace what has been partitioned out. In this case, the new complexity is the effort required to create <phrase><annotation type="concept">subject-domain</annotation></phrase> annotations. However, this partitioning is particularly effective both because annotating subject affinities requires only knowledge the writer already has and because the same annotation is useful for so many other algorithms. This is one of the best features of the subject domain – its structures can serve multiple algorithms rather than just one, which is, in itself, a highly effective partitioning of complexity.</p>
<p>However, although the responsibility of finding resources to link to has been partitioned away from writers, you still need to consider the people and processes that are now required to locate appropriate resources. They do this by looking up resources based on the subject information (type and value) captured by the subject annotation. For this you need content that is indexed using those types and values (or their semantic equivalents). This means that you need to index your content. If you have a page on John Wayne, you can index it as shown in <citation idref="fig.linking-index"/>.</p>
<figure id="fig.linking-index">
<title>Index information about John Wayne</title>

<codeblock language="sam">
topic: 
    title: Biography of John Wayne
    index:
        type: actor
        value: John Wayne
    body:
        John Wayne was an American actor known for westerns.
</codeblock>
</figure>
<pagination-tweak>
<min-space>1.5in</min-space>
</pagination-tweak>
<p>Now the linking algorithm looks like <citation idref="fig.linking-index-algorithm"/>.</p>
<figure id="fig.linking-index-algorithm">
<title>Linking algorithm for indexed content</title>

<codeblock language="pseudo">
match actor
    $target = find href of topic 
               where type = actor 
               and name = @name
    create xref
        attribute href = $target
        continue        
</codeblock>
</figure>
<p>However, content stored in the subject domain may already be indexed effectively enough by its inherent subject-domain structures. Suppose your content collection includes the subject-domain actor biography shown in <citation idref="fig.linking-content"/>.</p>
<figure id="fig.linking-content">
<title>Subject-domain actor biography for John Wayne</title>

<codeblock language="sam">
actor: 
    name: John Wayne
    bio: 
        John Wayne was an American actor known for westerns.
    filmography:
        film: Rio Bravo
        film: The Shootist        
</codeblock>
</figure>
<p>Here the topic type is actor, and the <code>name</code> field specifies the name of the actor in question. This is all you need to identify this topic as a source of information on the actor John Wayne.</p>
<p>Only minor changes to the linking algorithm are required to use this bio (see <citation idref="fig.linking-index-algorithm-2"/>).</p>
<figure id="fig.linking-index-algorithm-2">
<title>Linking algorithm modified to use biography</title>

<codeblock language="pseudo">
match actor
    $target = find href of actor topic where name = @name
    create xref
        attribute href = $target
        continue        
</codeblock>
</figure>
<p>There is a lot more to how this mechanism works in practice, including what you do about imperfect matches and what happens when the query returns multiple resources. But that goes into the specifics of individual systems, which is more detail than needed for present purposes.</p>
<p>You can also index topics using a <phrase><annotation type="tool">content management system</annotation></phrase>, in which case the linking algorithm would query the CMS to find topics to link to.</p>
<p>A useful feature of this approach is that you can have the <phrase><annotation type="concept">publishing algorithm</annotation></phrase> fall back to creating a link to an external resource if an internal one is not available. If a search of the index of your own content fails, you can search indexes of external content. You can build such an index yourself, but some external sites provide indexes, APIs, or search facilities that you can use to locate appropriate pages to link to.</p>
<p>Of course, building these linking algorithms adds complexity to your content system. The subject domain partitions complexity away from writers and distributes it to <phrase><annotation type="role" specifically="information architect">information architects</annotation></phrase> and <phrase><annotation type="role" specifically="content engineer">content engineers</annotation></phrase>.</p>
</section>
<section>
<title>Different domain, different algorithm</title>

<p>The linking algorithm – or, to be more precise, the subject-affinity handling algorithm – is perhaps the algorithm that most clearly illustrates how moving from one domain to another leads to a significantly different partitioning of complexity. While the purpose of the linking algorithm remains the same, the way it achieves that purpose differs significantly in each domain.</p>
<p>In the <phrase><annotation type="concept">document domain</annotation></phrase>, the data structures tend to have a one-to-one correspondence with their algorithms. As system designers determine they need a particular algorithm, they create structures to support that algorithm. Thus, document-domain languages have separate structures for linking, reuse, indexing, and single sourcing. (Some of these may be <phrase><annotation type="concept" specifically="management domain">management-domain</annotation></phrase> structures, of course.)</p>
<p>In the <phrase><annotation type="concept">subject domain</annotation></phrase>, however, the data structures reflect the subject matter. You won’t find a one-to-one correspondence between a structure and the algorithm it supports. Thus, you will not find markup for links, <phrase><annotation type="algorithm">reuse</annotation></phrase>, indexing, or <phrase><annotation type="algorithm">single sourcing</annotation></phrase> in the subject domain. You will find subject annotations that clarify and delineate the subject matter of the content. Any algorithm must interpret <phrase><annotation type="structure">subject annotations</annotation></phrase> and use them as the basis for creating whatever kind of document or <phrase><annotation type="concept" specifically="media domain">media-domain</annotation></phrase> structure you need for publishing.</p>
<p>System designers still must decide which algorithms they need, so they can ensure that the information that drives those algorithms is present in the content. However, since every subject structure can drive many publishing algorithms, you will often find that your <phrase><annotation type="concept">subject-domain</annotation></phrase> content already supports any new algorithm you want to apply. This helps <phrase><annotation type="concept">future proof</annotation></phrase> your content.</p>
<p>Therefore, moving from the <phrase><annotation type="concept">document domain</annotation></phrase> to the <phrase><annotation type="concept">subject domain</annotation></phrase> is not a matter of looking for the <phrase><annotation type="concept">subject-domain</annotation></phrase> equivalent of a document-domain structure. Instead, it’s a matter of asking what information in the <phrase><annotation type="concept">subject domain</annotation></phrase> drives the creation of <phrase><annotation type="concept">document-domain</annotation></phrase> structures. Subject-domain content can look very different from its document-domain counterpart, and it will often be starkly simpler and easier to understand. This represents a better partitioning of complexity. But as noted before, all complexity has to go somewhere, and the use of the subject domain tends to transfer more of the complexity to the <phrase><annotation type="role">information architect</annotation></phrase> or <phrase><annotation type="role">content engineer</annotation></phrase>.</p>
</section>
</chapter>
