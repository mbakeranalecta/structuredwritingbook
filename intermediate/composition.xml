<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.composition">
<title>Composition</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="process">conformance</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforming</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> <phrase><annotation type="process">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<p>A major source of complexity in content reuse comes from the need to write pieces of content that work when combined with other pieces to form a larger work. This is the <phrase><annotation type="italic">composition</annotation></phrase> problem. The composition problem doesn’t occur only in reuse scenarios. It can also occur whenever multiple writers contribute to a single work. In these scenarios, you partition the writing so each piece of content is written only once and is assigned to the person best qualified to write it.</p>
<p>But, as I noted earlier, successful partitioning requires that sufficient information be passed between the partitions so that each can do its own work completely without any complexity being dropped. When you divide an authoring task among many writers, you need to make sure that the individual pieces come together to form a coherent whole. The definition of what constitutes a coherent whole may vary. The criteria for evaluating whether a collection of <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> topics organized as a hypertext is a coherent whole are different from the criteria you would use for a printed product manual designed to be read in linear order. But whatever the criteria, they must be met if you want to distribute authoring to multiple writers or reuse content without allowing elements of complexity to fall through to the reader.</p>
<p>Many traditional writing tools produce files that are meant to encompass a whole work. If you take two <phrase><annotation type="tool">Word</annotation></phrase> files, for example, or two <phrase><annotation type="tool">FrameMaker</annotation></phrase> files and simply join them together, the result is not a document that combines the two files, it is a corrupt file that will not open.</p>
<p>Both <phrase><annotation type="tool">Word</annotation></phrase> and <phrase><annotation type="tool">FrameMaker</annotation></phrase> have features that allow you to compose <phrase><annotation type="tool">Word</annotation></phrase> and FrameMaker documents out of smaller pieces. To a limited extent, they may even allow you to compose documents out of files other than their own. Some systems allow you to compose a document from many different source files. Usually, however, you must do at least some cleanup before you can use the imported files, particularly if they contain <phrase><annotation type="concept">media-domain</annotation></phrase> formatting information. This cleanup requirement usually means that this is a one-time import. You can’t keep editing the original files and have the changes immediately reflected in the importing system.</p>
<p>Therefore, organizations that require a high degree of composability often turn to structured writing to solve the composability problem. Structured writing can help several aspects of the composability problem.</p>
<section>
<title>Combining the pieces</title>
<p>The first requirement of composability is that you must be able to combine the pieces at the file level. Many computer file formats won’t let you make a bigger file just by appending one file to the next or dropping parts of one file into another. They are not designed to work that way. Many let you add material to a file using cut and paste, but as discussed in <citation type = "nameref" value = "chapter.reuse"/>, you should avoid that method. You want an algorithm to do the composition, which means you need a format that lets you put the pieces together without turning the files into mush.</p>
<p>Most structured writing formats consist of a hierarchy of structures. Those structures tend to be self similar in form. For instance, all structures in an XML document are composed of XML elements. This means that you can take an XML document apart at any point in the structural hierarchy and insert, remove, or rearrange the structures at that level. To compose a larger structure out of smaller structures, you simply wrap new elements around them. Thus XML, and many other structured writing formats, provide a level of algorithmic composability often lacking in other formats.</p>
</section>
<section>
<title>Combining structures</title>
<p>The second requirement of composability is that the result of combining markup structures must be a valid document (must conform to the appropriate constraints for that document). The hierarchical nature of XML means that you could take a well-formed chunk of a <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> file and drop in into the middle of a <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> file. The result would be well-formed XML, but it would not be structurally valid <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> or structurally valid <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase>. It would not obey the constraints of either language. You need to do composition in a way that creates a valid document in the target language.</p>
<remark attribution="RLH">
<p>I think you will confuse anyone who doesn’t already understand the distinction between well-formed and valid XML content. I’m not sure you need to explain the concept at all, but if you do, I think it needs to be done more completely.</p>
</remark>
<p>The simplest way to assure this it to plan all of your pieces to fit the constraints of the documents they will be inserted into. The most obvious way to do this it to make sure that all of your pieces come from the same markup language. Thus DITA has good support for structural composability, but only for sources that are themselves DITA.</p>
<p>But belonging to the same markup language is not enough. Markup languages constrain where certain structures can occur and you must also make sure that the pieces go into a place where they are structurally allowed in that language. Just because all the pieces come from the same languages does not mean that every possible combination results in a valid document. Thus you cannot insert a DITA <code>steps</code> structure into a DITA concept or reference topic because <code>steps</code> are not permitted in those topic types. This requires planning and careful management to make sure the combinations you create are valid.</p>
<p>However, it is not essential to composability that all the pieces you want to combine come from the same language as the document you are composing. You can also take content from different sources and with different structures, as long as you can transform their structures on input to match the structures of the destination document. In other words, you can transform as you compose. This can be a very powerful technique. For instance, you can use it to compose documents from content in a database. (Indeed, all database reporting systems are exactly this: systems that compose documents in one format from tabular data in another format.) At the structural level, composability depends on the semantic equivalence of structures, not common syntax.</p>
<p>For this approach to work, however, it is important that all of the sources you draw from have a high level of <phrase><annotation type="process">conformance</annotation></phrase> to their own constraints. If you don’t know, or cannot rely on, the structure of the pieces you are drawing in, you cannot reliably combine them with an algorithm. Thus it is often better to focus on strategies for getting the most reliable sources rather that forcing everyone into a common format that they might not use reliably. For more on this, see <citation type = "nameref" value = "chapter.conformance"/>.</p>
</section>
<section>
<title>Stylistic compatibility</title>
<p>While composability of structures is vital, it is not always sufficient. You could have pieces in a <phrase><annotation type="concept">media-domain</annotation></phrase> language that are structurally compatible but formatted differently. The resulting document would be valid and would publish successfully, but it would be a mess of competing styles and fonts.</p>
<p>For practical purposes, then, you should not try to create composable content in the <phrase><annotation type="concept">media domain</annotation></phrase>. You should at least use the <phrase><annotation type="concept">document domain</annotation></phrase>. The <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="algorithm">separates content from formatting</annotation></phrase> so you can compose a document in the <phrase><annotation type="concept">document domain</annotation></phrase> and then apply consistent formatting to the result.</p>
<p>This is true even if the pieces are in different <phrase><annotation type="concept">document-domain</annotation></phrase> languages. All document-domain languages describe essentially the same set of abstract document structures – document are documents after all, and they all have the same basic features. As long as you can recognize the same basic features in each of the source languages, you can compose a document from pieces in different document-domain languages by converting each piece to a common output language, which does not have to be the same language as any of the pieces you are composing it from. However, be aware that embedded <phrase><annotation type="concept">management-domain</annotation></phrase> markup may spoil the party because there is not the same level of semantic equivalence between management systems. Therefore, you generally should resolve management-domain structures before composition. One exception is if you use management-domain structures to control composition.</p>
</section>
<section>
<title>Narrative flow</title>
<p>Even if you can assemble pieces from different document-domain sources and format them all with a single consistent look, that does not mean that the result will be a complete, correct, coherent narrative. Creating a coherent narrative is not necessarily a matter of making the document sound like it came from a single person. Many business documents are created by several different writers, sometimes working together, sometimes inheriting and maintaining a document over time. Making such a document sound like it was written by one person is a tall order, but doing so is usually not necessary to achieve a desired business purpose.</p>
<p>What does matter is that the document be cohesive and coherent. The <phrase><annotation type="concept">terminology</annotation></phrase> should be consistent from beginning to end. The end should flow logically from the middle and the middle from the beginning. There should be no obvious duplication or omission of content. To achieve this requires constraints on the composition and style of your content.</p>
<p>There are two approaches to narrative composition. One is the <phrase>information-typing</phrase> approach that you find in systems such as <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> or <phrase><annotation type="concept">Information Mapping</annotation></phrase>. In this approach, content is broken down into a set of broad types, such as procedure, process, principle, concept, structure, and fact (Information Mapping) or task, concept, and reference (DITA – though DITA allows you to define other types though specialization). The idea behind the information-typing approach is that if you keep different types of information (for instance, conceptual and reference) in separate chunks, the chunks will compose more reliably, since you won’t duplicate information between chunks of different types. (For more on these mechanisms, see <citation type = "nameref" value = "chapter.heavyweight"/>.)</p>
<p>The difficulty with this approach is that these abstract categories don’t always make a lot of sense to writers when they are writing about concrete subjects, and different writers may interpret the chunk types or their boundaries differently, resulting in material that does not compose as well as you might hope.</p>
<p>Also, this approach, while it has been shown to improve the quality of writing in some cases, can also impose an artificial clunkiness and lack of flow on the content, leaving it choppy or disjointed. Breaking content into separate chunks of different types, after all, is inherently about weakening the narrative threads that bind them together. And if you intend to reuse chunks in several different narratives, you must keep their attachment to any one narrative thread weak.</p>
<p>If you want to impose a specific rhetorical style or structure, any composition must be subject to the same rhetorical constraints as if the piece had been written as a whole. This is often difficult to achieve, not least because it is often difficult for writers to create material that conforms to a rhetorical structure when they can’t see the whole structure.</p>
<p>The other approach to composing coherent narratives is to move content to the <phrase><annotation type="concept">subject domain</annotation></phrase>. A subject-domain structure does not have to be structured as a collection of abstract chunk types. The structure is specific to the subject matter and, therefore, is much more concrete and less susceptible to varying interpretation by writers. Also, you can use the subject domain to factor out many of the style issues that might otherwise compromise composability. (This is similar to factoring out formatting issues by moving from the <phrase><annotation type="concept">media domain</annotation></phrase> to the <phrase><annotation type="concept">document domain</annotation></phrase>.) A narrative can then be composed algorithmically by arranging well-identified pieces of information in a predetermined order, relieving the writer of that task.</p>
<p>Obviously, though, this technique can only work with a limited range of content. Not all material fits into obvious, strongly typed <phrase><annotation type="concept">subject-domain</annotation></phrase> structures. Content that is more conceptual or theoretical in nature does not have a strong <phrase><annotation type="concept">subject-domain</annotation></phrase> structure because it does not approach its subject matter in such a systematic or regular way. Then again, the ability to compose such content out of existing pieces is limited anyway. By its very nature such content requires a continuous flow of exposition that is very hard to assemble from pre-written chunks.</p>
<p>In short, then, composition is a useful technique in certain limited situations, but it cannot be applied across a broad range of content without doing serious damage to content quality. As I have stressed before, fixating on any one algorithm is dangerous. You can always eke out more reuse from a system by pushing composition past the point at which quality can be maintained. But the point is not to drive up your reuse statistics. The point is to ensure that every part of the complexity of the content process is handled by the person or process that has the skills, time, and resources to handle it properly. When it comes to composing effective narratives, the writer, not an algorithm, is often the one who can do the job best.</p>
</section>
</chapter>
