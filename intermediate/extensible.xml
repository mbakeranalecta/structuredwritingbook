<?xml version="1.0" encoding="UTF-8"?>
<chapter name ="chapter.extensible">
<title>Extensible and Constrainable Languages</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="process">conformance</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforming</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> <phrase><annotation type="process">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<index>
<record>
<type>concept</type>
<term>extension</term>
</record>
<record>
<type>concept</type>
<term>constraint</term>
</record>
</index>
<p>The languages we have looked at to this point are publicly specified and have existing tool chains. Some are more constrained than others, and some support different structured writing algorithms and different ways of partitioning and redirecting complexity. Choosing one of them makes sense if the constraints they express and the algorithms they support partition content complexity in a way that is right for your organization. If not, you need to create your own structures to improve how complexity is partitioned and distributed in your organization.</p>
<p>You have three options for doing this:</p>
<ul>
<li>
<p>Create your own language entirely from scratch, creating both the syntax and the semantics. (This is what <phrase><annotation type="person">John Gruber</annotation></phrase> did when he created <phrase><annotation type="language">MarkDown</annotation></phrase>.)</p>
</li>
<li>
<p>Use an existing abstract markup syntax, such as XML or SAM, and create your own semantics by defining named structures using that syntax as described in <citation type = "nameref" value = "chapter.markup"/>.</p>
</li>
<li>
<p>Take an existing markup language with extensible and/or constrainable semantics, such as DITA or DocBook, and extend and/or constrain it to meet your needs.</p>
</li>
</ul>
<p>Each of these approaches has merits and drawbacks. For instance, creating a new language may enable you to achieve exceptional functional lucidity for a particular type of information; extending/constraining an existing language may save you a lot of tool development costs; while defining your own semantics based on an existing syntax may enable you to find the right balance between functional lucidity and development costs.</p>
<p>This chapter looks at extensible and constrainable markup languages.</p>
<section>
<title>XML</title>
<p>The X in <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> stands for eXtensible, but, as noted in <citation type = "nameref" value = "chapter.markup"/>, XML is an abstract language that does not define any document structures itself. Therefore, with XML, you start from zero. Syntactically, everything is defined for you. Semantically you start from scratch.</p>
<p>You can define the structure of a new XML markup language using one of the several available <phrase><annotation type="tool">schema languages</annotation></phrase>. We will look at schema languages in <citation type = "nameref" value = "chapter.constraints"/>, but the mechanics of defining a markup language in XML are out of scope for this book.</p>
</section>
<section>
<title>DITA</title>
<p>DITA is unique among markup languages because it was designed for extension from the beginning. In fact, it is something of a misnomer to call DITA a markup language. DITA actually calls itself an information typing architecture. What is an information typing architecture? DITA is really the only thing that calls itself by this name, so we have to derive the definition from the properties of this one example.</p>
<p>The conventional way to define a document type is using a schema language. Schema languages are simply languages for describing constraints on markup structures. (We will look at them in <citation type = "nameref" value = "chapter.constraints"/>). So what does an information typing architecture provide over and above what a schema language provides?</p>
<p>The programming world provides one useful example. Programming environments use architectures and frameworks to abstract certain types of operations to a higher level. For example, the environment may implement commonly used functions that you could program from scratch, but having those functions available moves complexity from the local developer to the algorithms supplied in the architecture, saving time and possibly avoiding errors. The usefulness of an architecture depends on whether it partitions and distributes the problem space in substantially the same way you would have done it if you were designing the system from scratch. (Of course, you might not have come up with all the good ideas in a good architecture yourself; the point is that once you have been exposed to those ideas and understand them, would you then partition and distribute complexity according to those ideas or not?)</p>
<p>So the question to ask about DITA is, does its architecture partition and distribute content complexity the way that you would naturally wish it to be done to achieve the best outcome for your organization?</p>
<p>The DITA architecture consists of a set of predefined markup languages that you can extend using a mechanism called <phrase><annotation type="concept">specialization</annotation></phrase>, a facility for assembling information products (maps), a facility for managing metadata (subject schema), an extensive set of <phrase><annotation type="concept">management-domain</annotation></phrase> markup, and specifications for the behaviors associated with all of these capabilities.</p>
<p>In other words, it predefines a range of structures, semantics, and operations that you might need in establishing an information architecture and then provides a way for you to build from there.</p>
<p>As with any other architecture, DITA’s usefulness depends on how well the predefined structures, semantics, and operations suit your needs; how easy the extension mechanism is to use; and how reliable the available implementations are.</p>
<p>It is common in the software world for there to be many competing architectures with different sweet spots. Because an architecture is essentially a series of guesses about what a variety of systems may have in common, different architectures may be constructed differently to cover different sets of commonalities among diverse projects, and you may not see equivalent architectural features from one system to another.</p>
<p>There are not a lot of information typing architectures. The only other one I am aware of is the one I am developing myself, which is called <phrase><annotation type="tool">SPFE</annotation></phrase>. <phrase><annotation type="tool">SPFE</annotation></phrase>, however, has a very different architecture from <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>. <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> has grown into a very large and complex architecture over the years, and it is out of scope for this book to describe its architecture in full.<citation type = "idref" value = "1"/> All I shall attempt to do here is to do a basic mapping of some key features of the DITA architecture to the structured writing concepts explored in this book.</p>
<footnote id ="1">
<p>Obviously I am not a fan of the DITA architecture or I would not be developing my own architecture in <phrase><annotation type="tool">SPFE</annotation></phrase>. For a much fuller and more sympathetic treatment of the DITA architecture, see <phrase><annotation type="citetitle">DITA for Practitioners Volume 1: Architecture and Technology</annotation></phrase> by Elliot Kimber, <phrase><annotation type="url">http://xmlpress.net/publications/dita/practitioners-1/</annotation></phrase></p>
</footnote>
<p>Inherent in the process of constructing an architecture is that you partition the field in certain ways. Architectures move functionality to a higher level by choosing some options and rejecting others. An XML schema is an information typing language that can define a markup language for any purpose at all. However, some applications of XML, such as recording transfers between banks or storing the configuration options of an editor, are not within the scope of the information typing that the DITA architecture was designed for. Therefore, DITA has a more restricted definition of information typing. The DITA specification defines information typing this way:</p>
<blockquote>
<citation type = "citation" value = "http://docs.oasis-open.org/dita/dita/v1.3/csd01/part3-all-inclusive/archSpec/base/information-typing.html"/><p>Information typing is the practice of identifying types of topics, such as concept, reference, and task, to clearly distinguish between different types of information.</p>
</blockquote>
<p>Unfortunately this definition is largely circular – information typing defines information types. But it does help establish a scale. Information typing is about defining topic types. The spec goes on to define the purpose of information typing:</p>
<blockquote>
<p>Information typing is a practice designed to keep documentation focused and modular, thus making it clearer to readers, easier to search and navigate, and more suitable for reuse.</p>
</blockquote>
<p>DITA information typing is not as general as structured writing. It focuses on information at a particular scale and on a subset of the structured writing algorithms. That does not make it impossible to work at other scales or implement other algorithms, it just means that the archicture provides better support for certain areas.</p>
<p>Out-of-the-box DITA is commonly associated with the idea that there are just three information types, task, concept, and reference. The DITA spec makes it clear that this is not the intention of DITA as an information typing architecture.</p>
<blockquote>
<p>DITA currently defines a small set of well-established information types that reflects common practices in certain business domains, for example, technical communication and instruction and assessment. However, the set of possible information types is unbounded. Through the mechanism of specialization, new information types can be defined as specializations of the base topic type (&lt;topic&gt;) or as refinements of existing topics types, for example, &lt;concept&gt;, &lt;task&gt;, &lt;reference&gt;, or &lt;learningContent&gt;.</p>
</blockquote>
<p>As I have noted, many structured writing algorithms partition complexity best with more specific markup, particularly markup in the subject domain. The ability to create an unbounded set of information types is thereforei relevant to getting the most out of structured writing.</p>
<p>Clearly, though, one does not need an information typing architecture to define an information type. You can, as <phrase><annotation type="person">John Gruber</annotation></phrase> did with <phrase><annotation type="language">MarkDown</annotation></phrase>, sit down and sketch out a set of structures and a syntax to represent them, and then write a program to process them. With an <phrase><annotation type="concept">abstract language</annotation></phrase> like <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> or <phrase><annotation type="language">SAM</annotation></phrase>, you can create a new information type by defining a set of named elements and attributes using a schema language. How does using a higher level information typing architecture like DITA change this process? How does it partition the design problem differently?</p>
<p>First and foremost, it means that you don’t start from scratch. All topic types in DITA are derived from a base topic type called <code>topic</code> through specialization.</p>
<p>What is specialization? XML syntax defines abstract structures that do not occur in documents: elements, attributes, etc. To create a markup language in XML, you define named elements and attributes for the structures you are creating. This is a type of specialization. For example, in <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <code>para</code> is a type of element. <code>para</code> has what is called an “is-a” relationship to elements: <code>para</code> “is-an” element, but it is a special type of element. An XML parser will process a <code>para</code> generically as an element, reporting its name to the application layer. The application layer must then supply a rule that processes just this specialized <code>para</code> element (and not the also specialized but different <code>title</code> element).</p>
<p>DITA specialization follows the same principle, but moves it up a level. The base <code>topic</code> topic type is the abstract structure. More specific types like <code>knitting-pattern</code> or <code>ingredients-list</code> are specializations of <code>topic</code> (or of other topic types that are specializations of <code>topic</code>). A generic DITA processor can process them as a instance of <code>topic</code>, but it requires additional code to process them specifically as <code>knitting-pattern</code> or <code>ingredient-list</code>. Each of these specialized types has an “is-a” relationship with the type it was specialized from. So <code>knitting-pattern</code> “is-a” topic.</p>
<p>DITA specialization differs from simply creating new named elements in XML in that the base DITA topic type is not an abstraction like an XML element. You cannot create an XML element without inventing a name for it. The base DITA topic type, on the other hand, is a fully implemented topic type that you can use directly. You can, and people do, write directly in the base topic type without inventing anything new. We noted in <citation type = "nameref" value = "chapter.rhetorical_structure"/> that it is sometimes easy to treat what is intended as a meta model as a generic model. This is the case here. All topic types in DITA are derived by specialization from the generic <code>topic</code> type. They all have an “is-a” relationship to this generic type.</p>
<p>One consequence of this is that a processor can process a specialized element as though it were the base element without failure. The result may not reflect all aspects of the specialized element, but the processing will not fail. This is an attractive quality because it is often easier to modify an existing piece of code than it is to write new code from scratch, particularly if most of the rules in the base code can remain unchanged.</p>
<p>To specialize a topic type, you specialize the root element and any child elements or attributes that you need to define your new topic type. Each specialized element or attribute should have an is-a relationship to the element it specializes. Thus a procedure element might be a specialization of an ordered list element and its step elements might be specializations of a list item element. In this case, processing a procedure as an ordered list would produce meaningful output, which is what you would expect. However, you would probably want to specialize the output of steps in a procedure, perhaps by prefixing each step with “Step 1:" rather than just “1.” This would probably be less code to write than writing a procedure processing algorithms from scratch.</p>
<p>The second way in which specialization differs from giving names to abstract elements is that specialization is recursive. That is, suppose you have a topic type <code>animal-description</code>, which is a specialization of <code>topic</code>. You want to impose additional constraints on the description of different types of animal, so you create more specialized types <code>fish-description</code> and <code>mammal-description</code>, which are specializations of <code>animal-description</code> (and could be processed like an <code>animal-description</code> if no other processing were specified for them). Then you might decide to impose still more constraints on the description of different kinds of mammals, so you create the type <code>horse-description</code>, which is a specialization of <code>mammal-description</code>. This type would be processed as a <code>mammal-description</code> if no specific processing is provided for <code>horse-description</code>; as <code>animal-description</code> if no specific <code>mammal-description</code> processing is provided; and as <code>topic</code> if no specific <code>animal-description</code> processing is provided.</p>
<p>The third way in which information typing in DITA differs from creating a language from scratch is that DITA information types share a common approach to processing and to information architecture. In particular, they inherit a common set of <phrase><annotation type="concept">management-domain</annotation></phrase> structures and their associated management semantics.</p>
<p>A DITA topic, then, comes with a lot of build in functionality and structure that you don’t have to invent for yourself when you create a specialized version of that topic type. But the corollary is that not all content types are specialized instances of a DITA generic topic, nor are all the structures they contain instances of generic document domain structures.</p>
<p>When we factored the ingredients of a recipe out of a <phrase><annotation type="concept">document domain</annotation></phrase> list into a <phrase><annotation type="concept">subject domain</annotation></phrase> record structure it was, in part, to make them independent of the decision of to format them as a <phrase><annotation type="structure">table</annotation></phrase> as a <phrase><annotation type="structure">list</annotation></phrase>.</p>
<codeblock language ="sam">
ingredients:: ingredient, quantity, unit
    eggs, 3, each
    salt, 1, tsp
    butter, .5, cup 
</codeblock>
<p>The ingredient record set no longer has an is-a relationship to a <phrase><annotation type="structure">table</annotation></phrase> or a <phrase><annotation type="structure">list</annotation></phrase>. The whole point was to break that relationship so that we could present that content any way we wanted to.</p>
<p>Labels are a big part of document domain content. When we created a subject domain structure for recording the nutritional information for a recipe, we factor out all of the labels by putting the content in named fields. In other words, the labels went from being data (in the content) to <phrase><annotation type="concept">metadata</annotation></phrase> (part of the structure):</p>
<codeblock language ="sam">
nutrition:
    serving: 1 large (50 g)
    calories: 78
    total-fat: 5 g
    saturated-fat: 0.7 g
    polyunsaturated-fat: 0.7 g    
    monounsaturated-fat: 2 g    
    cholesterol: 186.5 mg    
    sodium: 62 mg    
    potassium: 63 mg    
    total-carbohydrate: 0.6 g    
    dietary-fiber: 0 g    
    sugar: 0.6 g    
    protein: 6 g    
</codeblock>
<p>Though this structure looks superficially like a list, it is really a data record. If this structure were created as a specialization of a list and then published using a generic list publishing algorithm, the result would be:</p>
<blockquote>
<ul>
<li>
<p>1 large (50 g)</p>
</li>
<li>
<p>78</p>
</li>
<li>
<p>5 g</p>
</li>
<li>
<p>0.7 g</p>
</li>
<li>
<p>0.7 g</p>
</li>
<li>
<p>2 g</p>
</li>
<li>
<p>186.5 mg</p>
</li>
<li>
<p>62 mg</p>
</li>
<li>
<p>63 mg</p>
</li>
<li>
<p>0.6 g</p>
</li>
<li>
<p>0 g</p>
</li>
<li>
<p>0.6 g</p>
</li>
<li>
<p>6 g</p>
</li>
</ul>
</blockquote>
<p>In short, there is no “is-a” relationship between generic <phrase><annotation type="concept">document domain</annotation></phrase> structure and the structures of the <phrase><annotation type="concept">subject domain</annotation></phrase>.</p>
<p>Does this mean that you cannot create a <phrase><annotation type="concept">subject domain</annotation></phrase> structure using DITA’s <phrase><annotation type="concept">specialization</annotation></phrase> mechanism? No, you can usually create the structure you want, but it won’t be an actual <phrase><annotation type="concept">specialization</annotation></phrase> of its base type. By the very fact that it is a <phrase><annotation type="concept">subject domain</annotation></phrase> structure it has broken the “is-a” relationship with the <phrase><annotation type="concept">document domain</annotation></phrase>. As I noted at the end of <citation type = "nameref" value = "chapter.linking"/>, it is characteristic of the <phrase><annotation type="concept">subject domain</annotation></phrase> that its algorithms work completely different from those of the <phrase><annotation type="concept">document domain</annotation></phrase>, so inheriting some of the processing of a base <phrase><annotation type="concept">document domain</annotation></phrase> structure is moot once you move to the <phrase><annotation type="concept">subject domain</annotation></phrase>. You new <phrase><annotation type="concept">subject domain</annotation></phrase> structure will be a new and essentially unrelated structure for which you will have to create completely new processing algorithms, just as you would if you has started defining your structure from scratch.</p>
<p>Generally, the fewer pieces of an architecture you use, the less value there is to basing your work on that architecture, both because you have more work to do and because you take less advantage of the infrastructure or tools and expertise surrounding that architecture, creating a system that is less understandable to people versed in the architecture. All this betrays a poor fit between the system partitioning you are creating and the partitioning that the architecture provides. All architectures come with overheads and if you don’t use their features, you still have to live with their overhead, which adds cost and complexity to your system. Thus, while you can use DITA and depart from the default DITA way of doing things, the value of using DITA diminishes the further you depart from the DITA way. The same would be true of any other information typing architecture.</p>
</section>
<section>
<title>DocBook</title>
<p><phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> is not really extensible in the same sense as the other languages mentioned here, but it still deserves a mention. DocBook does not provide an extension mechanism like <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>’s specialization. What it does provide is a deliberately modular construction that makes it easy to create new schemas that include elements from DocBook. DocBook takes full advantage of the extensibility features built into XML schema languages.</p>
<p>Does the fact that DocBook does not invent its own extension mechanism means that it is not as extensible as DITA? No. By relying on XML’s own extensibility features, which are both more comprehensive and lower level than DITA’s specialization mechanism, DocBook is as extensible as it is possible for any XML vocabulary to be.</p>
<p>Where it differs from DITA is that there is no fall-back processing.  Extensions DocBook are not DocBook. They are new languages that incorporate DocBook structures. The extensions cannot be processed by standard DocBook tool chains, though the incorporated DocBook structures obviously can. DITA’s specialization mechanism means that a specialized topic will always pass through the DITA publication process, though whether it will be presented in a useful or comprehensible way very much depends on how well the is-a relationship between specialization and base was maintained. If you would rather ensure that topics always pass through the publication process, even if the results are gibberish, DITA will support that. If you want to ensure that errors are raised if any structure is not recognized by the publishing tool chain (thus avoiding accidental gibberish) then DocBook’s extension mechanism will give you that.</p>
<p>Another aspect of DocBook customization deserves to be mentioned here even though it is not strictly speaking extension. DocBook has a huge tag set and it is quite conceivable that if you want a small constrained document domain markup languages that you can create one by sub-setting DocBook. DocBook provides for just about every document structure out there, so if you are building a document domain language, chances are the pieces you need are in there.</p>
<p>The great advantage of creating a new language as a subset of DocBook is that the result is also a valid DocBook document and can therefore be published by the DocBook tool chain. You will not have to write any algorithms at all if you take this approach. Creating a subset of DocBook can therefore allow you to impose more constraints and improve <phrase><annotation type="concept">functional lucidity</annotation></phrase> significantly compared to standard DocBook without having to write any processing code at all.</p>
<p>Technically speaking, any XML-based markup language is extensible in the same way that DocBook is. However, DocBook’s structure, and the implementation of its schemas, was designed deliberately to support both extension and sub-setting of DocBook, something which is not true for many markup languages.</p>
</section>
<section>
<title>RestructuredText</title>
<p>RestructuredText has a number of blocks for things like paragraphs, titles, and lists that are defined with a concrete syntax. It defines other blocks using directives:</p>
<codeblock language ="reStructuredText">
.. image:: images/biohazard.png
   :height: 100
   :width: 200
   :scale: 50
   :alt: alternate text
</codeblock>
<p>It is extensible by adding new directives to the language. However, there is no schema language for RestructuredText. To create a new directive, you have to create the code that processes it.</p>
<p>There is an important distinction to be made between languages that are extensible by schema and those that are extensible by writing code to process the extension. If a language is extended by writing processing code for the extension, the only way to know if the input is valid is by processing it. If it raises a processing error, it is invalid.</p>
<p>If you have only one processor for a language, you can treat that processor as normative. That is, the definition of a correct file is any file that can be successfully processed by the normative processor. The language, in other words, is defined by the processor. But if you have multiple processors, how do you determine who is at fault when of of those processor fails to process a given input file? Is the processor incorrect or the source file?</p>
<p>A schema creates a language definition that is independent of any processor. (In other words, it partitions and redirects the complexity of validation in language design.) It is the schema that is normative, not any of the processors. If the source file is valid per the schema, the processor is at fault if it does not process that file correctly. If the source file is not valid per the schema, the blame lies with the source file.</p>
<p>In the case of RestructuredText, the capacity of the processor to be extended in this way is built into the processor architecture. It is not like you have to hack around in the code to add your extensions. There is a specific and well documented way to do it. But while RestructuredText allows you to extend it by adding new directives, it does not have a constraint mechanism. There is no mechanism (other than by hacking into the code) to restrict the use either of new directives or the existing directives and structures.</p>
</section>
<section>
<title>TeX</title>
<p>TeX (pronounced “Tek”) is a typesetting system invented by Donald Knuth in 1978. As a typesetting language it is a concrete <phrase><annotation type="concept">media domain</annotation></phrase> language. But Knuth also included a macro language in TeX which allows users to define new commands in terms of existing commands. (I say commands because that is the term used in TeX. Markup in the media domain tends to be much more imperative than markup in the subject domain, which is entirely descriptive, so “commands” is an appropriate name for TeX’s tags.) This macro language has been used to extend TeX, most notably in the form of <phrase><annotation type="language">LaTeX</annotation></phrase>, a <phrase><annotation type="concept">document-domain</annotation></phrase> language that we looked at in <citation type = "nameref" value = "chapter.heavyweight"/>.</p>
<p>As we noted with RestructuredText, extension of a language is not the same thing as constraint. Introducing new commands does not create a constraint mechanism.</p>
</section>
<section>
<title>SAM</title>
<p>While lightweight languages provide great <phrase><annotation type="concept">functional lucidity</annotation></phrase>, they suffer from limited extensibility (which generally requires writing code) and a general lack of constraint mechanisms. I believe that a fully extensible, fully constrainable lightweight markup language would be a valuable addition to the structured writing toolkit. This is why I have developed <phrase><annotation type="language">SAM</annotation></phrase>, the markup language used for most of the examples in this book and for writing the book itself.</p>
<p>As described in <citation type = "nameref" value = "chapter.markup"/>, SAM is a hybrid markup language which combines implicit syntax similar to <phrase><annotation type="language">MarkDown</annotation></phrase> with an explicit syntax for defining abstract structures called blocks, recordsets, and annotations, and with specific concrete markup for common features such as insertions, citations, and variable definitions.</p>
<p>SAM, like <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase>, is for defining specific markup languages. However, all languages defined in SAM share a small common base set of text structures for which SAM provides concrete syntax. This allows SAM to combine lightweight syntax for the most common text structures with the ability to define specific constrained markup languages for particular purposes, particularly <phrase><annotation type="concept">subject domain</annotation></phrase> languages. In other words, SAM represents a different partitioning of the markup design process from both the common lightweight languages and from XML.</p>
<p>SAM is designed to be extensible and constrainable through a schema language (this is not complete at time of writing, but hopefully will be available by the time you read this). The intent is that the schema language should be able not only to define and constrain new block structures, but to constrain the use of the concrete structures as well, and to constrain the values of fields using patterns.</p>
<p>SAM is not designed to be nearly as general as XML in its applications. As a result, its syntax is simple and more <phrase><annotation type="concept">functionally lucid</annotation></phrase> and its schema language should also be simpler and make it much easier for writers to develop their own SAM-based markup languages.</p>
<p>I use SAM for the majority of the examples in this book because SAM is designed to make structure clear and that is all I have needed to do in most examples. All the examples could be expressed in XML as well. Using XML would just have made them harder to follow. Naturally, to write in SAM you would need to know more about the rules of the language, but you should be able to read a typical SAM document and understand its structure with little or no instruction.</p>
<p>This is similar, but not identical, to the aim of mainstream concrete and hybrid languages such as <phrase><annotation type="language">Markdown</annotation></phrase> and <phrase><annotation type="language">Restructured Text</annotation></phrase>, which is to have the source file be readable as a document. In other words, they strive to make the document structure clear from the markup. They are document domain languages, and they strive to make sure that the markup expresses the document structure they create in a way that is readable. SAM has the same goal, except that SAM was designed primarily for creating subject domain languages. As such, it is designed to make the subject domain structure of the document clear to the reader.</p>
<p>A SAM document may not look as much like a finished document as a <phrase><annotation type="language">Markdown</annotation></phrase> or <phrase><annotation type="language">reStructuredText</annotation></phrase> document. For example, it does not use underlines to visually denote different levels of header. Instead, it focuses on creating a hierarchy of named blocks and fields. In doing so, it uses the kind of markup people commonly use to create named blocks of text and to express a hierarchical relationship between them. Blocks are introduced with a name followed by a colon, and hierarchy is expressed through indentation.</p>
<codeblock language ="SAM">
examples: Basic SAM structures

    example: Paragraphs
        The is a sample paragraph. It is inside
        the {block}(structure) called `example`.
        It contains two {annotations}(structure),
        including this one. It ends with a blank
        line.

        This is another paragraph.

    example: Lists

        Then there is a list:

        1. First item.
        2. Second item.
        3. Third item.

    example: Block quote

        Next is a block quote with a {citation}(structure).

        """[Mother Goose]
            Humpty Dumpty sat on a wall.
</codeblock>
<p>SAM is an open source project. A description of the language and a set of associated tools are available from <phrase><annotation type="url">https://github.com/mbakeranalecta/sam</annotation></phrase>.</p>
</section>
<section>
<title>SPFE</title>
<p><phrase><annotation type="tool">SPFE</annotation></phrase> is another project of mine. It is designed to be a framework for implementing structured writing algorithms and its structure follows the model I laid out in <citation type = "nameref" value = "chapter.publishing"/>. It is tempting to compare it to <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> as an information typing architecture, but as I commented before, architectures are not necessarily parallel to each other and often differ in their emphasis. SPFE takes a different approach to the partitioning and distribution of content complexity, with a major emphasis on directing content management and information architecture complexity away from writers. Individual writers working in a SPFE system should have to know little or nothing about how SPFE works, as long as they follow the constraints of the markup language they are using.</p>
<p>SPFE is principally designed for <phrase><annotation type="concept">subject domain</annotation></phrase> markup. As such, it does not start with a generic document domain topic type like DITA. SPFE does not require any particular schema, though it does require that schemas meet certain constraints.</p>
<p>But SPFE does not leave it entirely to you to develop schemas from scratch. Instead, it supports building schemas from pre-built components. The pre-built components include a collection of semantic blocks and the default processing code for each stage of the publishing algorithm. SPFE also allows you to define your own reusable structured components with processing code. This is, essentially, extensibility through composition, rather than extensibility through specialization (as in <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>) or extensibility through processor extension (and in <phrase><annotation type="language">reStructuredText</annotation></phrase>). Constraints are supported through normal schema mechanisms and by selecting the minimal required structural components for the individual case.</p>
<p>By strictly segregating the presentation and formatting layers, SPFE reduces the effort required to process custom markup formats. Custom format are processed to a common document-domain markup language which it then processed to all required media-domain output formats. The SPFE Open Tool Kit includes a basic document domain language for this purpose, but you can also use DocBook or DITA in this role, allowing you to take advantage of their existing publishing capabilities. This also allows you to install SPFE as an authoring layer on top of an existing DITA or DocBook tool chain.</p>
<p>To create a subject-domain markup language in SPFE, therefore, all you have to define for yourself are the key subject-domain fields and blocks that are essential to your business. All the other elements you need, such as paragraphs, lists, tables, and common annotations, you can include from the pre-built components, along with their default processing code.</p>
<p>Among its default processing steps, the SPFE process includes the subject-based linking algorithms described in <citation type = "nameref" value = "chapter.linking"/> and the subject-based composition and architecture algorithms described in <citation type = "nameref" value = "chapter.composition"/> and <citation type = "nameref" value = "chapter.architecture"/>, including bottom-up information architecture. The <phrase><annotation type="process">conformance</annotation></phrase> and <phrase><annotation type="algorithm">audit</annotation></phrase> algorithms are well-supported as well.</p>
<p>While it has support for <phrase><annotation type="algorithm">reuse</annotation></phrase>, SPFE is not as focused on content reuse or content management as <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>. It deliberately limits some of the forms of reuse that tend to produce unmanageable complexity. While it can produce books and top-down information architectures, its main focus is hypertext and bottom-up information architectures. SPFE does not define or require maps as an assembly mechanisms, though you could implement maps in SPFE if you wanted them. SPFE’s processing model is modeled on a software build architecture and it is designed to work well with a <phrase><annotation type="tool">version control system</annotation></phrase> system as a repository rather than a content management system. One of its key design objectives is that writers should have to know little or nothing about how SPFE works.</p>
<p>Both <phrase><annotation type="language">SAM</annotation></phrase> and <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> are supported as markup syntax for SPFE, and you can freely mix and match SAM and XML content.</p>
<p>SPFE is an open source project available from <phrase><annotation type="url">http://spfeopentoolkit.org</annotation></phrase>.</p>
</section>
</chapter>
