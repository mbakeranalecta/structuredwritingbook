<?xml version="1.0" encoding="UTF-8"?>
<chapter name="modeling">
<title>Modeling</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">DITA</annotation></phrase> <phrase><annotation type="language">DocBook</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">HTML</annotation></phrase> <phrase><annotation type="language">XML</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm">composition</annotation></phrase> <phrase><annotation type="algorithm">conformance algorithm</annotation></phrase> <phrase><annotation type="algorithm">conformance</annotation></phrase> <phrase><annotation type="algorithm">content management algorithm</annotation></phrase> <phrase><annotation type="algorithm">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract and merge algorithm</annotation></phrase> <phrase><annotation type="algorithm">extract and merge</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">Content management systems</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase></p>
</annotations>
<index>
<title>type, term</title>
<p>algorithm, modeling structure, procedure</p>
</index>
<p>As noted in <citation type="nameref" value="chapter.extract"/> it is possible to extract content from existing data sources. Some of these were not intended as sources of content, but in many cases you can turn them into content by using algorithms to wrap the data into sentences or field values in a document. Such sources essentially present a model of some object in the real world, and when we use them as a source of content, we are creating content from that model.</p>
<p>We can apply the same techniques to creating content even when an external data source does not exist by creating our own model of a real world object using structured writing techniques. We can then extract content from that model just as we would from an external data source. This can be an extremely powerful technique for managing complexity in cases where content frequently traverses the same ground, or in cases where content must express complex relationships that are easier to model and control in a formalized systems.</p>
<p>An entire book could be written about how to model various types of subjects and how to derive content from those models. Here I will confine myself to presenting one simplified model to demonstrate the principle at work and point to some of its key benefits.</p>
<p>In <citation type="nameref" value="chapter.duplication"/> I mentioned that while the sentence “Press OK.” occurs repeatedly in many content sets, it makes little sense to try to factor it out as duplicate text since while the words are identical in many cases, they actually represent different pieces of information about different dialog boxes, any one of which could change independent of the others. However, we can actually go much further than factoring out individual instances of “Press OK” and factor out the entire navigational part of the procedure using a model.</p>
<p>The navigational structure of a typical desktop application is essentially a tree consisting of a well defined set of objects: menus, menu items, dialog boxes, field values, buttons, and assorted other controls. The entire navigation system of an application can thus be modeled as a tree (and indeed, there are languages designed for modeling interfaces in just this way for programming purposes.<citation type="citation" value="https://en.wikipedia.org/wiki/User_interface_modeling"/>). Rather than looking at any of these, however, I will develop a very simple model of a UI just complex enough to demonstrate the technique:</p>
<codeblock language="sam">
application: MyApp
       menu-set:
            menu: File
                menu-item: New
                    dialog-box: New document
                        fields:: name, purpose
                            Name, the name of the new document
                            Type, the type of the new document
                        confirm: Create
                        cancel: Cancel
                        screen-shot:
                            windows: graphics/windows/new.png
                            mac: graphics/mac/new.png
                            linux: grahics/linux/new.png

Most of what is contained in a procedure for using a GUI is entirely formulaic. With a map of the UI like this, we can write an algorithm to follow that formula for all procedures.

Here is how a procedure for using this menu might be written using conventional techniques:

```(sam)
    procedure: Create a new document
        step: From the {File}(menu) menu, select {New}(menu-item). The {New document}(dialog) appears.
            &gt;&gt;&gt;(%image.new_dialog)
        step: Enter the name of the new document into the {Name}(field) field.
        step: Enter the type of the new document into the {Name}(field) field.
        step: Press {Create}(button) or {Cancel}(button) to cancel.

Using the model, however, we can reduce all of this to:

```(sam)
    procedure: Create a new document
        use-dialog: New document 

Every piece of text that is used in the written-out procedure above can be derived from the model by an algorithm. The `use-dialog` field in the second example triggers the use of that algorithm in the {synthesis} stage to generate the full text of the procedure, as well as including the correct version of the screen shot.

Clearly you won't always want to generate the full procedure with a single line. There will be cases where you need to say something specific about  a particular case. For example, if this procedure were part of a tutorial, you might want to specify a particular file name. In this case, you could use the model to generate only part of the procedure:

```(sam)
    procedure: Create a document for testing
        navigate-to: New document
        step: Enter "test.abc" into the {Name}(field) field.
        step: Enter "normal" into the {Name}(field) field.
        confirm: New document

Here the fields `navigate-to` and `confirm` tell an algorithm to generate parts of the procedure from the model (the navigation to the dialog box and the button presses to confirm the action) while allowing the writer to insert custom instructions in the middle.  

Procedures contain huge amounts of repeated text, none of which can be effectively factored out by standard variable substitution techniques. But by creating a model of the interface, we can factor out most of the text of most procedures, leaving it to an algorithm to perform the tedious task of typing out all those instructions over and over again. 

There are a number of potential benefits to factoring out content into a model:

* You reduce the amount of content that writers have to write, and remove the necessity for them to trace carefully through every procedure they write about to make sure every detail is correct. All the details will come from the model, so all you have to do to ensure that the details are correct is to make sure the model is correct. And if you find a flaw in the model, fixing it in the model automatically fixes it in all the content derived from the model. 

* When changes occur in the subject matter, you only have to change the model, not any of the documents that contain text derived from the model.

* The model can be maintained by one person who is an expert on the structured of the subject matter, thus removing the need for multiple writers to become experts in it. 

* If there is a change to the subject matter that could affect the way the model is called from the content, this will be immediately obvious because the names that the content used to identify the parts of the model it is interested in will no longer match, triggering a {referential integrity} error. This means it is almost impossible for a change in content to be missed when the subject matter changes. 

* It allows you to change the way that the subject matter is described independent of the existing content. If you want to shorten the navigation instruction in the procedure example to "File&gt;New", this requires only a change in the algorithm, not in hundreds of pieces of content. 

* The ability to change the way the subject is expressed simply by changing the algorithm gives you the ability to test different forms of expression to see which one works best. 

* This ability also allows you to personalize the content to different groups or even to allow individuals to choose how they want content such as procedures expressed. Using {active content} techniques, you can change how the content is expressed based on the information you have a about the user or allow them to select from verbose or terse forms of expression. 

* The fully-written-out example of the procedure above uses {keys} to factor out the difference between screen shots for different platforms, a technique that we looked at in [#chapter.reuse]. But while keys are a powerful tool, they are also an abstract concept and writers have to learn to use them correctly. But in the model example, the choice of screenshots is moved from the content to the model. This factors out the complexity of using keys. It also allows you to make choices about how and where and if screen shots are displayed, including the ability to test which works best or to allow the user to select whether they prefer to see screen shots or not. 

As with every other algorithm described in this book, it is important not to get carried away with enthusiasm of modeling in isolation. Although there is something very technically satisfying about building a model and deriving a variety of content from it, the model and its algorithms are both also sources of complexity. As we have noted, there is nothing wrong in principle with introducing new complexity into the content system. All tools do this. The point is to ensure that all of the complexity in the content system is handled by a person or process with the skills, time, and resources to handle it proper. Modeling partitions and redistributes a lot of complexity, which means it can create substantial change to the overall content system. It is important to make sure that when you do it, the effect on the overall content system is positive. </codeblock>
</chapter>
