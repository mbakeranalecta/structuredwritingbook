<?xml version="1.0" encoding="UTF-8"?>
<chapter name ="chapter.active">
<title>Active content</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">DITA</annotation></phrase> <phrase><annotation type="language">DocBook</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">HTML</annotation></phrase> <phrase><annotation type="language">XML</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm">composition</annotation></phrase> <phrase><annotation type="algorithm">conformance algorithm</annotation></phrase> <phrase><annotation type="algorithm">conformance</annotation></phrase> <phrase><annotation type="algorithm">content management algorithm</annotation></phrase> <phrase><annotation type="algorithm">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract and merge algorithm</annotation></phrase> <phrase><annotation type="algorithm">extract and merge</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance algorithm</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">Content management systems</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase></p>
</annotations>
<index>
<record>
<term>concept</term>
<type>active content</type>
</record>
</index>
<p>When you publish to <phrase>electronic media</phrase>, you can create <phrase>active content</phrase>, that is, content that has behavior as well as formatting. Some examples:</p>
<ll>
<li>
<label><phrase>Personalized content</phrase></label>
<p>You can select and arrange content for individual readers based on the things you know about them. For instance, if you are logged into <phrase>Amazon</phrase> it customizes elements of every page based on your previous purchases, your wishlist, and things you previously browsed.</p>
</li>
<li>
<label>Dynamic arrangement</label>
<p>Part of the <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> is arranging content on the page or screen, but with <phrase>online media</phrase> you can allow the reader to arrange the content. For instance, you can publish <phrase>tables</phrase> that readers can sort for themselves.</p>
</li>
<li>
<label><phrase>Adaptive content</phrase></label>
<p>Similarly, you can create content that adapts itself dynamically to the view port in which it is displayed. For instance, displaying in multiple columns on a wide view port, and in a single column on a narrow one.</p>
</li>
<li>
<label><phrase>Progressive disclosure</phrase></label>
<p>You can present content in a way that only shows part of the content on the screen initially but reveals more when the user clicks on a link or takes another action. For instance, you might show the high-level of a procedure and provide a link that opens detailed steps for those who need them. This is a way to cater to audiences with different levels of preparedness.</p>
</li>
<li>
<label><phrase>Feeds</phrase> and dynamic sources</label>
<p>You can include content that comes from an external source which updates independently of your content such as a feed or a web service.</p>
</li>
<li>
<label><phrase>Interactive media</phrase></label>
<p>You can include <phrase>apps</phrase>, <phrase>widgets</phrase>, and other media that the user can interact with.</p>
</li>
</ll>
<p><phrase>Active content</phrase> is simply the postponement of one or more of the structured writing algorithms to the time of reading. <phrase>Personalized content</phrase> is executing the <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> on the server when you request a page, using personal details as query terms to select content for the individual. Changing the layout of the page when you resize you browser or rotate your phone is executing the <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> in the browser. Allowing the reader to change the font size is allowing the reader to configure and execute the <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> in the browser. Pulling a live stock quote into a page that mentions a company is having the web server or the web browser executes the <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> when the page is served/displayed.</p>
<p>In principle, therefore, you support active content in exactly the same way you support those algorithms in any form of structured writing: by creating your content in the appropriate domain and with the appropriate structures to reliably support the algorithms you want to run. Reliability is key here, of course. If you are creating static <phrase>books</phrase> or <phrase>web pages</phrase> you may be able to get away with reviewing the results before they are published and even hand tweaking the output to fix any issues, but you can’t do that with active content. You need to be able to trust the algorithm 100%, which means you need to trust the content it is working on 100%. This makes the <phrase><annotation type="algorithm">conformance algorithm</annotation></phrase> crucial to an <phrase>active content</phrase> project, and, as we have seen, different domains support the <phrase><annotation type="algorithm">conformance algorithm</annotation></phrase> with varying degrees of reliability.</p>
<p>Another factor to consider, though, is that while active content is essentially just postponing the point at which you execute various structured writing algorithms until the content is in the user’s hands, you don’t necessarily want to postpone running those algorithms on the whole page. You usually only postpone them for the parts of the page that you want to make active. For instance, if you want real-time stock quotes embedded in your business stories whenever a company is mentioned, there is no reason to postpone the <phrase><annotation type="algorithm">synthesis</annotation></phrase>, <phrase><annotation type="algorithm">presentation</annotation></phrase>, and <phrase><annotation type="algorithm">formatting</annotation></phrase> of the entire page; you only need to postpone the synthesis of the stock quote itself. And if you want that quote to continue to update in real time while the page is displayed, you certainly don’t want to be redrawing the whole page every time the price changes.</p>
<p>The display of stock quotes depends on <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase>metadata</phrase> that unambiguously identifies the company mentioned in the content. For example:</p>
<codeblock language ="sam">
{Microsoft}(company "NASDAQ:MSFT") is a large software company.
</codeblock>
<p>In a normal static publishing flow, this <phrase><annotation type="concept">subject domain</annotation></phrase> information would be resolved into a static piece of content by the <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase>:</p>
<blockquote>
<p><phrase><annotation type="bold">Microsoft</annotation></phrase> US$60.29 +0.34 (+0.57%) is a large software company.</p>
</blockquote>
<p>But for <phrase>active content</phrase> the main <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> needs to pass through the <phrase><annotation type="concept">subject-domain</annotation></phrase> information to the browser so that that bit of synthesis can be executed in real time when the content is displayed.</p>
<p>This means that only those parts of the content that you want displayed as active content need to be captured in the structured writing domain, and in the specific structures, required to reliably run the applicable algorithms. The rest of the content can be in a different domain. In practice, this usually means that you have <phrase><annotation type="concept">subject domain</annotation></phrase> structures to support the active content embedded in <phrase><annotation type="concept">document domain</annotation></phrase> structures. Of course, having all your content in the <phrase><annotation type="concept">subject domain</annotation></phrase> is also an option, in which case you would perform the <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> on the content you want to deliver statically, while passing on the <phrase><annotation type="concept">subject-domain</annotation></phrase> representation of the content you want to be active to the system that will perform the active content algorithms.</p>
<p>However, this is not necessarily, or even likely, to be a straightforward pass through. The downstream system that is going to execute the active content algorithm, such as a JavaScript app running in the web browser, may expect or require the <phrase><annotation type="concept">subject domain</annotation></phrase> information it uses in a particular format. For instance, you might have to embed the ticker symbol in a call to a function that returns stock quotes:</p>
<codeblock language ="xml">
&lt;p&gt;Microsoft (&lt;span onload="getStockQuote(NASDAQ:MSFT)"/&gt;) 
is a large software company.&lt;/p&gt;
</codeblock>
<p>So your server side <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> needs to transform your <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase>annotation</phrase> into this format.</p>
<codeblock language ="pseudocode">
match company
    continue
    $fncall = 'getStockQuote(' + @specifically + ')'
    output ' ('
    create span
        create attribute onload = $fncall
    output ') '
</codeblock>
<p>The <phrase><annotation type="concept">document domain</annotation></phrase> represents the desired presentation of a piece of content. Therefore the only kinds of active content algorithms that you can execute on ordinary <phrase><annotation type="concept">document domain</annotation></phrase> structures are those that leave the <phrase><annotation type="algorithm">presentation</annotation></phrase> alone and only affect the <phrase><annotation type="algorithm">formatting</annotation></phrase>. For example, you can allow readers to select the font size of a web page, which is a purely formatting concern.</p>
<p>If you want to do active content that dynamically changes the presentation of the content, or that changes the text of the content (as in our stock price example) then you need either <phrase><annotation type="concept">subject domain</annotation></phrase> structures or <phrase><annotation type="concept">document domain</annotation></phrase> structures that are explicitly designed to support active content algorithms.</p>
<p>For example, a generic <phrase>table</phrase> structure does not support the action of allowing the reader to sort on any column. Sorting by column only makes sense if the content is inherently sortable.</p>
<grid>
<row>
<cell><phrase><annotation type="bold">item</annotation></phrase></cell>
<cell><phrase><annotation type="bold">legs</annotation></phrase></cell>
<cell><phrase><annotation type="bold">price</annotation></phrase></cell>
</row>
<row>
<cell>table</cell>
<cell>4</cell>
<cell>$400</cell>
</row>
<row>
<cell>stool</cell>
<cell>3</cell>
<cell>$20</cell>
</row>
<row>
<cell>shooting stick</cell>
<cell>1</cell>
<cell>$75</cell>
</row>
<row>
<cell>chair</cell>
<cell>4</cell>
<cell>$60</cell>
</row>
</grid>
<p>For example, in the table above the columns are sortable. The reader could choose to sort the table on the item name, the number of legs, or the price, all of which might be useful arrangements, based on their needs.</p>
<p>But consider what might happen if you sorted this table on the second column:</p>
<grid>
<row>
<cell>1.</cell>
<cell>Don protective clothing.</cell>
</row>
<row>
<cell>2.</cell>
<cell>Clear the area.</cell>
</row>
<row>
<cell>3.</cell>
<cell>Block all entrances.</cell>
</row>
<row>
<cell>4.</cell>
<cell>Activate the destruct sequence.</cell>
</row>
</grid>
<p>Thus you can’t just decide to make all the tables on a page sortable by column. Unless the <phrase><annotation type="concept">document domain</annotation></phrase> structure explicitly states which columns of a table are sortable and which are not, you can’t implement this kind of active content.</p>
<p>To implement column sorting at the <phrase><annotation type="concept">document domain</annotation></phrase> level, therefore, you need some sort of sortable table structure which assures that the sorting behavior is only applied to columns where it makes sense in tables where it makes sense.</p>
<p>While the <phrase><annotation type="concept">document domain</annotation></phrase> typically requires different markup for different algorithms, the <phrase><annotation type="concept">subject domain</annotation></phrase> typically does not. In the subject domain you capture the semantics of the subject matter, which are the same no matter what algorithms you are applying to the content.</p>
<p>In the <phrase><annotation type="concept">subject domain</annotation></phrase>, the product list would be a structured data set with known semantics (probably maintained as a separate database).</p>
<codeblock language ="sam">
products:: item, legs, price
    table, 4, $400      
    stool, 3, $20             
    shooting stick, 1, $75
    chair , 4, $60
</codeblock>
<p>Knowing what the semantics are, you would know whether that data set is sortable and therefore whether it can be presented as a sortable table.</p>
<p>Creating your content in the <phrase><annotation type="concept">subject domain</annotation></phrase> gives you the greatest flexibility to generate <phrase>active content</phrase> in ways that are appropriate to the subject matter and the device. And because the subject domain does not require any different structures to support active content, your writers don’t have to understand or even think about how the active content might work, effectively partitioning the complexity of active content from your writers. As we have seen before, an additional benefit of partitioning content from its presentation is that it allows you to experiment with different forms of presentation. This allows you to test if active content is working or not or change the form of <phrase>active content</phrase> you use, all without involving writers of changing your content.</p>
<p>This does not mean that active content is always going to be a free gift of the <phrase><annotation type="concept">subject domain</annotation></phrase>. Apart from the fact that you still have to design and implement the content behavior, you are going to have to make sure that you are capturing the subject domain semantics that are needed to drive the active content behaviors you want. Those semantics may not be different in kind from any other subject domain semantics, but you may need to break things down in greater detail than you might have to for other algorithms. You will also need to make sure that you get a high degree of <phrase><annotation type="algorithm">conformance</annotation></phrase> to these structures from your writers, as it is difficult to validate the correct operation of every active content algorithm on every content set at run time. The success of your active content strategy is going to depend heavily on the <phrase><annotation type="algorithm">quality</annotation></phrase> and consistency of your input data.</p>
</chapter>
