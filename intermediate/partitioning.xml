<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.partitioning">
<title>Partitioning Complexity</title>

<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="process">conformance</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforming</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> <phrase><annotation type="process">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<index>
<record>
<type>concept</type>
<term>structured writing</term>
</record>
<record>
<type>concept</type>
<term>complexity</term>
</record>
<record>
<type>concept</type>
<term>partitioning</term>
</record>
</index>
<p>To understand how to successfully partition the complexity of a content system, we must begin by asking what complexity is. The complexity of a task in the content process (or any other process) can be measured by the number of decisions people have to make and execute. Every decision requires knowledge (to make the correct choice) and skill (to execute that choice). The more decisions a task involves, the more knowledge and skill it requires, and the more knowledge and skill a task requires, the more complex it is. We can reduce the complexity of tasks by partitioning the complexity to minimize the knowledge and skills required for each task.</p>
<p>We can divide the decisions involved in a task into two kinds:</p>
<ll>
<li>
<label>Core</label>

<p>decisions that are fundamental to the task. These decisions are central to the task and cannot be removed by changing your processes.</p>
</li>
<li>
<label>Extended</label>

<p>decisions that are introduced into the task by your processes or tools. Theoretically, at least, these decisions can be removed from the task by changing your processes or tools.</p>
</li>
</ll>
<p>The more extended decisions you remove from a task, the simpler you make that task. The purpose of partitioning the content system is to remove these decisions from key tasks, making them less complex and, therefore, improving productivity and quality.</p>
<p>Of course, those decisions don’t just vanish into thin air. They still must be made and acted on somewhere in the system. Complexity cannot be destroyed, but it can be moved around to ensure that every decision is made by the person or process with the information, skill, and resources to make and execute it best.</p>
<p>Simplifying the tasks of individual people and processes is not the only reason to change where decisions get made. Making decisions earlier or later in the content process can also have profound effects on the efficiency of your process and the kinds of rhetoric it can produce. For instance, partitioning decisions about document formatting away from the writer means that those decisions are not recorded in the content itself. If you later need to change how your content is formatted, you can change the formatting algorithm, without touching the content. The possibilities in this area go well beyond formatting, as we will see in later chapters.</p>
<p>All modern content systems are partitioned, but not all are partitioned in a way that fully handles the complexity of the content development and delivery process. As a result, many organizations produce content of poor or variable quality, and lose money. Why are so many content systems poorly partitioned? We can find some answers by looking at the evolution of content development.</p>
<section>
<title>Desktop publishing</title>

<p>One of the biggest changes in the partitioning of the content system was ushered in by the <phrase><annotation type="concept">desktop publishing</annotation></phrase> (DTP) revolution of the 1980s. Prior to the introduction of desktop publishing, creating a formatted printed document generally meant handing off a manuscript from an author to a typesetter for re-keying, followed by mechanical pasteup by a page-layout artist, preparation of proofs by a printer, correction of proofs, and printing.</p>
<p>This was in many ways a well-partitioned process. Professionals in each trade had a piece of the decision making and the tools to implement those decisions. However, the overhead of passing information from one trade to the next was cumbersome resulting in a process that was time-consuming and expensive with many potential points of failure.</p>
<p><phrase><annotation type="concept">Desktop publishing</annotation></phrase> eliminated much of that overhead by putting all of these functions – writing, design, layout, and proofing – in the hands of a single operator: the writer. This greatly sped up the publishing process and generally reduced costs by eliminating most of the trades traditionally involved in the process.</p>
<p>However, this radical change in partitioning introduced three problems:</p>
<p>First, it put a huge amount of complexity on the writer. In a desktop publishing environment, writers must make many more decisions, which require knowledge and skills in addition to those required to research and write content. The demand for writers who can handle this complexity changed hiring practices. Desktop publishing skill became a major hiring criteria for writers and remains so today. The focus in hiring moved from writing skills and knowledge of subject matter to the ability to manage the publishing process.</p>
<p>Second, because writers did layout and design while writing, their attention was divided between these tasks. Attention is a finite resource; when writers pay attention to layout and design rather than rhetoric, the quality of the writing suffers. And since the layout and design are only getting partial attention, their quality suffers as well.</p>
<p>Third, although desktop publishing removed the need for a lot of vertical communication between writers, designers, and typesetters, it made no provision for horizontal communication between writers, leaving every writer on an island. Every book was a separate project. The division of the writer’s attention and the lack of horizontal coordination left huge amounts of complexity unhandled in large content systems. <phrase>Duplication</phrase>, <phrase>omissions</phrase>, and <phrase>inconsistencies</phrase> became difficult to detect and fix, and providing effective <phrase><annotation type="concept">navigation</annotation></phrase> between books were virtually impossible. All of this rhetorical complexity went unhandled and the result was dumped on the reader in the form of poor quality content. Desktop publishing did not create this problem, but it did nothing to fix it.</p>
</section>
<section>
<title>Style sheets</title>

<p>One of the most visible early signs of unhandled complexity creating quality problems came in the form of the dreaded “desktop publishing look” – an explosion of poorly designed and poorly laid out documents, characterized by bizarre font combinations, poor use of whitespace, poorly designed and placed graphics, and a seemingly random profusion of lines, shades, colors, and other decorative elements. (Insofar as these design defects hinder the reader’s reception of the content, or detract from the image of the organization, they are also rhetorical problems.)</p>
<p>To help contain this, desktop publishing systems introduced <phrase><annotation type="concept">style sheets</annotation></phrase>, which partially partition content from formatting. Style sheets allow a writer to format text using predefined, named styles. Each style encapsulates a set of decisions about content formatting that have been made by a style sheet designer. Style sheets allow you to partition decisions about what the text looks like from decisions about what the text says.</p>
<p>Style sheets do not completely partition formatting decisions from writers, however. Writers still must pass information to the partition that makes formatting decisions, which means writers must decide which styles to apply (knowledge) and know how to apply them (skill). Although this is less complex and requires less design skill than formatting by hand, experience shows that many writers do not use styles correctly or even at all.</p>
<p>Although style sheets remove some formatting decisions, the WYSIWYG (What You See is What You Get) display used by desktop publishing systems has another flaw. A key aspect of any interface between partitions is the feedback it gives users to let them know if they have done their work correctly. A WYSIWYG display tells you only one thing: does it look right? It does not tell you whether you have used styles correctly, or at all. And what looks right to you may not look right to the next person.</p>
<p>Another problem is that style sheets partition the design of individual elements of a document, such as a title or a list, but not the overall design of the document. Document design remains on the writer’s side of the partition. The style sheet restricts the formatting pallet, but it does not tell writers how to use that pallet to achieve an effective overall document design. Since writers are not document designers by trade, they may not always do this well, and multiple writers working on a common project will almost certainly do it inconsistently.</p>
<p>Many organization use <phrase>style guide</phrase>s to tell writers how to use the style pallet to design documents. (For instance, which styles to use when creating a bibliography.) But the style guide only provides instructions, it does not partition the task away from the writer. The style guide merely adds another knowledge requirement, adding complexity.</p>
<p>Styles, therefore, provide only limited relief to the complexity dumped on the author, and they are only moderately successful in promoting consistent document appearance.</p>
</section>
<section>
<title>Content management systems</title>

<p>Meanwhile, the Web brings a new set of challenges. A modern website is not a library of independent volumes; it’s a complex <phrase><annotation type="media">hypertext</annotation></phrase> consisting of many smaller pieces of content related in much more complex ways than paper documents ever were. <phrase>Search engines</phrase> and <phrase>social networks</phrase> have profoundly changed how readers seek and use content. Meeting those needs requires a level of coordination between writers – and between the pieces of content they create – that <phrase><annotation type="concept">desktop publishing</annotation></phrase> cannot provide.</p>
<p>To help manage these challenges, most organizations have adopted <phrase><annotation type="tool">content management systems</annotation></phrase> (CMS). This has led to new forms of partitioning and new roles, such as <phrase>webmaster</phrase>, <phrase><annotation type="role">information architect</annotation></phrase>, and, more recently, <phrase>content strategist</phrase>.</p>
<p>Some of this new partitioning is useful, but sometimes content management systems can make things worse. For instance, some content management systems give control of the page header and sidebar to an <phrase><annotation type="role">information architect</annotation></phrase> but let writers design the document part of the page pretty much as they did with a <phrase>desktop publishing system</phrase>. Unfortunately, this approach just wraps a frame around all of the shortcomings of desktop publishing, highlighting those shortcomings by closely juxtaposing the work of different writers.</p>
<p>Increasingly, therefore, content management systems have begun to incorporate more structured techniques and rely on a technology that actually predates desktop publishing: markup languages.</p>
</section>
<section>
<title>Markup languages</title>

<p>A <phrase><annotation type="tool">markup language</annotation></phrase> is a system for indicating the structure of a text via marks in the text itself. The structured writing examples we have looked at so far have all be written in markup languages. Markup languages were used for publishing on mainframe computers long before desktop computers had the processing power required for desktop publishing. A markup language – <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> – gave birth to the Web by enabling writers to include in a document the information needed to format and display that document in a Web browser.</p>
<p>The HTML document includes both information to be displayed to the reader and information to be used by the browser to display the document – information that is not shown to the reader. This combination of two different streams in a single stream of characters is at the heart of how a markup language works and the role it plays in a content process. It allows us to partition tasks within the content process by passing the information those tasks need along with the content intended for the reader.</p>
<p><phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> is probably the single most widely used markup language in the world today, but there are thousands of others, and people create new markup languages for specific purposes all the time. Each markup language represents a specific interface between partitions in a content system.</p>
<p>Markup languages are by far the most general type of content interface, and they can be used to implement nearly any kind of partitioning you might need. In fact, markup languages are usually found behind the scenes in WYSIWYG and forms-based interfaces. However, markup languages can also stand alone as interfaces in their own right. <phrase><annotation type="language">Markdown</annotation></phrase>, for instance, has become a popular markup language for writing simple Web content.</p>
<p>There can be (and usually are), multiple partitions in a content system. The interfaces between those partitions are frequently markup languages, including interfaces that writers never use themselves. For instance, an organization may use <phrase><annotation type="language">Markdown</annotation></phrase> to author some of their content but then convert <phrase><annotation type="language">Markdown</annotation></phrase> to <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> for publishing and use a <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> style sheet (another markup language) to specify the formatting for that content.</p>
<p>Today the term “structured writing” is often taken as a synonym for the use of markup languages. This is not really fair, since any use of computers for writing and publishing necessarily involves applying structure to text. The reason we associate markup languages so strongly with structured writing, however, is that markup languages allow organizations to create their own structures and, thus, change the way their content systems are partitioned. Any serious attempt to better manage the complexity of the content system by changing how the system is partitioned is likely to involve the use of markup languages, usually several markup languages in different roles.</p>
<p>Most of the discussion in this book focuses on the use of markup languages, because markup languages provide the greatest range of possibilities for effectively partitioning the content system. You may be able to hide some of the markup techniques discussed here behind WYSIWYG or forms-based interfaces. However, in this book I use markup to illustrate them all, because markup provides the clearest view of the structure and interfaces that define partitions.</p>
</section>
<section>
<title>Algorithms</title>

<p>To take content created using a markup language and turn it into a formatted document requires an algorithm. Algorithms are also used to manage the content process. An algorithm is simply a regular, codified, and repeatable method for doing a task.</p>
<p>Most complex tasks have repeatable elements in them. A design question that has been settled once can be implemented over and over again without having to redo the design work. If one piece of content is formatted a certain way, chances are many similar pieces can be formatted the same way. Algorithms are great at doing the same task the same way over and over. Therefore, partitioning such tasks away from authors and directing them to algorithms is a great way to reduce the complexity of the author’s task.</p>
<p>And while algorithms are repetitive by nature, they can also incorporate considerable knowledge, make sophisticated decisions, and execute complicated processes, which makes them capable of meeting both the knowledge and skill requirements to make useful decisions. Thus we can use algorithms to execute many of the extended decisions in a content process, leaving writers and designers free to focus on the core decisions.</p>
<p>A computer program is an encoding of an algorithm that a computer can execute. A program describes an algorithm to a computer, but you do not need to be a programmer to design an algorithm. The real trick is to discern which parts of a process can be defined as algorithms. That is why an understanding of the main structured writing algorithms is vital to effectively partitioning your content system.</p>
<p>Algorithms are fundamental to structured writing. Algorithms and structures work together to support rhetoric and process and you can’t design one without the other. The heart of this book describes the principal structured writing algorithms and the structures that support them.</p>
</section>
<section>
<title>Partitioning and Roles</title>

<p>Partitioning a content system often means changing the roles that people play in the organization. The introduction of <phrase><annotation type="concept">desktop publishing</annotation></phrase>, for instance, merged the role of writer and <phrase>typesetter</phrase> and, to a certain extent, the roles of <phrase>document designer</phrase> and <phrase>prepress operator</phrase> as well. The introduction of more sophisticated (or simply more appropriate) structured writing techniques will likely mean the introduction of new roles and/or the modification of existing ones within your organization.</p>
<p>Writing an algorithm redistributes complexity away from the person who used to do the task, but it directs that complexity to the person who writes and maintains the algorithm. For example, using a <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> style sheet to format lists redistributes the task of designing list formatting from writers, whose job is to know what they are talking about and how to say it, to a <phrase>publications designer</phrase>, whose job it is to know how to attractively format lists and how to code good <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase>.</p>
<p>Using <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> partitions the complexity of formatting a page, distributing that complexity away from the writer. Now, the writer does not have to know about formatting or design, and the designer does not have to know about writing or the subject matter. This allows writers to focus on writing and designers to focus on design. The result is better writing and better, more consistent, design supported by two distinct roles with different skill sets.</p>
<p>As we discuss the major structured writing algorithms in <citation nameref="part.algorithms"/> we will see how these algorithms partition tasks between writers and professionals such as <phrase><annotation type="role">information architect</annotation></phrase>s, <phrase><annotation type="role">content engineer</annotation></phrase>s, and <phrase>content strategist</phrase>s.</p>
</section>
<section>
<title>Quality and Rhetoric</title>

<p>Many structured writing systems focus only on the <phrase>separation of content from formatting</phrase> (<citation nameref="chapter.separating"/>) and on content management functions (<citation nameref="chapter.content-management"/>). Separating content from formatting can help improve content quality by freeing more of the writer’s time and attention to focus on writing. However, you can do even more to improve the quality of content by placing explicit constraints on the rhetorical structures that writers create.</p>
<p>Organizations are becoming more aware of the impact that <phrase>rhetorical quality</phrase> has on their business. The <phrase><annotation type="media">Web</annotation></phrase> has made it easier for users to access our information, but it has also made it easier for them to detect content that is inconsistent in tone and style, outdated, redundant, incomplete, or just plain useless. The Web did not create these flaws, but it made them painfully apparent. It has also given organizations a much more direct way to see and to measure the impact of their content and of its flaws. Organizations can no longer ignore major rhetorical faults. This has led to the emergence of the discipline of <phrase><annotation type="concept">content strategy</annotation></phrase> as organizations feel the impact of poor content quality and see content quality as a strategic value.</p>
<p>In the age of physical typesetting, we had no automated tools to help with the rhetorical quality of content, and the desktop publishing revolution was mostly concerned with digitizing the previously mechanical design and layout process. The limitations of the available tools forced organizations to partition their processes in ways that did not always support, encourage, or even permit, the highest quality rhetoric. The result was poor-quality content.</p>
<p>Modern structured writing tools allow us to partition the content system in ways that significantly enhance the <phrase>rhetorical quality</phrase> of content. This includes methods that free writers to focus on quality, to create consistent content, to validate and audit content quality, and to create content structures and products that would not be possible with other methods.</p>
</section>
<section>
<title>Build quality into the process</title>

<p>The idea that you can build quality into a process by managing the complexity of the design and production process, though well accepted in other fields, has not been widely considered in the content field. To a large extent, where we have sought process improvements, they have been in publishing and content management, not rhetoric and content quality. Where structured writing tools have replaced desktop publishing tools, it has largely been in pursuit of process goals. But process and rhetoric are intimately related and treating them holistically can significantly improve both.</p>
<p>Unfortunately, many current content systems not only fail to provide active rhetorical support to writers, they also fail to remove distractions and complexity from the writing environment. This ends up making the writer’s life more complex rather than less. If writers end up with more complexity than they can comfortable handle, the result is reduced attention to rhetoric, which means diminished content quality. Sometimes that unhandled complexity also derails the attempts to make the process more efficient because the information coming through the complex interface is not reliable enough for the new process to work correctly.</p>
<p>Sadly, the developers of many content systems have never seriously attempted to minimize the amount of complexity they dump on the writer. They treat writing and publishing as separate concerns, as if the publishing process and its demands had no influence on the quality of content that the system produced. The result has been widespread dissatisfaction with both content systems and the resulting output. Lack of attention to where complexity falls in a system, and to the intimate relationship between process and rhetoric, typically results in breakdown and failure of the system. And it gets worse as features are added without adequate thought being given to the impact of the complexity they introduce, a process content strategist Joe Gollner calls the “barnacalization of systems.”</p>
</section>
<section>
<title>Towards a more effective partitioning of the content system</title>

<p>The impact of poor quality content goes straight to the bottom line. To improve content quality on a consistent and economical basis, organizations need an approach to structured writing that recognizes the intimate relationship between process and rhetoric and that partitions the complexity of the content process to the people or processes with the time, skills, and resources to handle it effectively.</p>
<p>Every organization has different process challenges  and rhetorical goals. Thus there is no one structured writing system that is a perfect fit for every organization. The attempt to create a single system to meet all needs has been a large factor in the poor partitioning of many content systems. Rather than prescribe any one partitioning, this book explores structured writing strategies you can use to partition your content system and suggests how you can determine which approach will work best for your organization.</p>
</section>
</chapter>
