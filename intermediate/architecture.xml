<?xml version="1.0" encoding="UTF-8"?>
<chapter name="chapter.architecture">
<title>Information Architecture</title>
<annotations>
<p>Concepts</p>
<p><phrase><annotation type="concept">abstract language</annotation></phrase> <phrase><annotation type="concept">adaptive content</annotation></phrase> <phrase><annotation type="concept" specifically="algorithm">algorithms</annotation></phrase> <phrase><annotation type="concept">algorithm</annotation></phrase> <phrase><annotation type="concept">annotations</annotation></phrase> <phrase><annotation type="concept">annotation</annotation></phrase> <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> <phrase><annotation type="concept">categories</annotation></phrase> <phrase><annotation type="concept">categorization</annotation></phrase> <phrase><annotation type="concept">classification</annotation></phrase> <phrase><annotation type="concept">consistency</annotation></phrase> <phrase><annotation type="concept">constraints</annotation></phrase> <phrase><annotation type="concept">content silos</annotation></phrase> <phrase><annotation type="concept">content strategy</annotation></phrase> <phrase><annotation type="concept">coverage</annotation></phrase> <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="concept">document type</annotation></phrase> <phrase><annotation type="concept">document-domain</annotation></phrase> <phrase><annotation type="concept">electronic media</annotation></phrase> <phrase><annotation type="concept">Every Page is Page One</annotation></phrase> <phrase><annotation type="concept">extensibility</annotation></phrase> <phrase><annotation type="concept">faceted navigation</annotation></phrase> <phrase><annotation type="concept">feeds</annotation></phrase> <phrase><annotation type="concept">findability</annotation></phrase> <phrase><annotation type="concept">frameworks</annotation></phrase> <phrase><annotation type="concept">functional lucidity</annotation></phrase> <phrase><annotation type="concept">functionally lucid</annotation></phrase> <phrase><annotation type="concept">future proofing</annotation></phrase> <phrase><annotation type="concept">future proof</annotation></phrase> <phrase><annotation type="concept">guidance</annotation></phrase> <phrase><annotation type="concept">hierarchical structure</annotation></phrase> <phrase><annotation type="concept">hybrid markup language</annotation></phrase> <phrase><annotation type="concept">information architecture</annotation></phrase> <phrase><annotation type="concept">information design</annotation></phrase> <phrase><annotation type="concept">information foraging</annotation></phrase> <phrase><annotation type="concept">information mapping</annotation></phrase> <phrase><annotation type="concept">information typing</annotation></phrase> <phrase><annotation type="concept">interactive media</annotation></phrase> <phrase><annotation type="concept">management domain</annotation></phrase> <phrase><annotation type="concept">management-domain</annotation></phrase> <phrase><annotation type="concept">media domain</annotation></phrase> <phrase><annotation type="concept">media-domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> <phrase><annotation type="concept">navigation</annotation></phrase> <phrase><annotation type="concept">normalization</annotation></phrase> <phrase><annotation type="concept">personalized content</annotation></phrase> <phrase><annotation type="concept">progressive disclosure</annotation></phrase> <phrase><annotation type="concept">referential integrity</annotation></phrase> <phrase><annotation type="concept">rendering problems</annotation></phrase> <phrase><annotation type="concept">reuse of patterns</annotation></phrase> <phrase><annotation type="concept">rhetorical</annotation></phrase> <phrase><annotation type="concept">rhetoric</annotation></phrase> <phrase><annotation type="concept">searchable</annotation></phrase> <phrase><annotation type="concept">search</annotation></phrase> <phrase><annotation type="concept">specialization</annotation></phrase> <phrase><annotation type="concept">structured content type</annotation></phrase> <phrase><annotation type="concept">structured writing domains</annotation></phrase> <phrase><annotation type="concept">style</annotation></phrase> <phrase><annotation type="concept">subject affinities</annotation></phrase> <phrase><annotation type="concept">subject affinity</annotation></phrase> <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">subject-domain</annotation></phrase> <phrase><annotation type="concept">taxonomy</annotation></phrase> <phrase><annotation type="concept">terminology</annotation></phrase> <phrase><annotation type="concept">top-down information architecture</annotation></phrase> <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> <phrase><annotation type="concept">WYSIWYG</annotation></phrase></p>
<p>Languages</p>
<p><phrase><annotation type="language">ASCIIDOC</annotation></phrase> <phrase><annotation type="language">cascading style sheets</annotation></phrase> <phrase><annotation type="language" specifically="cascading style sheets">CSS</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase> <phrase><annotation type="language"><annotation type="standard">HTML</annotation></annotation></phrase> <phrase><annotation type="language">JavaDoc</annotation></phrase> <phrase><annotation type="language">LaTeX</annotation></phrase> <phrase><annotation type="language">Markdown</annotation></phrase> <phrase><annotation type="language">mathml</annotation></phrase> <phrase><annotation type="language">reStructuredText</annotation></phrase> <phrase><annotation type="language">SAM</annotation></phrase> <phrase><annotation type="language">SGML</annotation></phrase> <phrase><annotation type="language">TeX</annotation></phrase> <phrase><annotation type="language">XLIFF</annotation></phrase> <phrase><annotation type="language">XML schema</annotation></phrase> <phrase><annotation type="language"><annotation type="standard">XML</annotation></annotation></phrase> <phrase><annotation type="language">XSD</annotation></phrase> <phrase><annotation type="language">XSL-FO</annotation></phrase></p>
<p>Algorithms</p>
<p><phrase><annotation type="algorithm">active content</annotation></phrase> <phrase><annotation type="algorithm">audit algorithm</annotation></phrase> <phrase><annotation type="algorithm">auditable</annotation></phrase> <phrase><annotation type="algorithm">auditing</annotation></phrase> <phrase><annotation type="algorithm">audit</annotation></phrase> <phrase><annotation type="algorithm">authoring algorithm</annotation></phrase> <phrase><annotation type="algorithm">authoring</annotation></phrase> <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase> <phrase><annotation type="algorithm">change management</annotation></phrase> <phrase><annotation type="algorithm">change</annotation></phrase> <phrase><annotation type="algorithm">collaboration</annotation></phrase> <phrase><annotation type="algorithm">compliance</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition">composability</annotation></phrase> <phrase><annotation type="algorithm">composition algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="composition algorithm">composition</annotation></phrase> <phrase><annotation type="process">conformance</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conformant</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforming</annotation></phrase> <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> <phrase><annotation type="process">content management</annotation></phrase> <phrase><annotation type="algorithm">content reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content reuse</annotation></phrase> <phrase><annotation type="algorithm" specifically="content reuse algorithm">content-reuse</annotation></phrase> <phrase><annotation type="algorithm">continuous translation</annotation></phrase> <phrase><annotation type="algorithm">deferred synthesis</annotation></phrase> <phrase><annotation type="algorithm">differential presentation</annotation></phrase> <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> <phrase><annotation type="algorithm">differential synthesis</annotation></phrase> <phrase><annotation type="algorithm">encoding algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="encoding algorithm">encoding</annotation></phrase> <phrase><annotation type="algorithm">exchange algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="exchange algorithm">exchange</annotation></phrase> <phrase><annotation type="algorithm">extract algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="extract algorithm">extract</annotation></phrase> <phrase><annotation type="algorithm">formatting algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="formatting algorithm">formatting</annotation></phrase> <phrase><annotation type="algorithm">information architecture algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="linking algorithm">linking</annotation></phrase> <phrase><annotation type="algorithm">merge algorithm</annotation></phrase> <phrase><annotation type="algorithm" specifically="merge algorithm">merge</annotation></phrase> <phrase><annotation type="algorithm">modeling algorithm</annotation></phrase> <phrase><annotation type="algorithm">pagination</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithms</annotation></phrase> <phrase><annotation type="algorithm">presentation algorithm</annotation></phrase> <phrase><annotation type="algorithm">presentation</annotation></phrase> <phrase><annotation type="algorithm">publication</annotation></phrase> <phrase><annotation type="algorithm">publish  algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">publishing</annotation></phrase> <phrase><annotation type="algorithm">quality algorithm</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">quality</annotation></phrase> <phrase><annotation type="algorithm">relevance</annotation></phrase> <phrase><annotation type="algorithm">relevant</annotation></phrase> <phrase><annotation type="algorithm">rendering algorithm</annotation></phrase> <phrase><annotation type="algorithm">rendering</annotation></phrase> <phrase><annotation type="algorithm">repeatability</annotation></phrase> <phrase><annotation type="algorithm">repeatable</annotation></phrase> <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase> <phrase><annotation type="algorithm">reuse</annotation></phrase> <phrase><annotation type="algorithm">separate content from formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content form formatting</annotation></phrase> <phrase><annotation type="algorithm">separating content from formatting</annotation></phrase> <phrase><annotation type="algorithm">single source of truth algorithm</annotation></phrase> <phrase><annotation type="algorithm">single source of truth</annotation></phrase> <phrase><annotation type="algorithm">single sourcing algorithm</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single sourcing</annotation></phrase> <phrase><annotation type="algorithm">single-source</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis algorithm</annotation></phrase> <phrase><annotation type="algorithm">synthesis</annotation></phrase> <phrase><annotation type="algorithm">timeliness</annotation></phrase> <phrase><annotation type="algorithm">timely</annotation></phrase> <phrase><annotation type="algorithm">translation</annotation></phrase> <phrase><annotation type="algorithm">validate</annotation></phrase> <phrase><annotation type="algorithm" specifically="conformance">validation</annotation></phrase> <phrase><annotation type="algorithm">validation</annotation></phrase> <phrase><annotation type="algorithm">validity</annotation></phrase> <phrase><annotation type="algorithm">writing</annotation></phrase></p>
<p>Tools</p>
<p><phrase><annotation type="tool">browser</annotation></phrase> <phrase><annotation type="tool" specifically="content management system">CMS</annotation></phrase> <phrase><annotation type="tool">content management system</annotation></phrase> <phrase><annotation type="tool">content management systems</annotation></phrase> <phrase><annotation type="tool">Doxygen</annotation></phrase> <phrase><annotation type="tool">ebook readers</annotation></phrase> <phrase><annotation type="tool">FrameMaker</annotation></phrase> <phrase><annotation type="tool">FrameScript</annotation></phrase> <phrase><annotation type="tool">help systems</annotation></phrase> <phrase><annotation type="tool">Microsoft Word</annotation></phrase> <phrase><annotation type="tool">SPFE</annotation></phrase> <phrase><annotation type="tool">Sphinx</annotation></phrase> <phrase><annotation type="tool">XML database</annotation></phrase> <phrase><annotation type="tool">XML databases</annotation></phrase> <phrase><annotation type="tool">markup</annotation></phrase> <phrase><annotation type="tool">markup language</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase> <phrase><annotation type="tool">Word</annotation></phrase> <phrase><annotation type="tool">publishing pipeline</annotation></phrase> <phrase><annotation type="tool">repository</annotation></phrase> <phrase><annotation type="tool">page description language</annotation></phrase> <phrase><annotation type="tool">page descriptions languages</annotation></phrase> <phrase><annotation type="tool">schema</annotation></phrase> <phrase><annotation type="tool">schema languages</annotation></phrase> <phrase><annotation type="tool">search engine</annotation></phrase> <phrase><annotation type="tool">tool chain</annotation></phrase> <phrase><annotation type="tool">tool chains</annotation></phrase> <phrase><annotation type="tool">typesetting languages</annotation></phrase> <phrase><annotation type="tool">version control system</annotation></phrase> <phrase><annotation type="tool">workflow</annotation></phrase> <phrase><annotation type="tool">widgets</annotation></phrase> <phrase><annotation type="tool">wiki</annotation></phrase> <phrase><annotation type="tool">rights management</annotation></phrase> <phrase><annotation type="tool">queries</annotation></phrase> <phrase><annotation type="tool">query</annotation></phrase> <phrase><annotation type="tool">formatting language</annotation></phrase> <phrase><annotation type="tool">formatting languages</annotation></phrase></p>
<p>Roles</p>
<p><phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">content engineer</annotation></phrase> <phrase><annotation type="role">content engineers</annotation></phrase> <phrase><annotation type="role">content strategists</annotation></phrase> <phrase><annotation type="role">document designers</annotation></phrase> <phrase><annotation type="role">information architect</annotation></phrase> <phrase><annotation type="role">information architects</annotation></phrase> <phrase><annotation type="role">publication designers</annotation></phrase> <phrase><annotation type="role">subject matter experts</annotation></phrase></p>
<p>Companies</p>
<p><phrase><annotation type="company">Amazon</annotation></phrase> <phrase><annotation type="company">Narrative Science</annotation></phrase></p>
<p>Structures <phrase><annotation type="structure">cross references</annotation></phrase> <phrase><annotation type="structure">id</annotation></phrase> <phrase><annotation type="structure">ids</annotation></phrase> <phrase><annotation type="structure">index</annotation></phrase> <phrase><annotation type="structure">key</annotation></phrase> <phrase><annotation type="structure">keys</annotation></phrase> <phrase><annotation type="structure">list</annotation></phrase> <phrase><annotation type="structure">microformats</annotation></phrase> <phrase><annotation type="structure">subject annotation</annotation></phrase> <phrase><annotation type="structure">subject annotations</annotation></phrase> <phrase><annotation type="structure">table</annotation></phrase> <phrase><annotation type="structure">table of contents</annotation></phrase> <phrase><annotation type="structure">tables</annotation></phrase> <phrase><annotation type="structure">tables of contents</annotation></phrase> <phrase><annotation type="structure">cals table model</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> <phrase><annotation type="structure">rhetorical block</annotation></phrase> <phrase><annotation type="structure">rhetorical blocks</annotation></phrase> <phrase><annotation type="structure">semantic block</annotation></phrase> <phrase><annotation type="structure">semantic blocks</annotation></phrase> <phrase><annotation type="structure">topic</annotation></phrase> <phrase><annotation type="structure">topics</annotation></phrase> <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> <phrase><annotation type="structure">rhetorical pattern</annotation></phrase> <phrase><annotation type="structure">rhetorical structure</annotation></phrase></p>
<p>Standards (see also entries under languages, some of which are standards) <phrase><annotation type="standard">iso 1806</annotation></phrase> <phrase><annotation type="standard">s1000d</annotation></phrase></p>
<p>Programming languages</p>
<p><phrase><annotation type="programming-language">java</annotation></phrase> <phrase><annotation type="programming-language">javascript</annotation></phrase></p>
<p>Media</p>
<p><phrase><annotation type="media">paper</annotation></phrase> <phrase><annotation type="media">pdf</annotation></phrase> <phrase><annotation type="media">internet</annotation></phrase> <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="media">Web</annotation></phrase> <phrase><annotation type="media">web pages</annotation></phrase> <phrase><annotation type="media">tablet</annotation></phrase> <phrase><annotation type="media">online media</annotation></phrase> <phrase><annotation type="media">books</annotation></phrase></p>
</annotations>
<index>
<record>
<type>concept</type>
<term>information architecture</term>
</record>
<record>
<type>concept</type>
<term>bottom-up information architecture</term>
</record>
<record>
<type>concept</type>
<term>top-down information architecture</term>
</record>
</index>
<p>The overall goal of a content process it to create an effective information architecture. Information architecture is the arrangement of useful and effective content so that it can be found and navigated. An artful arrangement of awful content is of no good to anyone; information architecture is about both rhetoric and navigation.</p>
<p>The navigational aspects of information architecture deserve our particular attention, however. Artful content that on one can find does no good either. So far we have spoken about structured writing as a method for partitioning the complexity so that none of that complexity falls through to the reader. But finding the content you need is part of the complexity of the reader’s task, and information architecture is an attempt to transfer some of the complexity of information finding from the reader to the content provider.</p>
<p>But this dual nature of information architecture is often neglected. It is all too easy to think of it simply in terms of organizing things, but that can be a trap. An institution with a lot of content has its internal information finding problems to deal with, and often information architecture becomes an exercise in organizing the content for the convenience of the institution rather than the reader.</p>
<p>It is easy to think that organization is an absolute. Content is either organized or not. But this is not so. Organization is an orientation of content according to our knowledge and expectations. Things are organized for us if their location, or the means of retrieving them, match what we expect and know. But what the institution (and its staff) knows and expects is very different from what the reader knows and expects. What is organization for the institution can be chaos for the reader.</p>
<p>More than this, unless content follows an organizational scheme that the reader is already familiar with, or at least makes intuitive sense in terms of what they expect and know, few readers will be likely to spend much mental energy on trying to figure out a complex organizational scheme, even one that was designed with them in mind. Instead, they will <phrase><annotation type="concept" specifically="information foraging">forage for information</annotation></phrase>, which, in the Web world, means that they will use search and will follow links as long as they believe that the scent of the information they are looking for is growing stronger. (We discussed <phrase><annotation type="concept">information foraging</annotation></phrase> in <citation type = "nameref" value = "chapter.linking"/>. For a more in-depth treatment of <phrase><annotation type="concept">information foraging</annotation></phrase> and it implications for <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase>, see <phrase><annotation type="citetitle">Every Page is Page One: Topic-based writing for Technical Communication and the Web</annotation></phrase>.)</p>
<p>It is a mistake, therefore, to think of information architecture simply in terms of organization. A building supply store organizes building materials. An architect takes those materials and uses them to construct a navigable edifice full of useful spaces with efficient passages between them. The organization and standardization of materials provided by the building supply store is highly important to the architect in their work, but organization and standardization are just starting points for the unique and useful edifice that the architect will design and build.</p>
<p>And for this reason, content auqality is indispensible to informaton architecture. You can have good organization of bad material, but you cannot build a good edifice of bad material. The architect is concerned as much with the quality of their materials as they are with the design which integrates them. One does not work without the other. Information architecture is not, therefore, a wrapper around content, it is the union of rhetoric and navigation in a single discipline.</p>
<p>If there is a temptation to regard information architecture as merely a form of organization, its origins may lie in the past. For centuries, the basic unit of information was the book and the “architecture” of the book was an integral part of the responsibility of the writer and editor. Larger sets of information were created by collecting and organizing books and that was the responsibility of the librarian or bookseller.</p>
<p>Those larger collections were simply forms of organization. If there was an architecture at that scale it was in the expertise of the librarian or book seller to make inferences from the client’s needs and create useful connections.</p>
<p>With the advent of online media, first in the form of large capacity electronic media such as <phrase>CD-ROM</phrase>s and then the <phrase><annotation type="media">Internet</annotation></phrase> and the <phrase><annotation type="media">Web</annotation></phrase>, this division of responsibilities was overthrown. The basic unit of information in electronic media is not the book but the page. Thanks to <phrase><annotation type="media">hypertext</annotation></phrase> linking, the relationships between pages in electronic media are much more complex than on paper. Information architecture is a response to this challenge.</p>
<p>Information architect, therefore, is not merely a new name for librarian, but the integration of roles that were formerly divided, or, rather, the result of a very different partitioning of roles in the content process. I have spoken several times about partitioning certain forms of content complexity away from writers and directing it to information architects, but now we see that this is not just about relieving writers of a burden, it is also about giving the information architect the visibility into and control over rhetoric that they need to do their job. By no means does this transfer all control of rhetoric from writer to information architect, for the information architect does not have the intimate knowledge of the subject matter to define rhetorical best practices for every type of content. Rather it means that writer and information architect must work together to define and implement those best practices.</p>
<p>Another way in which things are different today is that the architecture of online media has to account for the ability to add, modify, and delete individual bits of content at any time. It is possible to think of book or library architectures in largely static terms. It is a serious mistake to think of Web architectures as static.</p>
<p>This leads to the development of architectures of much smaller units with much more complex relationships to a much larger, more diverse, and more rapidly changing set of resources. These architectures include not only text and static graphics but active media: videos, animation, and dynamic feeds and information widgets. Given these factors, the old separation of roles between writer and librarian no longer works. Unless we find a way to partition the responsibility away from them, writers now have to be much more conscious of how their pages interact with other pages in the collection, including those created by others. The scale at which these small pieces of content relate with each other is much greater than the scale at which the pieces of a book related to each other. This constitutes a significant increase in complexity (more, and more difficult, decisions requiring greater knowledge or skill) and calls for a whole new approach to information architecture, and for the appearance of a function and a role that had no equivalent in the paper world.</p>
<p>However, information architecture still needs to support paper delivery of content, and to ensure that the design of content delivered on paper is as effective as it can be. In many case, content delivered on paper will be the same content that was delivered on the Web and will come from the same repository. However, if the roles of writer and information architect have been partitioned to support Web output, responsibility for paper output is also likely to fall to the information architect, and structured writing algorithms such as <phrase><annotation type="algorithm">differential single sourcing</annotation></phrase> are likely to become an important part of the information architect’s concerns.</p>
<p>I have spoken at many points about structured writing, particularly in the <phrase><annotation type="concept">subject domain</annotation></phrase>, being used to transfer complexity from the writer to the <phrase><annotation type="role">information architect</annotation></phrase> or the <phrase><annotation type="role">content engineer</annotation></phrase>. It is the vast increase in the complexity of information architecture that makes this transfer necessary. But it also points out how much information needs to pass from the writer to the information architect for the information architect to do their job and not let any of the complexity slip through the cracks. Correct partitioning is essential to success in this area.</p>
<section>
<title>Top-down vs. bottom-up information architecture</title>
<p>How can structured writing structures and algorithms support information architecture? I’m going to start with making a basic distinction between two types of information architecture: <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> and <phrase><annotation type="concept" specifically="bottom-up information architecture">bottom-up</annotation></phrase>. Top down information architecture deals with navigational aids and organizing systems that stand apart from the content and point to it. A table of contents or a website menu system is a piece of top-down information architecture. Bottom-up information architecture deals with navigation and organization that exists within the content itself. A web site with a consistent approach to <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase> within its pages is an example of a bottom-up information architecture.</p>
<p>But <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> is not just about linking, it is about the way content is written. A page in a bottom-up information architecture is designed to be entered via search or links from almost anywhere (as opposed to being designed to be entered exclusively from a previous chapter). But it is also designed to help readers with onward navigation, to be a hub of its local subject space, offering readers many onward vectors according to their needs and interests.</p>
<p>This is a very different approach to information design because it unites rhetoric and navigation in a single design. Linking is not an afterthought, but part of the rhetorical design of the document. We are no longer dealing with an architecture in which navigation takes the reader to content and leaves them there. Navigation and rhetoric are intertwined and continuous, a design that is difficult to create and maintain without the use of structured writing.</p>
<p>I call this approach to information design <phrase><annotation type="concept">Every Page is Page One</annotation></phrase>, and it is described in my book, <phrase><annotation type="citetitle">Every Page is Page One: Topic-based Writing for Technical Communication and the Web</annotation></phrase>. One of the key principles of Every Page is Page One is that a <phrase><annotation type="structure">topic</annotation></phrase> should follow a well defined <phrase><annotation type="structure">rhetorical structure</annotation></phrase> or type. Structured writing, particularly <phrase><annotation type="concept">subject-domain</annotation></phrase> structured writing, is very useful in developing Every Page is Page One content.</p>
<p>Bottom-up and top-down information architectures are not incompatible with each other. In fact almost every information architecture has both top-down and bottom-up elements. (Books, for instance, which are principally top-down, based on a table of contents, may also have internal cross references, which are a bottom up mechanism.)</p>
<p>Structured writing can be used to drive both the <phrase><annotation type="concept" specifically="top-down information architecture">top-down</annotation></phrase> and <phrase><annotation type="concept" specifically="bottom-up information architecture">bottom-up</annotation></phrase> aspects of information architecture.</p>
</section>
<section>
<title>Categorization</title>
<p>One of the key elements of top-down information architecture is <phrase><annotation type="concept">categorization</annotation></phrase>. An <phrase><annotation type="role">information architect</annotation></phrase> develops categories of content and develops an organizational schema (such as a table of contents) based on those categories. This may include levels of subcategories forming a hierarchical categorization scheme.</p>
<p>Not all categorization is hierarchical, though. In some cases content can be classified on several independent axes, allowing for the development of what is called <phrase><annotation type="concept">faceted navigation</annotation></phrase>. The easiest place to see faceted navigation in action is on a used-car site where you can narrow down your selection using any set of criteria that matter to you, such as selecting blue convertibles or all-wheel drive vehicles with manual transmissions.</p>
<p>Categorization of content require metadata to identify which category it belongs to. (Even if you just sort papers into piles, as soon as you put a label on each pile, you are adding metadata, and if you don’t add a label, you will soon forget which pile is which.) Categorization may involve the addition of new metadata or it may rely on existing metadata that is already attached to the content. This effectively means that your categories are expressed as query statements, and those queries do not have to operate on a single piece of metadata. They can create a category out of the conjunction of several pieces of metadata. For example, they can create a category of heart healthy recipes by looking at the salt, fat, and calorie metadata of a collection of recipes.</p>
<p>For content in the <phrase><annotation type="concept">subject domain</annotation></phrase>, therefore, the <phrase><annotation type="concept">metadata</annotation></phrase> required to assign a piece of content to a category may be inherent in its subject domain markup. It is the nature of the subject domain to describe the subject matter and any markup that describes the subject matter may already contain the fields that you need for categorization. This is one of the attractions of the subject domain: the markup can serve many purposes, which simplifies both markup design and content authoring and often means that you don’t need to create additional structures to support a new algorithm.</p>
<p>Relying on the <phrase><annotation type="concept">subject domain</annotation></phrase> <phrase><annotation type="concept">metadata</annotation></phrase> already in the content, rather than creating a separate metadata record, can be a tremendous advantage, because it makes submission of content to a <phrase><annotation type="tool">repository</annotation></phrase> so much easier for authors. But in some cases it can also avoid the need for a costly <phrase><annotation type="tool">content management system</annotation></phrase>, since it allows the <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase> to categorize content at build time without the need of a separate metadata store or a separate system to manage categorization. I will look more at the role of the content management system in <citation type = "nameref" value = "chapter.management-domain"/>.</p>
</section>
<section>
<title>Linking</title>
<p>We have covered the <phrase><annotation type="algorithm">linking algorithm</annotation></phrase> already (<citation type = "nameref" value = "chapter.linking"/>), but linking is at the heart of a bottom up information architecture. In a bottom-up architecture, a page is not simply a leaf on a tree: the prize you find at the end of the search. It is a junction point in the exploration of an information space and the quest to understand a subject. In reading a page, a reader may discover new subjects that they need to understand and new options that they need to consider (<phrase><annotation type="concept">subject affinities</annotation></phrase> in the content). They may discover that what they thought they knew is wrong, or what they thought they wanted to do was not the right choice. They may find that their search or their traversal of the categorization system has led them to the wrong place, or they may discover whole new worlds they wish to explore. At a more mundane level, they may discover that they need additional information to complete their task, such as reference data.</p>
<p>These are all pointers to some next topic that the reader needs. Even the most prescient writer cannot have chosen all of them as the linear next topic in a linear narrative. To serve the reader they need to pave all of these possible paths for them, and the way you do that is with <phrase><annotation type="media">hypertext</annotation></phrase> <phrase><annotation type="structure">links</annotation></phrase>.</p>
<p>This means that linking is not something that happens at arbitrary points where the author feels like adding a link. It is something that is planned for as part of the <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase>. Whether you specify hard links in the <phrase><annotation type="concept">media domain</annotation></phrase> or the <phrase><annotation type="concept">document domain</annotation></phrase>, manage them with keys in the <phrase><annotation type="concept">management domain</annotation></phrase>, or generate them from <phrase><annotation type="structure">subject annotations</annotation></phrase> in the <phrase><annotation type="concept">subject domain</annotation></phrase>, they should be created in a disciplined and consistent manner according to a deliberate plan.</p>
</section>
<section>
<title>Tables of Contents</title>
<p><phrase><annotation type="structure">Tables of contents</annotation></phrase> can serve various purposes depending on the nature of the work. Some describe a linear reading order for a work, some provide a <phrase><annotation type="concept">classification</annotation></phrase> scheme for random access to the content, some are simply a list of chapters that does not necessarily imply an intended reading order.</p>
<p>A <phrase><annotation type="structure">table of contents</annotation></phrase> may seem like a <phrase><annotation type="concept">document domain</annotation></phrase> structure, but it is really more of a <phrase><annotation type="concept">media domain</annotation></phrase> structure, for two reasons. First, it contains specific links to specific resources at specific addresses, or specific page numbers in a paper or a virtual paper format such as <phrase><annotation type="media">PDF</annotation></phrase>. Secondly, it is virtually always factored out in <phrase><annotation type="concept">document domain</annotation></phrase> <phrase><annotation type="tool">markup languages</annotation></phrase>. Tables of contents are not written, they are generated.</p>
<p>From an <phrase><annotation type="algorithm" specifically="information architecture algorithm">information architecture</annotation></phrase> point of view, what matters is how they are generated. In <phrase><annotation type="language"><annotation type="standard">DocBook</annotation></annotation></phrase>, for instance, it is typical to write each chapter of a book in a separate <code>chapter</code> file and then pull them together into a book using a <code>book</code> file. The order of the table of contents is then determined by the order in which the chapters are listed in the <code>book</code> file. The TOC itself is generated by extracting chapter and section headings from the <code>chapter</code> files in the order they appear in the <code>book</code> file.</p>
<p>In <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase>, the normal process is to assemble a book using a <code>map</code> file. A map file may assemble a book out of <phrase><annotation type="language"><annotation type="standard">DITA</annotation></annotation></phrase> topics or other maps, and this may include assembling the chapters from topics as well. In the end, though, the <phrase><annotation type="structure">table of contents</annotation></phrase> is generated in the same way, by traversing the document assembled by the <code>map</code>.</p>
<p>In both these cases, the order of the TOC is specified by hand by the person who creates the <code>book</code> or <code>map</code> file. But there are other ways to determine the order of content in a TOC. For instance, a reference work such as an API reference may be organized by listing each library in order by name, and each function in alphabetical order by name within its library, creating a table of content with two levels. There is no need to write a map or book file to create this table of contents. There is an algorithm for creating this table of contents. In fact, it is the algorithm stated in the first sentence of this paragraph, “listing each library in order by name, and each function in alphabetical order by name within its library”. Here is that algorithm expressed in pseudo code:</p>
<codeblock language="pseudo">

create toc
    for each library sorted alphabetically
        create toc-entry library name
        for each function in library sorted alphabetically
            create toc-entry function name
</codeblock>
<p><phrase><annotation type="structure">Tables of contents</annotation></phrase> serve different purposes. Some describe a curriculum, a designed reading order. Others are simply a means of navigation, a way to select one topic out of a collection of many. If your content is written in the <phrase><annotation type="concept">subject domain</annotation></phrase>, the chances are that it already contains the structures on which such a classification could be based, and again the <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> can be generated based on the <phrase><annotation type="concept">metadata</annotation></phrase> already in the content.</p>
<p>One advantage of this approach is that if a <phrase><annotation type="structure" specifically="table of contents">TOC</annotation></phrase> is assembled based on <phrase><annotation type="concept">metadata</annotation></phrase> in the content, that means that when new content is added, it is automatically included in the TOC the next time output is generated. This simplifies the task of adding new content to a collection by avoiding the need to update multiple files or systems when a update occurs. This makes life easier for authors as they do not need to know how the TOC is constructed. They only have to create an individual piece of <phrase><annotation type="process" specifically="conformance">conforming</annotation></phrase> content and submit it to the right location. This also constitutes yet another example of the <phrase><annotation type="algorithm">avoiding duplication</annotation></phrase>, since the basis for the content’s inclusion at a particular point in the TOC is stored only in one place.</p>
</section>
<section>
<title>Lists</title>
<p>A major feature of a <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> is the <phrase><annotation type="structure">list</annotation></phrase>. Like <phrase><annotation type="structure">tables of contents</annotation></phrase>, lists are a catalog of resources. But while a TOC is a list of resources defined by their container (contents = things in a container) a list may have any principle of organization or inclusion.</p>
<p>For instance, you might want to have a list of all the movies starring each actor in a collection of movie reviews. Such a list is not only a useful piece of information, they are also an important aid for navigating around a site. Maintaining such a list by hand would be laborious and error prone, especially with new movies being added to the collection all the time.</p>
<p>If you have your movie reviews in a structured format that lists the actors in the movie in a format accessible to algorithms, like this:</p>
<codeblock language="sam">

movie: Rio Bravo
    starring:: actor
        John Wayne
        Dean Martin    
        Ricky Nelson    
        Angie Dickinson
        Walter Brennan
</codeblock>
<p>you can generate the filmographies for all your actors, like this:</p>
<codeblock language="pseudo">

create-filmographies
    for each unique actor in movie/starring/actor 
        create filmography named actor with link to actor
        for each movie where starring/actor = actor
            create entry named movie with link to movie
</codeblock>
<p>Tables of contents are a <phrase><annotation type="concept">top-down information architecture</annotation></phrase> device. You expect to find them at the top of the information set. List are a <phrase><annotation type="concept">bottom-up information architecture</annotation></phrase> device. You expect to find them as independent pages or as elements within a page. Thus if our collection includes the biographies of actors, and we want each biography to include the filmography, we can omit the filmography from the <phrase><annotation type="concept">subject domain</annotation></phrase> version of the biography and add it to the output in the <phrase><annotation type="algorithm">publishing algorithm</annotation></phrase>.</p>
<codeblock language="pseudo">

match actor-bio
    create html
        create h1 "Biography: " + actor-name
        continue
        create h2 "Filmography"
        for each movie-review where starring/actor = actor-name
            create li 
                create a with attribute href 
                 = address of movie-review
                    output movie-name
</codeblock>
<p>Note the close relationship between rhetoric and navigation here. The generated filmography is both content and navigation, both part of the individual topic and part of the overall navigation scheme – and example of how information architecture unites rhetoric and navigation.</p>
<p>It is also worth noting this kind of thing is a sophisticated example of the <phrase><annotation type="algorithm">reuse algorithm</annotation></phrase>. It takes a set of movies, each with a list of actors, and uses it to generate a list of movies for each actor, reusing existing information to create new content. This happens without any explicit reuse markup.</p>
</section>
<section>
<title>Personalized content</title>
<p>Another key feature of modern web architecture is personalized content, which means content that is generated in response either to what the site already knows about you (from your account information, or a transaction token such as a <phrase><annotation type="tool">cookie</annotation></phrase>, or the  selections or entries that you make on the page). For example, when you log into Amazon, the first page you see is crafted for you based on everything Amazon knows about your browsing and purchasing history. As you make selections, such as adding an item to your shopping cart or wish list, that information is used to shape the next page you see.</p>
<p>If you browse a used car site like Autotrader.com, you can select those features of a car that you are interested in (red convertibles with manual transmission under $20000, for instance) and the next page will be built based on that input.</p>
<p>The ability of a site to personalize pages depends on its ability to identify content that is <phrase><annotation type="algorithm" specifically="relevance">relevant</annotation></phrase>, based on everything it knows about the reader, and to assemble those pieces to form a page. For this to work, the content has to be easy to identify unambiguously, and it needs to be highly <phrase><annotation type="algorithm" specifically="composability">composable</annotation></phrase>.</p>
<p>As we have seen, these properties are maximized when content is stored in the <phrase><annotation type="concept">subject domain</annotation></phrase>, both because the <phrase><annotation type="concept">subject domain</annotation></phrase> makes the relevant <phrase><annotation type="concept">metadata</annotation></phrase> available, and because working in the <phrase><annotation type="concept">subject domain</annotation></phrase> helps authors produce more consistent content that works better with these algorithms.</p>
<p>The consistency of the content is most important in any personalized content application. There is no possibility for an author or editor to inspect the output of a personalized content publication before the reader sees it, since it is assembled in real time based on the unique things we know about each reader. This requires total confidence that:</p>
<ul>
<li>
<p>the content <phrase><annotation type="process" specifically="conformance">conforms</annotation></phrase> to its <phrase><annotation type="concept">constraints</annotation></phrase></p>
</li>
<li>
<p>those constraints are completely and correctly expressed by its <phrase><annotation type="tool">markup</annotation></phrase></p>
</li>
<li>
<p>the algorithm correctly processes and delivers the content</p>
</li>
</ul>
<p>All three of these requirements depend on the soundness and simplicity of the <phrase><annotation type="tool">markup</annotation></phrase> design. They require precise content structures with few alternatives, clear guidance for writers, and good <phrase><annotation type="algorithm">audit</annotation></phrase> capability. Without these properties, content and its markup will be inconsistent and reliable algorithms will be hard to write and test because of the wide variety of markup combination they may encounter.</p>
<p>Most personalized content applications model their content in relational database tables for these very reasons. However, with the correct markup design, almost certainly in the <phrase><annotation type="concept">subject domain</annotation></phrase>, there is no reason why you cannot use markup-based tools alone or in concert with database tools and solutions to achieve the same kind of thing.</p>
</section>
<section>
<title>Constraints enable processes</title>
<p>In the last few sections I have discussed the creation of the navigational elements that are a necessary part of an information architecture. But as I said at the beginning of the chapter, information architecture is bigger than this. It is the union of rhetoric and navigation. This means that while the information architect is responsible for the overall architecture, it is the writers who must execute every specific part of that that architecture, which makes information architecture a massively collaborative venture.</p>
<p>As we saw in <citation type = "nameref" value = "chapter.collaboration"/>, the key to successful collaboration is to use the right set of structures and constraints to limit the amount that individual contributors have to know about each other’s work. Writers and information architects need to collaborate face to face on the design of those structures and constraints so that the day to day work of creating and maintaining the information architecture can be carried out without an inordinate collaboration overhead.</p>
<p>In order to create a successful information architecture, therefore, it is necessary to partition this complexity so that writers can write their individual contribution confidently and correctly without requiring such comprehensive knowledge of the system and its contents. This kind of partitioning require a set of clear and precise constraints to govern the writer’s work and a set of sophisticated processes to <phrase><annotation type="algorithm">audit</annotation></phrase> and maintain the content and the content system over time.</p>
</section>
</chapter>
