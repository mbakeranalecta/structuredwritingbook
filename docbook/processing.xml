<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.processing"><db:title>Processing Structured Text</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp38234644"><db:primary>processing structured text</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp38234644x"><db:primary>task</db:primary><db:secondary>processing structured text</db:secondary></db:indexterm>




<db:para><db:xref linkend="chapter.separating"/> looked at separating content from formatting. Separating them is necessary to achieving certain rhetorical and process goals. But of course they cannot stay separated. Content must be formatted before you present it to the reader. So let’s look at the algorithm for putting them back together again.</db:para>
<db:para>Understanding how to put things back together is a big part of understanding how to separate them. Indeed, describing how you would put them back together is the only way to know for certain that you didn’t lose anything when you did the separation. This is essential to ensuring a clean partitioning that does not allow any complexity to fall through the cracks.</db:para>
<db:section>
<db:title>Two into one: reversing the factoring out of invariants</db:title>

<db:para>Moving content from the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain to the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain or the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain involves progressively factoring out invariants in the content. Each step in this process creates two artifacts: the structured content and the invariant piece that was factored out.</db:para>
<db:para>Processing structured text is about putting the pieces back together – combining the structured content with the invariants that were factored out. But processing structured text is also about making and/or executing the decisions that were partitioned away from the writer. These decisions may be invariant, such as applying approved corporate style, or they may be variable, such as presenting content differently in different media or for different audiences. Invariant decisions are always made the same way for a given purpose. They may be made differently for different purposes but still the same way for each purpose.</db:para>
<db:para>If factoring out the invariants moves content toward the document or subject domains, recombining the content with the invariants moves it in the opposite direction, toward the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain. This could mean moving the content from the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain to the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain or from the document domain to the media domain, or simply from a more abstract form in the media domain to a more concrete form, which is our first example.</db:para>

<?dbfo-need height="1.5in"?>

</db:section>
<db:section>
<db:title>Restoring style information</db:title>

<db:para>In <db:xref linkend="chapter.separating"/>, the first example of <db:indexterm><db:primary>separating content from formatting</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>separating content from formatting</db:secondary></db:indexterm>separating content from formatting factored out the style information from this structure:</db:para>
<db:programlisting>
{font: 10pt "Open Sans"}The box contains:
{font: 10pt "Open Sans"}[bullet][tab]Sand
{font: 10pt "Open Sans"}[bullet][tab]Eggs
{font: 10pt "Open Sans"}[bullet][tab]Gold
</db:programlisting>
<db:para>The style information was replaced with style names:</db:para>
<db:programlisting>
{style: paragraph}The box contains:
{style: bullet-paragraph}Sand
{style: bullet-paragraph}Eggs
{style: bullet-paragraph}Gold
</db:programlisting>
<db:para>And then the styles were defined as follows:</db:para>
<db:programlisting>
paragraph = {font: 10pt "Open Sans"}
bullet-paragraph = {font: 10pt "Open Sans"}[bullet][tab]
</db:programlisting>
<db:para>To unite each paragraph with the correct style, you can write a set of search-and-replace rules:</db:para>
<db:programlisting>
find {style: paragraph}
    replace {font: 10pt "Open Sans"}

find {style: bullet-paragraph}
    replace {font: 10pt "Open Sans"}[bullet][tab]
</db:programlisting>
<db:para>This algorithm combines two sources of information: the structured text and the style definitions. Usually, the style definitions are embedded in the rules, as in this example. In some cases, however, the rules may pull content from a separate file. I show examples of this later.</db:para>
<db:para>Applying these rules brings back the original content:</db:para>
<db:programlisting>
{font: 10pt "Open Sans"}The box contains:
{font: 10pt "Open Sans"}[bullet][tab]Sand
{font: 10pt "Open Sans"}[bullet][tab]Eggs
{font: 10pt "Open Sans"}[bullet][tab]Gold
</db:programlisting>

<?dbfo-need height="1in"?>

<db:para>If you want to change the styles, you can apply a different set of rules (in other words, make a different set of decisions):</db:para>
<db:programlisting>
find {style: paragraph}
    replace {font: 12pt "Century Schoolbook"}

find {style: bullet-paragraph}
    replace {font: 12pt "Century Schoolbook"}[em dash][tab]
</db:programlisting>
<db:para>Applying these new rules gives you the following:</db:para>
<db:programlisting>
{font: 12pt "Century Schoolbook"}The box contains:
{font: 12pt "Century Schoolbook"}[em dash][tab]Sand
{font: 12pt "Century Schoolbook"}[em dash][tab]Eggs
{font: 12pt "Century Schoolbook"}[em dash][tab]Gold
</db:programlisting>
</db:section>
<db:section>
<db:title>Rules based on structures</db:title>

<db:para>The tools that do this sort of processing do not literally use search and replace like this. Rather, they parse the source document to pull out the structures and allow you to specify your processing rules by referring to those structures.</db:para>
<db:para>The mechanism by which a processing tool recognizes structure is not our focus here. We are just going to tell it what to do when it finds a structure. So, the next set of rules match structures rather than looking for literal strings in the text:</db:para>
<db:programlisting>
match paragraph
    apply style {font: 12pt "Century Schoolbook"}

match bullet-paragraph
    apply style {font: 12pt "Century Schoolbook"}
    output "[em dash][tab]"
</db:programlisting>
<db:para>The result of applying these rules is the same as before:</db:para>
<db:programlisting>
{font: 12pt "Century Schoolbook"}The box contains:
{font: 12pt "Century Schoolbook"}[em dash][tab]Sand
{font: 12pt "Century Schoolbook"}[em dash][tab]Eggs
{font: 12pt "Century Schoolbook"}[em dash][tab]Gold
</db:programlisting>
<db:para>The way I have written these rules is an example of <db:indexterm><db:primary>pseudocode</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>pseudocode</db:secondary></db:indexterm>pseudocode. Pseudocode is a means for sketching out an algorithm so you understand what you are trying to do before you write actual code. There is no formal syntax for pseudocode. It is intended for humans, not computers, and you can use whatever approach you like as long as it is clear to your intended audience. However, pseudocode should lay out a set of logical steps for accomplishing something and make it clear how the steps go together.</db:para>
<db:para>Writing an algorithm in pseudocode is a great way to make sure you understand the algorithm without worrying about the details of code – or even learning how to code. And pseudocode algorithms are a great way to tell programmers what you need a program to do.</db:para>
</db:section>
<db:section>
<db:title>The order of the rules does not matter</db:title>

<db:para>You may have noticed that these rules do pretty much exactly what style sheets do in applications such as <db:indexterm><db:primary>Microsoft Word</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>Microsoft Word</db:secondary></db:indexterm>Word or <db:indexterm><db:primary>FrameMaker</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>FrameMaker</db:secondary></db:indexterm>FrameMaker. If you understand style sheets, you understand a good deal of how structured writing algorithms work.</db:para>
<db:para>One important thing to notice is that when you create a style sheet in <db:indexterm><db:primary>Microsoft Word</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>Microsoft Word</db:secondary></db:indexterm>Word or <db:indexterm><db:primary>FrameMaker</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>FrameMaker</db:secondary></db:indexterm>FrameMaker, you don’t specify the order in which styles are applied to the document. The same is true when you create a CSS style sheet. The style sheet is just a flat list of rules. The order in which the rules are applied to the document depends entirely on the order in which the various structures occur in the document.<db:footnote>
<db:para>Actually, there is a wrinkle to this. It is possible to have more than one rule that could match a particular structure. In this case the language in which the rules are implemented has to decide which rule to pick. There are various mechanism that a language can use to decide which rule to choose, for example, choosing a more specific rule over a more general one. But in some cases, the selection may be based simply on which rule comes first (or last) in the rule set. But this is a minor detail and does not distract from the idea that rules are fundamentally unordered and rule selection is  fundamentally document driven.</db:para>
</db:footnote></db:para>

<db:para>To put it another way, rather than being a set of steps to follow, style-sheet rules define a set of decisions to be made when certain events occur. If you see X, do Y. The structure of the source document determines the order in which the processor applies the rules; the order of the rules in the style sheet doesn’t matter.</db:para>
<db:para>This may seem obvious, but it is key to understanding how structured text is usually processed. This can be confusing even to skilled programmers, because style sheets are processed differently from the way most programmers learn to write computer programs.</db:para>
<db:para>Things get more complex when you move into processing the nested structures of the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain and <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, but the basic pattern of a set of unordered rules to describe a transformation algorithm still applies.</db:para>

<?dbfo-need height="1.5in"?>

</db:section>
<db:section>
<db:title>Applying rules in the document domain</db:title>

<db:para>Suppose you have a piece of document-domain structured text that contains this <db:code>title</db:code> structure:</db:para>
<db:programlisting language="sam">
title: Moby Dick
</db:programlisting>
<db:para>You want to transform this document into HTML. When a rule matches a structure in the source document, the processor outputs the equivalent HTML structure. Here is the pseudocode for this rule (it is in a slightly different format from the pseudocode above):</db:para>
<db:programlisting language="pseudo">
match title
    create h1 
        continue
</db:programlisting>
<db:para>This says, when the processor sees a <db:code>title</db:code> structure in the source, it creates an <db:code>h1</db:code> structure in the output and then continues applying rules to the content of the title structure.</db:para>
<db:para>The <db:code>continue</db:code> instruction is indented under the <db:code>create h1</db:code> instruction to indicate that the results will appear inside the <db:code>h1</db:code> structure. Another way of expressing this would be:</db:para>
<db:programlisting language="pseudo">
match title
    &lt;h1&gt;
        continue
    &lt;/h1&gt;
</db:programlisting>
<db:para>Again, it does not matter what form you use for your pseudocode as long as you clearly express the decision to make when the event in question occurs.</db:para>
<db:para>In this example, the processor outputs the text content of the structure automatically (as is the case in many tools), so the output of this rule (expressed in HTML) is:</db:para>
<db:programlisting language="html">
&lt;h1&gt;Moby Dick&lt;/h1&gt;
</db:programlisting>
<db:para>But suppose there is another structure inside the title? In this case that structure is an <db:indexterm><db:primary>annotation</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>annotation</db:secondary></db:indexterm>annotation of part of the title text:</db:para>
<db:programlisting language="sam">
title: Review of {Rio Bravo}(movie)
</db:programlisting>
<db:para>Here the annotated text is set off with curly braces and the annotation itself is in parentheses immediately after it. (This is a feature of the <db:indexterm><db:primary>SAM</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SAM</db:secondary></db:indexterm>SAM markup syntax that I use for most of the examples in this book.) This annotation says that the words <db:emphasis>Rio Bravo</db:emphasis> refer to a movie. The annotation is a content structure, just like the title structure, and is nested inside the text of the title.</db:para>
<db:para>So what do you need to do to your <db:code>title</db:code> rule to make it handle <db:code>movie</db:code> annotations embedded in the title text? Absolutely nothing. Instead, you write a separate rule for handling <db:code>movie</db:code> annotations no matter where they occur:</db:para>
<db:programlisting language="pseudo">
match movie
    create i
        continue
</db:programlisting>
<db:para>When the processor hits <db:code>continue</db:code> in the <db:code>title</db:code> rule, it processes the content of the title structure. In doing so, it encounters the <db:code>movie</db:code> structure and executes the <db:code>movie</db:code> rule. The result is output that looks like this:</db:para>
<db:programlisting language="html">
&lt;h1&gt;Review of &lt;i&gt;Rio Bravo&lt;/i&gt;&lt;/h1&gt;
</db:programlisting>
<db:para>The <db:code>continue</db:code> instruction is all you need to add to your rules to allow them to deal with nested structures. The rules remain an unordered collection, just like a style sheet. (In fact, <db:indexterm><db:primary>XSLT</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>XSLT</db:secondary></db:indexterm>XSLT, a language that implements this model, calls a set of processing rules a “stylesheet.”)</db:para>
</db:section>
<db:section>
<db:title>Processing based on context</db:title>

<db:para>When you move to the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, you use context to reduce the number of structures you need. For example, where <db:indexterm><db:primary>HTML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>HTML</db:secondary></db:indexterm>HTML has six different heading structures (<db:code>H1</db:code> through <db:code>H6</db:code>), <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook has only one (<db:code>title</db:code>), which can occur in many different contexts. So how do you apply the right formatting to a title based on its context? You create a different rule for the <db:code>title</db:code> structure in each context. You express the context by listing the parent structure names separated by slashes:</db:para>
<db:programlisting language="pseudo">
match book/title
    create h1 
        continue

match chapter/title
    create h2
        continue

match section/title
    create h3 
        continue

match figure/title
    create h4
        continue
</db:programlisting>
<db:para>Now here is the clever bit. You don’t have to change the <db:code>movie</db:code> rule to work with any of these versions of the <db:code>title</db:code> rule. Suppose your title is the title of a section, like this:</db:para>
<db:programlisting language="sam">
section:
    title: Review of {Rio Bravo}(movie)
</db:programlisting>
<db:para>When you process, the processor will execute the <db:code>section/title</db:code> rule to deal with the title structure and the <db:code>movie</db:code> rule when the <db:code>movie</db:code> structure occurs in the course of processing the content of the <db:code>title</db:code> structure. The results are as follows:</db:para>
<db:programlisting language="html">
&lt;h3&gt;Review of &lt;i&gt;Rio Bravo&lt;/i&gt;&lt;/h3&gt;
</db:programlisting>
<db:para>Here is the basic pattern for most structured writing algorithms:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>For each input structure, create a rule that says how to transform that structure into the new structure you want.</db:para>
</db:listitem>
<db:listitem>
<db:para>For each rule, specify the new structure(s) and where to place the content in the new structure(s).</db:para>
</db:listitem>
<db:listitem>
<db:para>For each rule, specify where to process any nested structures. I use the term <db:code>continue</db:code> for this function.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you want a different rule for a structure that occurs in different contexts, write a separate rule for each context.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Why is it important to understand this pattern? Because when you abstract out invariants to move content to the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain or <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, understanding how those invariants will be factored back in can help you recognize them in your source and give you the confidence to factor them out. Writing pseudocode helps you validate that you have factored out invariants correctly, that the structures are easy to process, and that the processing rules are clear, consistent, and reliable.</db:para>
<db:para>Obviously, building a complete processing system is much more complex, and I won’t go into all the details here, but let’s look at a few common cases.</db:para>
</db:section>
<db:section>
<db:title>Processing container structures</db:title>

<db:para>When you move content to the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain or the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, you often create container structures to provide context. These container structures have no media-domain analog, so what do you do with them when you publish? The containers provide context for the rest of your processing rules, but what do you do with the containers themselves?</db:para>
<db:para>In the previous example the content was contained in a <db:code>section</db:code> structure. So how does the <db:code>section</db:code> structure get processed?</db:para>
<db:programlisting language="pseudo">
match section
    continue
</db:programlisting>
<db:para>Yes, it’s that simple. You don’t output any new structure in its place. The section container has done its work at this point so you simply discard it. You still want what’s inside it, so you use the <db:code>continue</db:code> instruction to make sure the contents get processed. But the container is just a box; you unpack the contents and discard the box.</db:para>
</db:section>
<db:section>
<db:title>Restoring factored-out text</db:title>

<db:para>Sometimes when you factor out invariants, you not only factor out styles, you also factor out text. To process the content, you need to restore the text (obviously you can restore different text if you need to, which is why you factored it out in the first place).</db:para>
<db:para>As we saw in <db:xref linkend="chapter.separating"/>, a simple example of factoring out text is numbered and bulleted lists, where you factor out the text of the numbers and bullets. Let’s look at how you create rules to put them back.</db:para>
<db:para>Suppose you have a document that contains these two different kinds of lists:</db:para>
<db:programlisting>
paragraph: To wash hair:
ordered-list:
    list-item:Lather
    list-item:Rinse
    list-item:Repeat
    
paragraph: The box contains:
unordered-list:
    list-item:Sand
    list-item:Eggs
    list-item:Gold
</db:programlisting>
<db:para>Let’s write a set of rules to deal with this document. Converting this to HTML lists isn’t very interesting, since HTML handles list numbering and bullets itself. Instead, let’s create instructions for printing on paper. Real printing instructions get tediously detailed, so let’s use the same style specification shorthand used earlier. The <db:code>paragraph</db:code> rule is simple enough:</db:para>
<db:programlisting>
match paragraph
    apply style {font: 10pt "Century Schoolbook"}
    continue
</db:programlisting>
<db:para>Now let’s deal with the <db:code>ordered-list</db:code>. The ordered list structure is just a container, so you don’t need to create an output structure for it. But because this is an ordered list, you need to start a count to number the items in the list. That means you need a variable to store the current count. The <db:code>$</db:code> prefix indicates that you are creating a variable:</db:para>
<db:programlisting>
match ordered-list
    $count=1
    continue
</db:programlisting>
<db:para>Then, the rule for each ordered list item outputs the value of the variable <db:code>$count</db:code> and increments it by one:</db:para>
<db:programlisting>
match ordered-list/list-item
    apply style {font: 12pt "Century Schoolbook"}
    output $count
    output ".[tab]"
    $count=$count+1
    continue
</db:programlisting>
<db:para>Every time the <db:code>ordered-list/list-item</db:code> rule is executed, the count increases by one, numbering the list items sequentially.</db:para>
<db:para>When the processor encounters a new numbered list, it executes the <db:code>ordered-list</db:code> rule, which resets <db:code>$count</db:code> to 1.</db:para>
<db:para>This rule does not match <db:code>list-item</db:code> elements that are children of an <db:code>unordered-list</db:code> element, so you need a separate set of rules for unordered lists:</db:para>
<db:programlisting language="pseudocode">
match unordered-list
    continue
    
match ordered-list/list-item
    apply style {font: 12pt "Century Schoolbook"}
    output "[em dash][tab]"
    continue
</db:programlisting>
<db:para>Applying the combined set of rules produces output like this:</db:para>
<db:programlisting>
{font: 10pt "Century Schoolbook"}To wash hair:
{font: 10pt "Century Schoolbook"}1.[tab]Lather
{font: 10pt "Century Schoolbook"}2.[tab]Rinse
{font: 10pt "Century Schoolbook"}3.[tab]Repeat           
{font: 10pt "Century Schoolbook"}The box contains:
{font: 10pt "Century Schoolbook"}[em dash][tab]Sand
{font: 10pt "Century Schoolbook"}[em dash][tab]Eggs
{font: 10pt "Century Schoolbook"}[em dash][tab]Gold
</db:programlisting>
<db:para>This process flattens the structure and removes the document-domain containers. You are back in the media domain, with a flat structure that specifies formatting and text.</db:para>
</db:section>
<db:section>
<db:title>Processing in multiple steps</db:title>

<db:para>You may not always want to apply final formatting to your content in a single step. When you separated content from formatting, you did the separation in several stages. You may want to put them back together in several stages. This not only results in simpler, easier-to-maintain algorithms, it can make it possible for you to reuse some of the downstream steps (nearer the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain) for different types of <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain and <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain content.</db:para>
<db:para>So far the examples have come from the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain and the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain. Here is a <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain example that builds on <db:xref linkend="ex.separate-1"/>, which moved a labeled list from the document domain to the subject domain.</db:para>
<db:programlisting language="sam">
address:
    street: 123 Elm Street
    town: Smallville
    country: USA
    code: 12345
</db:programlisting>
<db:para>Moving this content back to the document domain should make it look like this:</db:para>
<db:programlisting language="sam">
labeled-list:
    list-item:
        label: Street
        contents: 123 Elm Street
    list-item:
        label: Town
        contents: Smallville
    list-item:
        label: Country
        contents: 123 USA
    list-item:
        label: Code
        contents: 12345
</db:programlisting>
<db:para>Here is the set of rules to accomplish this transformation:</db:para>
<db:programlisting>
match address
    create labeled-list
        continue
    
match street
    create list-item 
        create label 
            output "Street"
        create contents
            continue
                
match town
    create list-item 
        create label 
            output "Town"
        create contents
            continue

match country
    create list-item 
        create label 
            output "Country"
        create contents
            continue

match code
    create list-item 
        create label 
            output "Code"
        create contents
            continue
</db:programlisting>
<db:para>Notice that the label text, which you factored out when you moved to the subject domain, is being factored back in and is specified in the processing rules. As you moved the content from the media domain to the document domain to the subject domain, you first factored out invariant formatting and then invariant text. In the algorithms, you put back the text and the formatting, each at a different processing stage. (Or different label text, of course, if you want to change the presentation decisions.)</db:para>
<db:para>Processing content in multiple steps can save you a lot of time. The <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain <db:code>address</db:code> structure is specific to a single subject, and you might have similar structures for different subjects in your subject-domain markup. However, you might choose to present those different subjects using the same <db:code>labeled-list</db:code> structure. Since a labeled list is a <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain structure that can be used to present all kinds of information and formatted for many different media, you don’t have to write any code to format the <db:code>address</db:code> structure – or any of the similar structures – directly. You can format them all correctly for multiple media using the existing <db:code>labeled-list</db:code> formatting rules.</db:para>
</db:section>
<db:section>
<db:title>Query-based processing</db:title>

<db:para>The rule-based approach shown here is not the only way to process structured writing. There is another approach that I call the query-based approach.<db:footnote>
<db:para>The rule-based and query-based approaches are often called “push” and “pull” methods respectively, but I sometimes find it hard to remember which is which. I find rule-based and query-based more descriptive.</db:para>
</db:footnote> In this approach, you write a query expression that reaches into the structure of a document and pulls out a structure or a set of structures from the middle of the document.</db:para>
<db:para>This is a useful technique if you want to radically rearrange the content of a document or if you want to pull content out of one document to use in another. Any reference in these pages to using an algorithm to go through a content set and pull out certain pieces of data is an example of the query-based approach. You will see more examples of this in future chapters.</db:para>

<db:para>This chapter does not by any means describe the full range of available content processing techniques or all the ways in which algorithms can recognize and manipulate structures in content. The point of introducing structured writing algorithms and the basics of content processing is to enable you to think about structures with an eye to how they can be processed. Often when you look at structures in this way you can see how you can use a simpler structure and how that simpler structure can be processed to achieve the same result as a more complex structure.</db:para>
<db:para>Don’t be afraid to write out your algorithms in pseudocode to make sure you have a clear idea of the processing you intend for your structures, and don’t feel confined by the algorithms shown in this book or the annotation I use for pseudocode. You own your pseudocode. Choose a format that is clear to you and that communicates clearly to whoever will be implementing the actual code. Working together with that person can help you improve your appreciation of algorithms and your ability to write useful pseudocode.</db:para>
<db:para>Can learning to write real code help with this to? Absolutely it can. Is it necessary? No. What is essential is to think in terms of distributing certain parts of your content system to algorithms and to develop the ability to describe those algorithms and structures well enough that a programmer can implement them.</db:para>
<db:indexterm class="endofrange" startref="idp38234644"/><db:indexterm class="endofrange" startref="idp38234644x"/></db:section>
</db:chapter>
