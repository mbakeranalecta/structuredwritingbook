<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.collaboration"><db:title>Collaboration</db:title><db:indexterm class="startofrange" xml:id="idp1493290836"><db:primary>collaboration</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1493290836x"><db:primary>algorithms</db:primary><db:secondary>collaboration</db:secondary></db:indexterm>



<db:para>Many organizations produce large information sets that cannot be produced and maintained by a single person. Thus collaboration is required in producing and maintaining all that content. Collaboration is a difficult and complex process, and the more people you have trying to collaborate, the more complex it becomes. In other words the more you have to collaborate, the more you have to make decisions that affect or are affected by the work of others, and therefore the more information and skill you need to make these decisions.</db:para>
<db:para>As Tom Johnson writes:</db:para>
<db:blockquote>
<db:attribution>http://idratherbewriting.com/2016/12/14/higher-level-technical-writing/</db:attribution><db:para>So often we place the bar for contribution at whether someone can write. In reality, it’s not just whether someone can construct clear, grammatically correct sentences. It’s whether the person can integrate the information into a larger documentation set.</db:para>
</db:blockquote>
<db:para>And, of course, the larger the documentation set becomes, the more complex the task of integration becomes, to the point where it can quickly come to exclude the participation of anyone except full time writing staff that have been specifically trained in how to do it. How does each collaborator know what others are doing? How do they know which parts of the wider work they are responsible for? How do they integrate their work with the work of others? How do you manage the overhead created when collaborators have to be aware of other people’s work as well as their own? As always, any complexity that is not handled in the organization gets dumped on the reader in the form of quality and <db:indexterm><db:primary>findability</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>findability</db:secondary></db:indexterm>findability problems.</db:para>
<db:para>All of this militates against one of the main reasons organizations want to encourage collaboration in content creation, which it to allow subject matter experts to contribute content directly and in a <db:indexterm><db:primary>timely</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>timely</db:secondary></db:indexterm>timely fashion. The mechanisms of collaboration exclude the very people it was meant to include – or else the drop support for handling most of the other complexities of content creation and publication by simply creating an open space that lacks any kind of <db:indexterm><db:primary>rhetorical</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>rhetorical</db:secondary></db:indexterm>rhetorical or management constraints.</db:para>
<db:para>The fundamental constraint on collaboration is the amount of time that collaborators have to spend on collaborative activities – orienting themselves to the work of others – as opposed to creating new work. Unless you do something to ease this burden you quickly reach the point where adding more collaborators actually slows the project down because every new person you add to the project increases the collaboration overhead by more than the amount of work time they add to the project.</db:para>
<db:para>The essence of managing collaboration, therefore, is to minimize the amount of collaborative overhead in the system. In other words, you need to partition the work of collaborators sufficiently that the complexity of communication with other collaborators does not overwhelm the work to be done. But unless you do this in a way that allows all of the necessary coordination of work to get done, the unmanaged complexity gets dumped on the reader.</db:para>
<db:para>Before the Web, organizations handled the overhead of collaboration largely by assigning different books, pamphlets, and other publications to different writers and issuing them with some basic style guidance for language, physical appearance, and layout. All the other aspects of collaborative complexity, like making sure that everyone way saying the same thing at the same time in the same way, or that people were not creating the same content over and over again, or that at least one person was saying everything that needed to be said, were ignored and the results were dumped on the customer in the form of inconsistent information that was incomplete, incorrect, contradictory, and hard to find.</db:para>
<db:para>With the advent of the Web, all the same content, produced by the same non-collaborative approach to collaboration, got dumped onto the company website. It wasn’t necessarily any better or worse than it was before, but because it was now all <db:indexterm><db:primary>searchable</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>searchable</db:secondary></db:indexterm>searchable in one place, the <db:indexterm><db:primary>quality</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>quality</db:secondary></db:indexterm>quality problems became much more obvious. Early attempts to allow employees to post content to the Web arguably made things worse, since they combined a technically difficult process with a complete lack of constraints on <db:indexterm><db:primary>coverage</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>coverage</db:secondary></db:indexterm>coverage, <db:indexterm><db:primary>consistency</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>consistency</db:secondary></db:indexterm>consistency, or <db:indexterm><db:primary>style</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>style</db:secondary></db:indexterm>style. In response to this mess, the discipline of <db:indexterm><db:primary>content strategy</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>content strategy</db:secondary></db:indexterm>content strategy was born.</db:para>
<db:para>As always, we can address these problem by partitioning and redirecting the complexity to make sure that each part of the burden is placed on a person or process best able to handle it. Structured writing can help by enabling you to more effectively redistribute the complexity while reducing the amount that slips through the cracks.</db:para>
<db:para><db:indexterm><db:primary>Management-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>Management-domain</db:secondary></db:indexterm>Management-domain-oriented languages, such as <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA, move a lot of the complexity of <db:indexterm><db:primary>content management algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content management algorithm</db:secondary></db:indexterm>content management, and therefore of <db:indexterm><db:primary>collaboration</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>collaboration</db:secondary></db:indexterm>collaboration, into the source file in the form of <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain structures. If the writer is working directly in <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA, therefore, that complexity is transferred to the writer. In a collaborative situation, this means that that part of the burden is being transferred onto the collaborators, which means that it takes more time, discipline, skill, and knowledge to be an effective collaborator.</db:para>
<db:para>A well-designed <db:indexterm><db:primary>management-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management-domain</db:secondary></db:indexterm>management-domain system backed by well-designed tools my reduce the collaboration overhead compared to doing it add hoc, so this may be a step in the right direction, but it is still leaving a lot of the collaborative overhead on the writer’s plate and therefore the same basic limit on the effective scale of collaboration still apply, even if they have been pushed out a little. Alternative approaches can reduce the overhead further at all scales.</db:para>
<db:para>Part of the complexity of collaboration is the difference in skills, knowledge, and background between contributors. A good interface can correctly partition complexity for a collaborator, but with diverse users we need diverse interfaces that partition complexity in different way in accordance with the needs and capacities of their users.</db:para>
<db:para>Some of your contributors may be full time professional writers while others are engineers or marketers, field personnel or support people for whom communication is an important, but not central, part of their jobs. It makes perfect sense in these situations to design a collaborative system that distributes authoring complexity from your occasional contributors to your full time writers, or, better still, to your <db:indexterm><db:primary>information architects</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>information architects</db:secondary></db:indexterm>information architects and <db:indexterm><db:primary>content engineers</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>content engineers</db:secondary></db:indexterm>content engineers. People can handle far more complexity in their core task than then can in any of their peripheral tasks.</db:para>
<db:para>This kind of approach can be very fruitful, but it is not well supported by most off-the-shelf tools which essentially present the same interface to everyone. A structured writing approach in which different contributors use different structured writing languages, each best suited to their contributions, can be very effective. Of course, any use of structured writing distributes some degree of complexity towards the writer, since they are now obliged to know and follow the structure. On the other hand, this can also distribute a lot of complexity away from the writer. While the blank page may seem like the simplest possible interface, it actually give no task guidance at all. It is an interface without any <db:indexterm><db:primary>affordances</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>affordances</db:secondary></db:indexterm>affordances. It leaves it to every contributor not only to write, but to design the information they are creating, to decide what needs to be said and how to say it. Structured writing can provide this design information to the writer, thereby distributing the design complexity to the <db:indexterm><db:primary>information architect</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>information architect</db:secondary></db:indexterm>information architect who designs the structured writing language. What is vital here, though, is that the structured writing language not distribute any other complexity to the writer. Any language that requires them to master <db:indexterm><db:primary>publishing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publishing</db:secondary></db:indexterm>publishing or <db:indexterm><db:primary>content management algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content management algorithm</db:secondary></db:indexterm>content management concepts, for instance, is not going to work well for this purpose. What works is a simple <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain language the addresses the writer in terms they already understand and ask for annotations using concepts and ideas that the writer already knows.</db:para>
<db:para>One of the more common reasons for introducing <db:indexterm><db:primary>content management algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content management algorithm</db:secondary></db:indexterm>content management and/or structured writing to an organization is to improve collaboration. It is certainly not the only way to facilitate collaboration. In fact, the more common approach is to create simple and largely unstructured tools such as message boards and wikis. One of the most widely collaborative projects in the world – Wikipedia – runs on a wiki using a fairly simple document domain markup language which is often hidden behind a simple WYSIWYG editor.</db:para>
<db:para>This is powerful model for collaboration. Complexity does not require or even respond well to central top-down control (which essentially pushes more complexity to the center than anyone there has sufficient attention or knowledge to handle). But it is also a model that distributes almost all of the complexity to people rather than algorithms. There is simply not enough structure in this model to allow you to transfer very much complexity to an algorithm. Nor is there anyone making sure that all of the complexity is getting handled. The system relies as much for <db:indexterm><db:primary>auditing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>auditing</db:secondary></db:indexterm>auditing and <db:indexterm><db:primary>content management algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content management algorithm</db:secondary></db:indexterm>content management on the uncoordinated work of volunteers as it does for content creation.</db:para>
<db:para>Why then might one turn to a more complex structured writing system for collaboration. In a word: integration. The kind of collaboration that is supported by message boards and wikis is one in which collaboration chiefly means everybody being able to see what everyone else is doing. Any connections between the pieces created by different people are loose and non-critical, mostly taking the form of ad hoc <annotation type="media">hypertext</annotation> links. And such connections as there are are manged by large scale community efforts. Wikipedia is full of links between articles largely because anyone can go in an edit an article to add a link to an article on a related subject.</db:para>
<db:para>But not all collaboration can rely on such loose and uncoordinated activity. In many cases you need to bring the pieces created by collaborators together to form an integrated and cohesive whole. You can do that by hand, of course, but that can be cumbersome and time consuming. It may be hard for any one coordinator to keep up with all the content that is being created, especially if new content is continually being written, without any freeze period to allow the integration to take place.</db:para>
<db:para>Equally important, the collaborators on a message board or a larger wiki like Wikipedia are largely ignorant of each other and each other’s activity. Duplication of effort and even outright contradiction may be frequent. If you have huge numbers of volunteers constantly reading the site and finding duplication and contradictions, as Wikipedia does, you can live with this (though there will always be parts of the system that are in error at any give time). But an organization that is paying its writers and editors may not be able to afford this labor-intensive approach. It may need a more efficient way to coordinate the activity of its collaborators to avoid duplication and error. This means using structured writing to transfer a lot of that complexity and effort to algorithms.</db:para>
<db:section>
<db:title>Bridging silos</db:title>
<db:para>There is a lot of talk in <db:indexterm><db:primary>content management algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content management algorithm</db:secondary></db:indexterm>content management circles about breaking down <db:indexterm><db:primary>content silos</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>content silos</db:secondary></db:indexterm>content silos. The naive way to do this it to have everyone use a single system and a single markup language. But as we have seen, this means either adopting a simple <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain language that everyone can learn, like <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown, which does not have enough structures to meet everyone’s needs, or adopting a large complex document domain language like <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA or <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook that meets a lot of needs but has poor <db:indexterm><db:primary>functional lucidity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functional lucidity</db:secondary></db:indexterm>functional lucidity, especially for part-time contributors. It is a classic case of focusing on one problem and paying no attention to where the complexity that is directed away from that problem get dumped.</db:para>
<db:para>The most pernicious myth about collaboration is that it requires everyone to use the same tools and to understand each other’s work. In fact, this is the worst way to collaborate, because it creates a huge amount of overhead which can swamp the ability to actually get anything done. Efficient collaboration is actually achieved by limiting the amount that collaborators have to know about each other’s work and each other’s tools. This allows each group or individual to work efficiently while still creating a product that can be integrated successfully with the work of other.</db:para>
<db:para>This approach to collaboration is seen throughout the worlds of engineering and computer programming. The secret ingredient that allows workers to collaborate with minimal knowledge of each other’s work is the interface. A structured writing language is an interface to content creation. It works by partitioning and redirection the complexity of the content system.</db:para>
<db:para>To look at it another way, structured writing is a tool for partitioning and redirecting complexity in a content system. The examples we have examined so far in this book have looked at ways in which content decisions can be partitioned away from writers towards <db:indexterm><db:primary>document designers</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>document designers</db:secondary></db:indexterm>document designers, <db:indexterm><db:primary>content strategists</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>content strategists</db:secondary></db:indexterm>content strategists, <db:indexterm><db:primary>information architects</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>information architects</db:secondary></db:indexterm>information architects, and <db:indexterm><db:primary>content engineers</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>content engineers</db:secondary></db:indexterm>content engineers. But structured writing can also be used to partition decisions differently for different types of contributors, so that the interfaces they are asked to use are a good match for the kinds of decisions they are qualified to make, and shield them from those they are not qualified to make.</db:para>
<db:indexterm class="endofrange" startref="idp1493290836"/><db:indexterm class="endofrange" startref="idp1493290836x"/></db:section>
</db:chapter>
