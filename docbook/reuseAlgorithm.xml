<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.reuse"><db:title>Reuse</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp326755812"><db:primary>reuse</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp326755812x"><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idp326749924"><db:primary>content reuse</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp326749924x"><db:primary>concept</db:primary><db:secondary>content reuse</db:secondary></db:indexterm>




<db:para>Another source of complexity in content creation occurs when you want the same information to occur in more than one publication. If there is no coordination between writers, each writer who wants to include that piece of information will research and write it independently. Individual writers who want to use the same information in more than one publication will copy the information from one publication to another. However it happens, you now have two or more instances of the same information that you have to maintain and edit whenever the subject matter changes. If some instances do not get updated, or some of them get updated incorrectly, that is content maintenance complexity that is not being handled, and, as always, it falls through to the reader in the form of inconsistent or incorrect information.</db:para>
<db:para>Content reuse is an attempt to handle the complexity associated with using the same information in more than one place. Reuse has become one of the main drivers of structured writing, particularly with the widespread adoption of <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA. Unfortunately, most reuse techniques also introduce a lot of <db:indexterm><db:primary>management-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management-domain</db:secondary></db:indexterm>management-domain complexity. A single-minded focus on reuse has sometimes led to the implementation of systems that dump large amounts of complexity on writers.</db:para>
<db:para>Reuse is an area in which, if you are not careful, you can end up with more unhandled complexity in the system than when you began, resulting in both process problems and significant damage to rhetoric. Reuse is also an area in which process and rhetorical goals can easily be at odds; although using the same content for multiple purposes can deliver process benefits, it may not be the best rhetorical strategy.</db:para>
<db:para>It is important to remember that content reuse is a means for creating duplication in content. It eliminates duplication on the writing side, but it creates duplication on the output side. It is important to evaluate why you want that duplication at all and see if there are viable alternatives, such as publishing the information once and linking to it from various places. Here are some scenarios where you might want to duplicate information in more than one place:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>You are writing about different products that share common technology, and you want to duplicate information on the common features in the documents for each individual product.</db:para>
</db:listitem>
<db:listitem>
<db:para>You are writing about several different releases of a product, and you want information on features that have not changed to be duplicated in the documents for the next release.</db:para>
</db:listitem>
<db:listitem>
<db:para>You are writing documents for different audiences (marketing material, technical documentation for various roles, training material), and you want the same product descriptions in all these documents.</db:para>
</db:listitem>
<db:listitem>
<db:para>You are writing general information (e.g., copyright and trademark statements), and you want to duplicate that information in many different publications.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>The term <db:emphasis>reuse</db:emphasis> can suggest that this activity is akin to rummaging through that jar of old nuts and bolts you have in the garage looking for one that is the right size to fix your lawnmower. While you can do it that way, that approach is neither efficient nor reliable. The efficient and reliable approach involves deliberately creating content for duplication in multiple locations. This means that you need to place constraints on the content to be reused and the content that reuses it, and that means you are in the realm of structured writing.</db:para>
<db:section><db:title>Fitting pieces of content together</db:title>


<db:para>To create one piece of content that can be used in many outputs, you have to make sure it fits in each of those outputs. In other words, you have to partition it appropriately for reuse.</db:para>
<db:para>If you cut and paste, this is not a concern. You can cut any text you like, paste it in anywhere, and edit it to fit if you need to. But if the content you want to use is used in other places, you can’t edit it to fit because that might cause it to no longer fit in the other places. For reuse to work, the content must be written to fit in multiple places. In other words, it has to meet a set of constraints that ensure that it will fit in multiple places. I will look at this in more detail in <db:xref linkend="chapter.composition"/>. In this chapter I focus on the algorithms for fitting the pieces together.</db:para>
<db:para>There are seven basic models for fitting pieces of content together:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Common into variable</db:para>
</db:listitem>
<db:listitem>
<db:para>Variable into common</db:para>
</db:listitem>
<db:listitem>
<db:para>Variable into variable</db:para>
</db:listitem>
<db:listitem>
<db:para>Common with conditions</db:para>
</db:listitem>
<db:listitem>
<db:para>Factor out the common</db:para>
</db:listitem>
<db:listitem>
<db:para>Factor out the variable</db:para>
</db:listitem>
<db:listitem>
<db:para>Assemble from pieces</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section><db:title>Common into variable</db:title>


<db:para>In the common-into-variable case, you have a common piece of content that occurs in many places. The common content could occur in many documents, in many places in the same document, or both (see <db:xref linkend="fig.common2variable"/>).</db:para>
<db:figure xml:id="fig.common2variable"><db:title>Common-into-variable diagram</db:title><db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/common2variable.svg" contentwidth="4.25in" align="center"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/common2variable.png"/></db:imageobject><db:textobject><db:para>A diagram showing the common to variable reuse pattern.</db:para></db:textobject></db:mediaobject></db:figure>
<db:para>We looked at an example of this in <db:xref linkend="chapter.management-domain"/>, where we had a set of dangerous procedures which each required a standard warning. Each individual procedure is the variable part and the standard warning is the common part (see <db:xref linkend="fig.blow-stuff-up-sam"/>).</db:para>
<db:figure xml:id="fig.blow-stuff-up-sam"><db:title>Common-into-variable markup example</db:title><db:programlisting language="sam">
procedure: Blow stuff up
    &gt;&gt;&gt;(files/shared/admonitions/danger)
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.        
</db:programlisting></db:figure>
<db:para>To ensure that the included content will always fit, you need to make sure that there is a clear partitioning of responsibilities between the common content and each place it will be inserted into. In <db:xref linkend="fig.blow-stuff-up-sam"/>, the inserted content should be the safety warning, the whole safety warning, and nothing but the safety warning. The procedure structure should describe the steps and only the steps and should insert the reusable warning at the right place.</db:para>
<db:para>Of course, you can also use the subject-domain approach to common into variable that we looked at in <db:xref linkend="chapter.management-domain"/>. I will go into more detail on that approach later in this chapter.</db:para>
</db:section>
<db:section><db:title>Variable into common</db:title>


<db:para>In the variable-into-common case, you have a single document that will be output in many different ways by inserting variable content at certain locations (see <db:xref linkend="fig.variable2common"/>).</db:para>
<db:figure xml:id="fig.variable2common"><db:title>Variable-into-common diagram</db:title><db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/variable2common.svg" contentwidth="4.25in" align="center"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/variable2common.png"/></db:imageobject><db:textobject><db:para>Diagram showing the variable to common reuse pattern.</db:para></db:textobject></db:mediaobject></db:figure>
<db:para>For instance, if you are writing a manual to cover a number of car models, you can factor out the number of seats each model has.</db:para>
<db:programlisting language="sam">
The vehicle seats &gt;($seats) people.
</db:programlisting>
<db:para>This is the fixed content that will occur in all manuals, with the number of seats pulled in from an external source. Let’s say you have a collection of vehicle data that is stored in a structure like <db:xref linkend="fig.variable2common-sam"/>.</db:para>
<db:figure xml:id="fig.variable2common-sam"><db:title>Variable-into-common data structure example</db:title><db:programlisting language="sam">
vehicles:
    vehicle: compact
        seats: four
        colors: red, green, blue, white, black
        transmissions: manual, CVT
        doors: four
        horsepower: 120
        torque: 110 @ 3500 RPM
    vehicle: midsize
        seats: five
        colors: red, green, blue, white, black
        transmissions: CVT
        doors: four
        horsepower: 180
        torque: 160 @ 3500 RPM        
</db:programlisting></db:figure>
<db:para><db:xref linkend="fig.variable2common-pseudo"/> shows an algorithm that selects the correct insert by querying the structure in <db:xref linkend="fig.variable2common-sam"/>.</db:para>
<db:figure xml:id="fig.variable2common-pseudo"><db:title>Pseudocode for the variable-into-common algorithm</db:title><db:programlisting language="pseudo">
match insert where variable = $seats
    $number_of_seats = vehicles/vehicle[$model]/seats
    output $number_of_seats        
</db:programlisting></db:figure>
<db:para>Of course, the insert and query mechanism in <db:xref linkend="fig.variable2common-pseudo"/> is <db:indexterm><db:primary>pseudocode</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>pseudocode</db:secondary></db:indexterm>pseudocode. Exactly how things work and exactly how you delineate, identify, and insert content will vary from system to system.</db:para>
<db:para>With the variable-into-common technique, you create a common source by factoring out all the parts of the different outputs that are not common. This is, in some ways, the inverse of the usual pattern of factoring out invariants: you are actually factoring out the variants. But, really, it amounts to the same thing. You are factoring variants from invariants. The only real difference between this and the common-into-variable technique is whether the common parts are embedded in the variable parts or vice versa. Either way, you still end up with two artifacts: the variable piece or pieces and the common piece or pieces.</db:para>
</db:section>
<db:section><db:title>Variable into variable</db:title>


<db:para>Variable into variable is a variation on common into variable in which you select different common elements to pull into a set of variable documents.</db:para>
<db:para>For example, suppose you decide to sell your product line in a new market. The new market has different safety regulations, which means you need to insert a different standard warning into your manuals for that market. In this case, you want to swap out the common elements used in your home market and substitute the common elements for the foreign market (see <db:xref linkend="fig.variable2variable-diagram"/>).</db:para>
<db:figure xml:id="fig.variable2variable-diagram"><db:title>Variable-into-variable diagram</db:title><db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/variable2variable.svg" contentwidth="4.25in" align="center"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/variable2variable.png"/></db:imageobject><db:textobject><db:para>Diagram showing the variable to variable reuse pattern.</db:para></db:textobject></db:mediaobject></db:figure>
<db:para>In the common-into-variable example, you inserted the contents of a file that contained a standard warning. But for variable into variable, this approach does not work. Variable into variable requires you to load a different file for each market, but the content specifies a particular file name, making it difficult to select a different file for the new market.</db:para>
<db:para>As always in structured writing, you look for a way to factor out the problematic content. So here, you look for a way to factor out the file name and replace it with something else.</db:para>
<db:section><db:title>Using IDs</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp326793572"><db:primary>IDs</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp326793572x"><db:primary>concept</db:primary><db:secondary>IDs</db:secondary></db:indexterm>



<db:para>The most basic way to factor out the file name is to give the file an ID. An ID is a management-domain structure used to identify a piece of content in a location-independent way. No matter where the content is stored, it keeps the same ID. <db:xref linkend="fig.warning-danger-id"/> shows the warning file with the ID <db:code>#warn_danger</db:code> added.</db:para>
<db:figure xml:id="fig.warning-danger-id"><db:title>Danger warning with an ID added</db:title><db:programlisting language="sam">
warning:(#warn_danger) 
    title: Danger
    
    Be very very careful. This could kill you.
</db:programlisting></db:figure>
<db:para>You can then insert the warning into your procedure by referring to that ID (see <db:xref linkend="fig.warning-danger-ref"/>).</db:para>
<db:figure xml:id="fig.warning-danger-ref"><db:title>Procedure that refers to a warning using an ID</db:title><db:programlisting language="sam">
procedure: Blow stuff up
    &gt;&gt;&gt;(#warn_danger)
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting></db:figure>
<db:para>The decision about which warning to include has been shifted from the writer to the algorithm in <db:xref linkend="fig.warning-danger-pseudo"/>.</db:para>
<db:figure xml:id="fig.warning-danger-pseudo"><db:title>Pseudocode to locate a warning using its ID</db:title><db:programlisting language="pseudo">
match insert with ID
    $insert_content = find ID in $content_set
    output $insert_content
</db:programlisting></db:figure>
<db:para>This is a constant pattern in structured writing. When it comes to choosing and locating resources, you want to move that responsibility from the writer to the algorithm, which means moving the identity of the resource out of the content and into the algorithm. This makes it easier to update locations, but it also gives you far more options for storing and managing your content, since algorithms can interact with a variety of systems in sophisticated ways, rather than just storing a static address. It also means you can make wholesale changes in how your content is stored without having to edit the content itself. This is a major win in terms of partitioning complexity so it can be distributed and handled more efficiently.</db:para>
<db:para>This method requires that the algorithm have a way to resolve the ID and find the content to include. In many cases, a <db:indexterm><db:primary>content management system</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>content management system</db:secondary></db:indexterm>content management system can resolve the ID. In other cases, you can do something as simple as having the algorithm search through a set of files to find the ID or building a catalog that points to the files that contain content with IDs.</db:para>
<db:para>To do variable-into-variable reuse in a system that uses IDs, you maintain a separate set of files that contain the variable content for each market. Each set uses the same IDs but different content. You simply point the <db:indexterm><db:primary>algorithm</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>algorithm</db:secondary></db:indexterm>algorithm at the set for the market you are generating output for. So if your foreign market requires a different warning, you can create a file that contains the message shown in <db:xref linkend="fig.warning-danger-id-2"/>.</db:para>
<db:figure xml:id="fig.warning-danger-id-2"><db:title>Alternate warning message for a different market</db:title><db:programlisting language="sam">
warning:(#warn_danger) 
    title: Look out!
    
    Pay close attention. You could really hurt yourself.            
</db:programlisting></db:figure>
<db:para>By telling the algorithm that builds the foreign market docs to search this file for IDs, rather than the file with the domestic market warning, you automatically get the foreign warning rather than the domestic one.</db:para>
<db:indexterm class="endofrange" startref="idp326793572"/><db:indexterm class="endofrange" startref="idp326793572x"/></db:section>
<db:section><db:title>Using keys</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp326807652"><db:primary>keys</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp326807652x"><db:primary>concept</db:primary><db:secondary>keys</db:secondary></db:indexterm>



<db:para>Another way to do this is with another <db:indexterm><db:primary>management-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management-domain</db:secondary></db:indexterm>management-domain structure called a <db:emphasis>key</db:emphasis>. A key is similar to an ID, but it is not directly tied to a resource. Instead, the same key can point to different resources at different times. Since a key does not represent any one concrete resource, you don’t assign the key to a resource. Instead, you use an intermediate lookup table to resolve keys to particular resources for a particular purpose.</db:para>
<db:para>Suppose you have the warning in a file called <db:code>files/shared/admonitions/domestic/danger</db:code> with the content shown in <db:xref linkend="fig.variable2variable-key-1"/> (no ID):</db:para>
<db:figure xml:id="fig.variable2variable-key-1"><db:title>Warning content in a key-based system</db:title><db:programlisting language="sam">
warning: 
    title: Danger

    Be very very careful. This could kill you.            
</db:programlisting></db:figure>

<?dbfo-need height="1.5in"?>

<db:para><db:xref linkend="fig.variable2variable-key-2"/> shows a procedure that includes the warning using the key <db:code>%warn_danger</db:code>.</db:para>
<db:figure xml:id="fig.variable2variable-key-2"><db:title>Procedure that includes a warning using key-based linking</db:title><db:programlisting language="sam">
procedure: Blow stuff up
    &gt;&gt;&gt;(%warn_danger)
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting></db:figure>
<db:para>(These examples use <db:code>#</db:code> to denote IDs and <db:code>%</db:code> to denote keys. This is the notation that <db:indexterm><db:primary>SAM</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SAM</db:secondary></db:indexterm>SAM uses for IDs and keys, but it is purely arbitrary and has nothing to do with how they work. Different systems denote IDs and keys in different ways.)</db:para>
<db:para>To connect the key to the warning file, you create a key lookup table (see <db:xref linkend="fig.variable2variable-key-3"/>).</db:para>
<db:figure xml:id="fig.variable2variable-key-3"><db:title>Key lookup table</db:title><db:programlisting language="sam">
keys:
    key:
        name: warn_danger
        resource: files/shared/admonitions/domestic/danger            
</db:programlisting></db:figure>
<db:para>When the algorithm in <db:xref linkend="fig.variable2variable-key-4"/> processes the procedure, it sees the key reference <db:code>%warn_danger</db:code> and looks it up in the key lookup table. The key lookup table tells the algorithm that the key resolves to the resource <db:code>files/shared/admonitions/domestic/danger</db:code>. The algorithm then loads that file and inserts the contents into the output.</db:para>
<db:figure xml:id="fig.variable2variable-key-4"><db:title>Pseudocode for the key lookup algorithm</db:title><db:programlisting language="pseudo">
match insert with key
    $resource = find key in lookup-table
    output $resource            
</db:programlisting></db:figure>
<db:para>To output your content for the foreign market, you prepare a new key lookup table (see <db:xref linkend="fig.variable2variable-key-5"/>) and tell the algorithm to use this table instead.</db:para>
<db:figure xml:id="fig.variable2variable-key-5"><db:title>Key lookup table for a new market</db:title><db:programlisting language="sam">
keys:
    key:
        name: warn_danger
        resource: files/shared/admonitions/foreign/danger            
</db:programlisting></db:figure>
<db:para>Using keys is not necessarily better than using IDs. What it comes down to is that you need some kind of bridge between the citation of an identifier in the source file and the location of a resource with that identifier in the content store. This bridge can be created by a key lookup table, by remapping file URLs, or by modifying a query to a content repository.</db:para>
<db:para>One advantage of keys is that, because you don’t attach the key directly to the content, you can use a key to identify resources that don’t have IDs, including resources you don’t control.</db:para>
<db:para>One downside of keys is that, by themselves, they can only point to a whole resource. This can force you to keep your reusable units in separate files. To avoid this, you can combine keys with IDs. <db:xref linkend="fig.variable2variable-key-6"/> combines both danger warnings into one file and gives each an ID.</db:para>
<db:figure xml:id="fig.variable2variable-key-6"><db:title>Keys and IDs combined</db:title><db:programlisting language="sam">
warnings:
    warning:(#warn_danger_domestic) 
        title: Danger
    
        Be very very careful. This could kill you.

    warning:(#warn_danger_foreign) 
        title: Look out!
        
        Pay close attention. You could really hurt yourself.
</db:programlisting></db:figure>
<db:para>Now you can rewrite your key lookup tables to use IDs to pull the right warning out of the common file. Then you can use a key lookup table like <db:xref linkend="fig.variable2variable-key-7"/> for the domestic build and <db:xref linkend="fig.variable2variable-key-8"/> for the foreign build.</db:para>
<db:figure xml:id="fig.variable2variable-key-7"><db:title>Key lookup table with ID for domestic market</db:title><db:programlisting language="sam">
keys:
    key:
        name: warn_danger
        resource: files/shared/warnings#warn_danger_domestic
</db:programlisting></db:figure>
<db:figure xml:id="fig.variable2variable-key-8"><db:title>Key lookup table with ID for foreign market</db:title><db:programlisting language="sam">
keys:
    key:
        name: warn_danger
        resource: files/shared/warnings#warn_danger_foreign
</db:programlisting></db:figure>
<db:para>This method partitions the warnings into separate files and also partitions the location of those files from the writer. Using keys as a bridge between two partitions can be a convenient way to manage content relationships without having to update source files every time the relationships change.</db:para>
<db:para>The downside is that keys introduce an abstract element into the writer’s world, and abstractions are a form of complexity that can be difficult to deal with. Instead of deciding which warning to use, writers have to decide which key or ID to use. However, that decision is not necessarily easier to make, and it requires more system knowledge and a more abstract way of thinking than the original decision that was factored out. Keys and IDs abstract out the actual act of inclusion, but that is the least complex part of ensuring that the standard warning is used.</db:para>
<db:indexterm class="endofrange" startref="idp326807652"/><db:indexterm class="endofrange" startref="idp326807652x"/></db:section>
</db:section>
<db:section><db:title>Common with conditions</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp323747668"><db:primary>conditions</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp323747668x"><db:primary>concept</db:primary><db:secondary>conditions</db:secondary></db:indexterm>



<db:para>In some implementations of the variable-into-common approach, the variant pieces are not factored out into a separate file. Rather, each of the possible alternatives is included in the file conditionally (see <db:xref linkend="fig.commonconditions-diagram"/>).</db:para>
<db:figure xml:id="fig.commonconditions-diagram"><db:title>Common-with-conditions diagram</db:title><db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/commonconditions.svg" contentwidth="4.25in" align="center"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/commonconditions.png"/></db:imageobject><db:textobject><db:para>Diagram of the common with conditions reuse pattern.</db:para></db:textobject></db:mediaobject></db:figure>
<db:para>For instance, in content for a car manual you might have conditional text for the number of people the car seats.</db:para>
<db:programlisting language="sam">
The vehicle seats {four}(?compact){five}(?midsize){seven}(?van).
</db:programlisting>
<db:para>Here the main text is the fixed piece and the variable pieces are the words “four,” “five,” and “seven.” Which of these will be included in the output depends on which condition is applied during the build. If the condition <db:code>midsize</db:code> is applied, then the output text will be “five” and the other alternatives will be suppressed. <db:xref linkend="fig.commonconditions-pseudo"/> shows this algorithm.</db:para>
<db:figure xml:id="fig.commonconditions-pseudo"><db:title>Pseudocode for the common-with-conditions algorithm</db:title><db:programlisting language="pseudo">
match phrase with condition
    if condition in $build_conditions
        continue
    else
        ignore        
</db:programlisting></db:figure>
<db:para>The upside of the conditional approach is that it keeps all the variants in one file, so your algorithm does not have to know where to go to find the external content. But there are downsides to this approach:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>It gets cumbersome to read the source if you apply many different conditions.</db:para>
</db:listitem>
<db:listitem>
<db:para>When the subject matter changes, you have to find all the places where conditions occur and update them.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you refer to the same data point (the number of seats) in many different documents, that information is still being duplicated all over the content, which makes it hard to maintain, verify, or change if, for example, the compact seats five in the next model year.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Common with conditions is not limited to cases where there are alternate values, however. In some cases, content may simply be inserted or omitted for certain outputs (see <db:xref linkend="fig.commonconditions-sam"/>).</db:para>
<db:figure xml:id="fig.commonconditions-sam"><db:title>Common with conditions used for optional content</db:title><db:programlisting language="sam">
The main features of the car are:            

ol:
    li: Wheels
    li: Steering wheel
    li:(?deluxe) Leather seats
    li: Mud flaps        
</db:programlisting></db:figure>
<db:para>In this case, the list item “Leather seats” is only published if you specify the condition <db:code>deluxe</db:code> in the build. It would be omitted for all other builds. In cases like this, it is hard to avoid using conditionals as a reuse mechanism.</db:para>
<db:para>This approach to reuse is often called filtering or profiling. Some systems have more elaborate ways of specifying filtering or profiling. The net effect is the same as the simple condition tokens shown in this section, but such systems may allow for more sophisticated conditions.</db:para>
<db:para>Because common with conditions is essentially a form of variable into common where the variable content is contained inside the common source, it can technically be replaced by a variable-into-common approach in all cases. In practice, conditions are typically used in the following cases:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The number of variations is small and thought to be fixed or to change infrequently.</db:para>
</db:listitem>
<db:listitem>
<db:para>The variable pieces are eccentric or contextually dependent.</db:para>
</db:listitem>
<db:listitem>
<db:para>The writer or organization wishes to avoid managing multiple files.</db:para>
</db:listitem>
<db:listitem>
<db:para>The current tools don’t support variable into common.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>How successful a common-with-conditions approach will be also depends on what you choose for your conditional expressions. Generally, subject-domain conditions will be more stable and manageable than document-domain conditions. For instance, conditions that relate to different vehicles (subject domain) are based in the real world and are, therefore, objectively true as long as the subject matter remains the same. Conditions that relate to different publications or different media, on the other hand, are not objectively true and can’t be verified independently. The only way to verify them is to build the different documents or media and see if you get the content you expected. This makes maintaining such conditions cumbersome and error prone – an indication that complexity is not being distributed in an optimal way.</db:para>
<db:indexterm class="endofrange" startref="idp323747668"/><db:indexterm class="endofrange" startref="idp323747668x"/></db:section>
<db:section><db:title>Factor out the common</db:title>


<db:para>In <db:xref linkend="chapter.management-domain"/>, I noted that the subject-domain alternative to using an insertion instruction for the warning text was to specify which procedures were dangerous, thus factoring out the constraint that the warning must appear (see <db:xref linkend="fig.factor-out-common-sam"/>).</db:para>
<db:figure xml:id="fig.factor-out-common-sam"><db:title>Procedure that factors out explicit inclusions</db:title><db:programlisting language="sam">
procedure: Blow stuff up
    is-it-dangerous: yes
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting></db:figure>
<db:para>In this case, writers do not have to identify the material to be included, either directly by file name or indirectly through an <db:indexterm><db:primary>ID</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>ID</db:secondary></db:indexterm>ID or a key. Instead, it is up to the algorithm to include it (see <db:xref linkend="fig.factor-out-common-pseudo"/>).</db:para>
<db:figure xml:id="fig.factor-out-common-pseudo"><db:title>Pseudocode for the factor-out-the-common algorithm</db:title><db:programlisting language="pseudo">
match procedure/is-it-dangerous 
    if is-it-dangerous = 'yes'
        output files/shared/warnings#warn_danger_domestic
</db:programlisting></db:figure>
<db:para>To produce the foreign market version of the documentation, you simply edit the rule, as shown in <db:xref linkend="fig.factor-out-common-pseudo-2"/>.</db:para>
<db:figure xml:id="fig.factor-out-common-pseudo-2"><db:title>Pseudocode for an alternative warning using the factor-out-the-common algorithm</db:title><db:programlisting language="pseudo">
match procedure/is-it-dangerous 
    if is-it-dangerous = 'yes'
        output files/shared/warnings#warn_danger_foreign
</db:programlisting></db:figure>
<db:para>Or, to further partition complexity in the code, you can use keys, as shown in <db:xref linkend="fig.factor-out-common-pseudo-3"/>.</db:para>
<db:figure xml:id="fig.factor-out-common-pseudo-3"><db:title>Pseudocode for the factor-out-the-common algorithm using keys</db:title><db:programlisting language="pseudo">
match procedure/is-it-dangerous 
    if is-it-dangerous = 'yes'
        $resource = find key '%warn_danger' in lookup-table
        output $resource      
</db:programlisting></db:figure>
<db:para>The beauty of this approach is that the content is entirely neutral as to what kind of reuse is going on or how dangerous procedures are treated. Because the content contains only objective information about the procedure itself, you can implement any publish or reuse algorithm you like – in any way you like and at any time. Because the content does not specify any form of reuse or any reuse mechanism, you have made it more reusable and partitioned the complexity of reuse much more neatly and reliably.</db:para>
<db:para>This approach also makes the content much easier to write, since it does not require writers to know how the reuse mechanism works, how to identify reusable content, or even that reuse is occurring at all. All they have to do is answer a simple question about the content that they should know the answer to: is the procedure dangerous or not.</db:para>
<db:para>This approach partitions the entire reuse mechanism away from writers. This is a big win because the biggest problem with most reuse techniques is the amount of complexity they add for writers, which directly compromises their finite and valuable attention.</db:para>
<db:para>This is important from the point of view of both complexity and cost. Whenever writers are asked to consciously reuse content, they have to look for that content every time the potential for reuse occurs. This cost is incurred whether or not they find reusable content, whereas any savings from reuse are realized only when reusable content is found.</db:para>
<db:para>The factor-out-the-common approach relieves writers of all responsibility for the reusable content. Locating reusable content is the job of an algorithm. If the content does not exist, the algorithm will report that it is missing, and it will be somebody’s job to create it, after which the algorithm will locate it automatically every time it is needed. This is far more efficient than having writers look for reusable content over and over and over.</db:para>
<db:para>The downside of this approach is that it is not as general. The <db:code>is-it-dangerous</db:code> metadata applies only to dangerous procedures. It does not address the inclusion of reusable content in other places. You would need to factor out other interesting reuse cases in a similar way to create a complete subject-domain solution. Again, we see that complexity always has to go somewhere. But as we have also seen, if writers cannot fully handle the complexity thrust on them, that complexity goes unhandled, with consequences for both process and rhetoric.</db:para>
</db:section>
<db:section><db:title>Factor out the variable</db:title>


<db:para>You can also factor out the variable content. In the case of the different models of a car, rather than conditionalizing the list of features in the document, you can maintain the list in a database. The organization probably already has a database of features for each vehicle, so you don’t need to create anything new. Instead, you simply query the existing database. After all, reusing what already exists is what reuse is all about.</db:para>

<?dbfo-need height="2in"?>

<db:para>For example, instead of including the feature list, as shown in <db:xref linkend="fig.factor-out-variable-sam"/>, you can factor out the list entirely, as shown in <db:xref linkend="fig.factor-out-variable-db"/>.</db:para>
<db:figure xml:id="fig.factor-out-variable-sam"><db:title>Conditionalized feature list</db:title><db:programlisting language="sam">
The main features of the car are:
            
ol:
    li: Wheels
    li: Steering wheel
    li:(?deluxe) Leather seats
    li: Mud flaps        
</db:programlisting></db:figure>
<db:figure xml:id="fig.factor-out-variable-db"><db:title>Factored-out feature list</db:title><db:programlisting language="sam">
The main features of the car are:
            
&gt;&gt;&gt;(%main_features)
</db:programlisting></db:figure>
<db:para>Now, your algorithm looks like <db:xref linkend="fig.factor-out-variable-pseudo"/>.</db:para>
<db:figure xml:id="fig.factor-out-variable-pseudo"><db:title>Pseudocode for the factor-out-the-variable approach</db:title><db:programlisting language="pseudo">
match insert with key
    $resource = lookup key in lookup-table
    output $resource        
</db:programlisting></db:figure>
<db:para>You then have a key lookup table where the resource is identified by a query on the database (<db:xref linkend="fig.factor-out-variable-query"/>).</db:para>
<db:figure xml:id="fig.factor-out-variable-query"><db:title>Key lookup table for the factor-out-the-variable approach</db:title><db:programlisting language="sam">
keys:
    key:
        name: %main-features
        resource: from vehicles select features where model = $model        
</db:programlisting></db:figure>
<db:para>This query retrieves a different set of features from the database depending on how the variable <db:code>$model</db:code> is defined for the build. Launch the build with <db:code>$model = 'compact'</db:code> and you get the feature set for the compact model. Launch the build with <db:code>$model = 'van'</db:code> and you get the feature set for the van model.</db:para>
<db:para>Naturally, this leaves out a lot of detail about how this query gets executed and how the results get structured into a <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain list structure. But those are implementation details.</db:para>
</db:section>
<db:section><db:title>Assemble from pieces</db:title>


<db:para>In the assemble-from-pieces approach, there is no common vs. variable distinction and no single source document into which you insert reused content or apply conditions. Instead, you assemble a set of content units to form a finished document (see <db:xref linkend="fig.assemble-diagram"/>).</db:para>
<db:figure xml:id="fig.assemble-diagram"><db:title>Assemble-from-pieces diagram</db:title><db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/assemble.svg" contentwidth="4.25in" align="center"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/assemble.png"/></db:imageobject><db:textobject><db:para>A diagram showing multiple pieces being combined in different ways to produce different outputs.</db:para></db:textobject></db:mediaobject></db:figure>
<db:para>For example, if you have a range of products with common features, you might assemble the documentation for those products using a common introduction followed by a piece representing each feature of each model. This piece could be a flat list, or it could be a tree structure. For instance, you might assemble a chapter of a manual with an introductory piece and then several sections below it in the tree, as shown in <db:xref linkend="fig.assemble-tree"/>.</db:para>
<db:figure xml:id="fig.assemble-tree"><db:title>Assemble-from-pieces tree structure</db:title><db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/tree.svg" contentwidth="2in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/tree.png"/></db:imageobject><db:textobject><db:para>A diagram showing the tree structure of a book.</db:para></db:textobject></db:mediaobject></db:figure>
<db:para>The assembly approach requires a structure to describe how the units are assembled. This structure is often called map. (It is called a map in <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA, for instance.) Some applications refer to it as a table of contents. <db:xref linkend="fig.assemble-map"/> is an example of a map.</db:para>
<db:figure xml:id="fig.assemble-map"><db:title>Assemble-from-pieces map</db:title><db:programlisting language="sam">
map: Widget Wrangler Deluxe User Manual
   unit: units/ww/deluxe/intro
       unit: units/ww/shared/basic_features
       unit: units/ww/deluxe/deluxe_features
   unit: units/ww/shared/install/intro
       unit: units/ww/shared/requirements
       unit: units/ww/deluxe/requirements
       unit: units/ww/shared/install
       unit: units/ww/deluxe/install_options
</db:programlisting></db:figure>
<db:para>Rather than using a map, you can allow the units themselves to pull in other units, which may in turn pull in other units. So the Widget Wrangler Deluxe install introduction unit might look like the example in <db:xref linkend="fig.assemble-unit"/>.</db:para>
<db:figure xml:id="fig.assemble-unit"><db:title>Alternate structure for the assemble-from-pieces approach</db:title><db:programlisting>
unit: Installing the Widget Wrangler Deluxe
            
    You should be very careful when installing the 
    Widget Wrangler Deluxe. Follow these steps carefully:

    &gt;&gt;&gt;(unit units/ww/shared/requirements)
    &gt;&gt;&gt;(unit units/ww/deluxe/requirements)
    &gt;&gt;&gt;(unit units/ww/shared/install)
    &gt;&gt;&gt;(unit units/ww/deluxe/install_options)        
</db:programlisting></db:figure>
<db:para>This method avoids the need for a map, but it can make the units less reusable. In <db:xref linkend="fig.assemble-unit"/>, you would need a separate introduction unit for the regular Widget Wrangler, since the introduction file imports all the requirements and procedural units. By assembling units with the map, you can use a shared install introduction, which increases the amount of reuse you can do.</db:para>
</db:section>
<db:section><db:title>Combining multiple techniques</db:title>


<db:para>There is one problem with using a common install introduction for both the regular and the deluxe Widget Wrangler. The introduction mentions the name of the product. To solve this problem without requiring two different units, you can use the variable-into-common or common-with-conditions reuse techniques. <db:xref linkend="fig.combine-unit"/> shows an example using variable into common:</db:para>
<db:figure xml:id="fig.combine-unit"><db:title>Combination of the assemble-from-pieces and variable-into-common approaches</db:title><db:programlisting>
unit: Installing the &gt;($product_name)
            
    You should be very careful when installing 
    the &gt;($product_name). Follow these steps carefully:

    &gt;&gt;&gt;(unit unit/ww/shared/requirements)
    &gt;&gt;&gt;(unit unit/ww/deluxe/requirements)
    &gt;&gt;&gt;(unit unit/ww/shared/install)
    &gt;&gt;&gt;(unit unit/ww/deluxe/install_options)        
</db:programlisting></db:figure>
<db:para>There are a number of ways to mix and match the basic reuse patterns to achieve an overall reuse strategy. Most systems designed to support reuse allow you to use all of these approaches and combine them as needed. However, don’t lose sight of the amount of complexity you introduce into your content and your writers’ workload when you rely on a complex set of reuse techniques.</db:para>
</db:section>
<db:section><db:title>Content reuse is not a panacea</db:title>


<db:para>Content reuse can seem like an easy win, and in some cases it can return substantial benefits, but there are pitfalls to be aware of. You need to plan carefully to make sure that you avoid the traps that await the unwary.</db:para>
<db:para>Many reuse techniques introduce a lot of complexity into the writer’s job and into the content itself. These techniques may address major sources of content complexity, but they come with a high cost in terms of new complexity introduced. Even if a reuse tool looks easy to use, it can introduce large amounts of complexity.</db:para>
<db:section><db:title>Rhetoric traps</db:title>


<db:para>Designing content to be reused can harm its rhetoric, either by distracting writers with complexity or by motivating them to prefer reusability over rhetorical quality. There are three main rhetoric traps with content reuse:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Making content too generic</db:para>
</db:listitem>
<db:listitem>
<db:para>Losing the narrative flow</db:para>
</db:listitem>
<db:listitem>
<db:para>Failing to address the audience appropriately</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Many works on content reuse casually recommend making content more generic or more abstract as a means to making it more reusable, without saying anything about the potential downside. This is very dangerous and can do serious harm to the rhetorical quality of your content. Specific, concrete statements are easier to understand, and they communicate better than generic or abstract statements. Replacing specific and concrete statements with generic or abstract statements will reduce the effectiveness of your content significantly. This is a classic case of one process directing complexity away from itself without regard for the effect on the whole.</db:para>
<db:para>Unfortunately, as noted in <db:xref linkend="chapter.writing"/>, human beings suffer from <db:indexterm><db:primary>the curse of knowledge</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>the curse of knowledge</db:secondary></db:indexterm>the curse of knowledge. The curse of knowledge is a cognitive bias that makes it very hard for people who understand an idea to appreciate the difficulties that idea presents to people who do not understand it. The curse of knowledge makes a generic or abstract statement of an idea appear to the writer to be as clear as a concrete and specific statement – and perhaps more succinct and precise. This pulls writers away from the kind of specific and concrete statements that make ideas easier to comprehend. The desire to make content reusable reinforces this temptation.</db:para>
<db:para>Replacing the specific and concrete with the generic and abstract always reduces content quality and effectiveness. You may decide that the economic benefits of content reuse outweigh the economic costs of less effective content, but you should at least be aware that there are real economic consequences to this choice.</db:para>
<db:para>Another potential quality problem comes with the loss of narrative flow. Not all content has or needs a lengthy narrative flow, but if you start breaking your content into reusable units and putting those units back together in different ways, the narrative flow can easily be lost. In some cases you can avoid this problem by making your topics more self-contained, using an <db:indexterm><db:primary>Every Page is Page One</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>Every Page is Page One</db:secondary></db:indexterm>Every Page is Page One information design. But don’t assume that you have an effective Every Page is Page One design just because you have broken your content into reusable units. If that content was written in a way that assumed a narrative flow, it won’t work when reused in a way that breaks that flow.</db:para>
<db:para>Finally, reuse can encourage you to come up with one way of telling our story that you present to all your audiences. But not all audiences are alike, and the way you tell your story to one audience may not work for another audience. Good rhetoric tells a good story to a particular audience. Two different tellings of the same story do not constitute redundant content if they address different audiences.</db:para>
</db:section>
<db:section><db:title>Cost traps</db:title>


<db:para>It is easy to see content reuse as a method to achieve big cost savings. Reusing content means you do not have to write the same content over and over again. It is easy to add up the cost of all that redundant writing and regard that number as pure cost savings from a content reuse strategy.</db:para>
<db:para>But all of the reuse techniques create multiple artifacts – including content and algorithms – that need to be managed. You need a mechanism to make sure that your content obeys the constraints required to make the pieces of content fit together reliably. You need a mechanism to make sure that your reuse processes produce the documents you need. The cost of such management can be non-trivial, and the consequences if the management breaks down can be significant.</db:para>
<db:para>While reuse is supposed to reduce the cost of modifying content when the subject matter changes, there are hidden cost traps here as well. It is often not until the subject matter changes that you find out if the content you have treated as common is really common. If not, you have to sort out what is common and what isn’t, which can involve complex edits that have to be tested and verified.</db:para>
<db:para>If you get everything right, you can realize major savings when it comes time to modify your content, but if you get it wrong, your costs can multiply. Not only that, you may find that the money you spent factoring duplicate content out in anticipation of a change that did not happen is wasted as well. Reacting to changes that actually happen is sometimes cheaper than preparing for multiple changes that never happen.</db:para>
<db:para>If your content collection and its web of reuse relationships is not audited and validated regularly, it can become chaotic over time and lose cohesion. This can make adding new content or changing existing content increasingly difficult and expensive.</db:para>
<db:para>Depending on the techniques you use, content reuse strategies can complicate the lives of writers, which may reduce the pool of writers you can use or reduce their productivity.</db:para>
<db:para>With many reuse techniques, writers have to look for reusable content frequently. Not only does this take time and add complexity, writers have to pay that cost every time they look for content to reuse, whether they find it or not. Indeed, if writers must look for reusable content before they write anything, much of their time may be taken up with unsuccessful content queries. Reducing the expense of content queries, therefore, has to be a major component of any general reuse strategy. I look  at this in more detail in <db:xref linkend="chapter.duplication"/>.</db:para>
<db:para>Localized and constrained forms of reuse can avoid this cost trap. For instance, if your reuse is focused on producing manuals for different versions of a product, you can avoid having writers make frequent broad-based content queries to find reusable content. You merely need to ensure that writers are aware of the reuse strategies used for their projects.</db:para>
<db:para>Some content reuse techniques are easy to use in non-structured ways, and early in a project, it may seem like a non-structured approach to reuse speeds things up by allowing writers to reuse content wherever they find it. Over time, however, this approach can lead to a rat’s nest of dependencies and relationships that makes it hard to update the content with any confidence.</db:para>
<db:para>Once the cohesion and discipline of a content set starts to break down, the decline can accelerate. As it becomes harder to find content to reuse, more duplication occurs, which further complicates the search for reusable content, creating a vicious cycle. As links and other content relationships break down, people tend to form ad hoc links and relationships to get a job finished, further tangling the existing rat’s nest. Under the gun, it is almost always easier to get the next document out by ignoring the discipline of the content set structure, but the effects of this are corrosive. Without consistent discipline, even in the face of deadlines, a reuse system can fail over time.</db:para>
<db:para>All of these issues can be managed successfully with the right techniques and the right tools, but they all introduce costs as well, both up-front costs and ongoing costs. Those costs have to be calculated and subtracted from the projected cost savings before you can determine if a content reuse strategy is going to save money.</db:para>
<db:para>One final trap: there may not be as much potential reuse as you thought. Some organizations have plunged into reuse strategies in hopes of a big payoff only to find that they had far less reusable content than they first thought. The cost of systems and the complexity added to the process by complex reuse techniques require a high level of reuse to pay off. If you can’t achieve that level of reuse, your system will end up costing you more than it saves.</db:para>
</db:section>
</db:section>
<db:section><db:title>Alternatives to reuse</db:title>


<db:para>Here are three alternatives to content reuse:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:emphasis role="bold">Duplicate but label:</db:emphasis> Allow information to be expressed in more than one place but clearly label the information so you can easily find it when you need to do an update. If this sounds like an inferior solution, consider that reuse techniques cannot possibly eliminate all repeated information without adding more complexity than they eliminate. Therefore, no matter how much reuse you do, when you have a major change in subject matter, you will still have to search your content for places that need to be updated.</db:para>


</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Reduce duplication:</db:emphasis> Content reuse is always content duplication. Reuse is predicated on the idea that you actually want to duplicate information in multiple publications. This idea is out of date. In the paper world, you had to give each customer a book that contained all the information needed, even if the same information occurred in many different books. But in an online environment, you don’t need to duplicate information to make it available to every user who needs it. Maintaining the information once and linking to it whenever it is needed is often a much less complex solution. To do this efficiently may require some of the techniques described in <db:xref linkend="chapter.linking"/>.</db:para>


</db:listitem>
<db:listitem>
<db:para><db:emphasis role="bold">Combine and differentiate:</db:emphasis> Another approach to reducing duplication in your content is to combine information on multiple products into a single publication and differentiate them in the text. There are limits to this, obviously, and some organization got into content reuse specifically so that they could remove the complexity of handling multiple versions in a single manual. Still, there are times when it is an appropriate solution.</db:para>


</db:listitem>
</db:itemizedlist>
<db:indexterm class="endofrange" startref="idp326755812"/><db:indexterm class="endofrange" startref="idp326749924"/><db:indexterm class="endofrange" startref="idp326755812x"/><db:indexterm class="endofrange" startref="idp326749924x"/></db:section>
</db:chapter>
