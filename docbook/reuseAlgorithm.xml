<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.reuse"><db:title>Reuse</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp1601934356"><db:primary>reuse</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1601934356x"><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idp1601935252"><db:primary>content reuse</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1601935252x"><db:primary>concept</db:primary><db:secondary>content reuse</db:secondary></db:indexterm>



<db:para>Another source of complexity in content creation occurs when you want the same information to occur in more than one publication. If there is no coordination between authors, each author who want to include the piece of information will research and write it for themselves. Individual writers who want to use the same information in more than on publication they are writing, will copy the information from one publication to another. However it happens, you now have two or more instances of the same information that have to be maintain and edited whenever the subject matter changes. If some instances do not get updated, or some of them get updated incorrectly, that is content maintenance complexity that is not being handled, and, as always, it falls through to the reader in the form of inconsistent or incorrect information.</db:para>
<db:para>Content reuse is an attempt to handle the complexity associated with using the same information in more than one place. Reuse has become one of the main drivers of structured writing, particularly in the form of widespread adoption of <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA. Unfortunately, most reuse techniques also introduce a lot of <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain complexity. A single-minded focus on reuse has sometimes led to the implementation of systems that dump large amounts of complexity on authors (and thus, eventually, on readers). It is an area in which, if you are not careful, you can easily end up with more unhandled complexity in the system than when you began.</db:para>
<db:para>It is important to remember that content reuse is a means for creating duplication in content. It eliminates duplication on the authoring side, but it creates duplication on the output side. It is important to think about why you want that duplication at all, or if there are viable alternatives, such as publishing the information once and linking to it from various places. There are a number of different scenarios in which you might want to duplicate information in more than one place. For example:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>You are writing about different products in a product line that share common technology. You want to duplicate information on the common features in a document on each individual product.</db:para>
</db:listitem>
<db:listitem>
<db:para>You are writing about several different releases of a product. You want information on features that have not changed to be duplicated in all documents.</db:para>
</db:listitem>
<db:listitem>
<db:para>You are writing documents for different audiences (marketing material, technical documentation for various roles, training material) and you want to  duplicate product descriptions in all these documents.</db:para>
</db:listitem>
<db:listitem>
<db:para>There is general information about your organization that you want to duplicate in many different publications (such as your copyright and trademark ownership statements).</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>“Reusing” can suggest that this activity is somewhat akin to rummaging through that jar of old nuts and bolts you have in the garage looking for one that is the right size to fix your lawnmower. While you can do it that way, that approach is neither efficient nor reliable. The efficient and reliable approach involves deliberately creating content for duplication in multiple locations. This means that you need to place constraints on the content to be reused and the content that reuses it, and that means you are in the realm of structured writing.</db:para>
<db:section>
<db:title>Fitting pieces of content together</db:title>
<db:para>If you are going to create one piece of content that can be used in many outputs, you have to make sure it fits in each of those outputs (in other words, partition it appropriately for reuse.)</db:para>
<db:para>If you cut and paste, this is not a concern. You can cut any text you like, paste it in anywhere, and edit it to fit if you need to. But if the content you want to use is used in other places, you can’t edit it to fit because that might cause it to no longer fit in the other places. For reuse to work, the content must be written to fit in multiple places. In other words, it has to meet a set of constraints that will ensure that it will fit in multiple places. We will look at this in more detail in <db:xref linkend="chapter.composition"/>. In this chapter we will focus on the algorithms for fitting the pieces together.</db:para>
<db:para>There are seven basic models for fitting pieces of content together:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Common into variable</db:para>
</db:listitem>
<db:listitem>
<db:para>Variable into common</db:para>
</db:listitem>
<db:listitem>
<db:para>Variable into variable</db:para>
</db:listitem>
<db:listitem>
<db:para>Common with conditions</db:para>
</db:listitem>
<db:listitem>
<db:para>Factor out the common</db:para>
</db:listitem>
<db:listitem>
<db:para>Factor out the variable</db:para>
</db:listitem>
<db:listitem>
<db:para>Assemble from pieces</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>Common into variable</db:title>
<db:para>In the common into variable case, you have a common piece of content that occurs in many places. This could mean it occurs in many documents or in many places in the same document, or both.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/common2variable.svg" contentwidth="5.25in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/common2variable.png"/></db:imageobject><db:textobject><db:para>A diagram showing the common to variable reuse pattern.</db:para></db:textobject></db:mediaobject><db:programlisting language="sam">

procedure: Blow stuff up
    &gt;&gt;&gt;(files/shared/admonitions/danger)
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting>
<db:para>To ensure that the included content will always fit, you need to make sure that there is a clear partitioning of responsibilities between the common content and each place it will be inserted into. In this example, the inserted content should give the safety warning, the whole safety warning, and nothing but the safety warning. The procedure structure should describe the steps and only the steps and should insert the reusable warning at the right place.</db:para>
<db:para>Of course, you can also use the subject-domain approach to common into variable that we looked at in <db:xref linkend="chapter.management-domain"/>. I will go into more detail on that approach later in this chapter.</db:para>
</db:section>
<db:section>
<db:title>Variable into common</db:title>
<db:para>In the variable into common case, you have a single document that will be output in many different ways by inserting variable content at certain locations.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/variable2common.svg" contentwidth="4in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/variable2common.png"/></db:imageobject><db:textobject><db:para>Diagram showing the variable to common reuse pattern.</db:para></db:textobject></db:mediaobject>
<db:para>For instance, if you are writing a manual to cover a number of car models you can factor out the number of seats each model has.</db:para>
<db:programlisting language="sam">

The vehicle seats &gt;($seats) people.
</db:programlisting>
<db:para>This is the fixed content that will occur in all manuals, with the number of seats pulled in from an external source. Let’s say we have a collection of vehicle data that is stored in a structure like this:</db:para>
<db:programlisting language="sam">

vehicles:
    vehicle: compact
        seats: four
        colors: red, green, blue, white, black
        transmissions: manual, CVT
        doors: four
        horsepower: 120
        torque: 110 @ 3500 RPM
    vehicle: midsize
        seats: five
        colors: red, green, blue, white, black
        transmissions: CVT
        doors: four
        horsepower: 180
        torque: 160 @ 3500 RPM
</db:programlisting>
<db:para>Then we write the algorithm to process the insert so that it queries this structure.</db:para>
<db:programlisting language="pseudo">

match insert where variable = $seats
    $number_of_seats = vehicles/vehicle[$model]/seats
    output $number_of_seats
</db:programlisting>
<db:para>All these insert and query mechanisms are <db:indexterm><db:primary>pseudocode</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>pseudocode</db:secondary></db:indexterm>pseudocode, of course. Exactly how things work and exactly how you delineate, identify, and insert content vary from system to system.</db:para>
<db:para>With the variable into common technique, you are creating a common source by factoring out all the parts of the different outputs that are not common. This is, in some ways, the inverse of the usual pattern of factoring out invariants: we are actually factoring out the variants. But really, it amounts to the same thing. We are factoring variants from invariants. The only real difference between this and the common into variable is whether the common parts are embedded in the variable parts or vice versa. Either way, we still end up with two artifacts: the variable piece or pieces and the common piece or pieces.</db:para>
</db:section>
<db:section>
<db:title>Variable into variable</db:title>
<db:para>Variable into variable is a variation on common into variable in which you can make a wholesale change of the common elements that you are pulling into a set of variable documents.</db:para>
<db:para>For example, suppose you decide to market your product line to a new market. The new market has different safety regulation which means you need to insert a different standard warning into all your manuals. In this case, you want to swap out the common elements used in your home market and substitute the common elements for the foreign market.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/variable2variable.svg" contentwidth="4in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/variable2variable.png"/></db:imageobject><db:textobject><db:para>Diagram showing the variable to variable reuse pattern.</db:para></db:textobject></db:mediaobject>
<db:para>Here we need to talk about how we identify the content to be inserted. In the common into variable example, we inserted the content of a file that contains a standard warning.</db:para>
<db:para>But for variable into variable this approach simply does not work. Variable into variable requires loading a different file, which is difficult when the content specifies a particular file name to import.</db:para>
<db:para>As always in structured writing, we look for a way to factor out the problematic content. So here we look for a way to factor out the file name and replace it with something else.</db:para>
<db:section>
<db:title>Using IDs</db:title>
<db:para>The most basic way to factor out the file name is to give the content of the file an ID. An ID is a management domain structure used to identify a piece of content in a location independent way. No matter where the content is stored, it keeps the same ID. Here is the warning file with the ID <db:code>#warn_danger</db:code> added:</db:para>
<db:programlisting language="sam">

warning:(#warn_danger) 
    title: Danger
    
    Be very very careful. This could kill you.
</db:programlisting>
<db:para>We can then insert the warning into our procedure by referring to that ID.</db:para>
<db:programlisting language="sam">

procedure: Blow stuff up
    &gt;&gt;&gt;(#warn_danger)
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting>
<db:para>The decision about which warning to include has now been shifted from the writer to the algorithm.</db:para>
<db:programlisting language="pseudo">

match insert with ID
    $insert_content = find ID in $content_set
    output $insert_content
</db:programlisting>
<db:para>This is a constant pattern in structured writing. When it comes to choosing and locating resources, you want to move that responsibility from the writer to the algorithm, which means moving the identity of the resource out of the content and into the algorithm. This makes it easier to update the locations, but it also gives you far more options for storing and managing your content, since algorithms can interact with a variety of systems in sophisticated ways, rather than just storing a static address. It also means you can make wholesale changes in how your content is stored without having to edit the content itself. This is a major win in terms of partitioning complexity so it can be distributed and handled more efficiently.</db:para>
<db:para>This means that the algorithm needs some way to resolve the ID and find the content to include. In many cases, a <db:indexterm><db:primary>content management system</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>content management system</db:secondary></db:indexterm>content management system is used to resolve the ID. In other cases it is as simple as the algorithm searching through a set of files to find the ID or building a catalog that points to the files that contain IDs.</db:para>
<db:para>To do variable into variable reuse in a system that uses IDs, you simply point the <db:indexterm><db:primary>algorithm</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>algorithm</db:secondary></db:indexterm>algorithm at a different set of files that contain the same IDs, but attached to different content. So if your foreign market requires a different warning, you can create a file like this:</db:para>
<db:programlisting language="sam">

warning:(#warn_danger) 
    title: Look out!
    
    Pay close attention. You could really hurt yourself.
</db:programlisting>
<db:para>By telling the build of the foreign market docs to search this file for IDs rather than the file with the domestic market warning, you automatically get the the foreign warning rather than the domestic one.</db:para>
</db:section>
<db:section>
<db:title>Using keys</db:title>
<db:para>Another way to do this is with another <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain structure called a key. A key is similar to an ID but it is not directly tied to a resource. Instead, the same key can be used to point to different resources at different times. Since a key does not represent any one concrete resource, we don’t assign the key to a resource. Instead we use an intermediate lookup table to resolve keys to particular resources for a particular purpose.</db:para>
<db:para>So in this case we have the warning in a file called files/shared/admonitions/domestic/danger with the following content (no ID):</db:para>
<db:programlisting language="sam">

warning: 
    title: Danger
    
    Be very very careful. This could kill you.
</db:programlisting>
<db:para>And we have the procedure which includes the warning via a key:</db:para>
<db:programlisting language="sam">

procedure: Blow stuff up
    &gt;&gt;&gt;(%warn_danger)
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting>
<db:para>(I am using <db:code>#</db:code> to denote IDs and <db:code>%</db:code> to denote keys. This is the notation that SAM uses for IDs and keys, but it is purely arbitrary and has nothing to do with how they work. Different systems will denote IDs and keys in different ways.)</db:para>
<db:para>To connect the key to the warning file, we then create a key lookup table:</db:para>
<db:programlisting language="sam">

keys:
    key:
        name: warn_danger
        resource: files/shared/admonitions/domestic/danger
</db:programlisting>
<db:para>When the algorithm processes the procedure, it sees the key reference <db:code>%warn_danger</db:code> and looks it up in the key lookup table. The key lookup table tells the algorithm that the key resolves to the resource <db:code>files/shared/admonitions/domestic/danger</db:code>. The algorithm then loads that file and inserts the contents into the output.</db:para>
<db:programlisting language="pseudo">

match insert with key
    $resource = find key in lookup-table
    output $resource
</db:programlisting>
<db:para>To output your content for the foreign market, you simply prepare a new key lookup table:</db:para>
<db:programlisting language="sam">

keys:
    key:
        name: warn_danger
        resource: files/shared/admonitions/foreign/danger
</db:programlisting>
<db:para>You then tell the algorithm to use this lookup table instead.</db:para>
<db:para>Using keys is not necessarily better than using IDs. What it comes down to is that you need some kind of bridge between the citation of an identifier in the source file and the location of a resource with that identifier in the content store. This bridge can be created by a key lookup table, by remapping file URLs, or by modifying a query to a content repository.</db:para>
<db:para>One feature of the key approach is that, because it does not attach the key directly to the content, it can be use to identify resources that do not have IDs, which may include resources that you do not control.</db:para>
<db:para>One downside of keys is that by themselves they can only point to a whole resource. This could force you to keep all your reusable units in separate files. To avoid this, you can combine keys with IDs. The following example combines the foreign and domestic danger warnings into one file and gives each an ID:</db:para>
<db:programlisting language="sam">

warnings:
    warning:(#warn_danger_domestic) 
        title: Danger
        
        Be very very careful. This could kill you.

    warning:(#warn_danger_foreign) 
        title: Look out!
        
        Pay close attention. You could really hurt yourself.
</db:programlisting>
<db:para>Now we can rewrite our key lookup tables to use the IDs to pull the right warning out of this common file. For the domestic build we would use a key lookup table like this:</db:para>
<db:programlisting language="sam">

keys:
    key:
        name: warn_danger
        resource: files/shared/warnings#warn_danger_domestic
</db:programlisting>
<db:para>And for the foreign build, one that looks like this:</db:para>
<db:programlisting language="sam">

keys:
    key:
        name: warn_danger
        resource: files/shared/warnings#warn_danger_foreign
</db:programlisting>
<db:para>Here we have partitioned the warnings into a separate file and also partitioned the location of those files from the writer. The use of keys as a bridge between two partitions can be a convenient way to manage content relationships without having to update source files every time the relationships change.</db:para>
<db:para>The downside is that keys introduce an abstract element into the writer’s world, and abstractions are a form of complexity that can be difficult to deal with. Decisions about which warning to use have been replaced by decisions about which key or id to use, but those decisions are not necessarily easier to make and require more system knowledge, and a more abstract way of thinking, than the original decision they are designed to factor out. They abstract out the actual act of inclusion, but that is actually the least complex part of ensuring the standard warning is used.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>Common with conditions</db:title>
<db:para>In some cases of variable into common, the variant pieces is not actually  factored out into a separate file. Rather, each of the possible alternatives is included in the file conditionally.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/commonconditions.svg" contentwidth="3in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/commonconditions.png"/></db:imageobject><db:textobject><db:para>Diagram of the common with conditions reuse pattern.</db:para></db:textobject></db:mediaobject>
<db:para>For instance, in content for a car manual you might have conditional text for the number of people the car seats.</db:para>
<db:programlisting language="sam">

The vehicle seats {four}(?compact){five}(?midsize){seven}(?van).
</db:programlisting>
<db:para>Here the main text is the fixed piece and the variable pieces are the words “four”, “five”, and “seven”. Which of these will be included in the output depends on which condition is applied during the build. If the condition <db:code>midsize</db:code> is applied, then the output text will be “five” and the other alternatives will be suppressed.</db:para>
<db:programlisting language="pseudo">

match phrase with condition
    if condition in $build_conditions
        continue
    else
        ignore
</db:programlisting>
<db:para>The upside of the conditional approach is that it keeps all the variants in one file, so your algorithm does not have to know where to go to find the external content.</db:para>
<db:para>But there are a number of downsides to this approach:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>It gets very cumbersome to read the source if there are many different conditions applied.</db:para>
</db:listitem>
<db:listitem>
<db:para>When the subject matter changes, you have to find all the places the conditions occur and update them.</db:para>
</db:listitem>
<db:listitem>
<db:para>If the same data point (the number of seats) is mentioned in many different documents, that information is still being duplicated all over the content, which makes it hard to maintain and verify, and hard to change if, for example, the compact seats five in the next model year.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Common with conditions is not limited to cases where there are alternate values, however. In some cases, content may simply be inserted or omitted for certain outputs.</db:para>
<db:programlisting language="sam">

The main features of the car are:

ol:
    li: Wheels
    li: Steering wheel
    li:(?deluxe) Leather seats
    li: Mud flaps
</db:programlisting>
<db:para>In this case, the list item “Leather seats” would only be published if the condition <db:code>deluxe</db:code> was specified in the build. It would be omitted for all other builds. In these kinds of cases, it is harder to get away from the use of conditionals as a reuse mechanism.</db:para>
<db:para>This approach to reuse is often called filtering or profiling. Some systems have elaborate ways of specifying filtering or profiling of the content. The net effect is the same as the simple condition tokens shown here, but they may allow for more sophisticated or elaborate conditions than shown here.</db:para>
<db:para>Because common with conditions is essentially a form of variable into common where the variable content is contained inside the common source, it can technically be replaced by a variable into common approach in all cases. In practice, the use of conditions tends to occur when:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The number of variations is small and thought to be fixed or to change infrequently.</db:para>
</db:listitem>
<db:listitem>
<db:para>The variable pieces are eccentric or contextually dependent.</db:para>
</db:listitem>
<db:listitem>
<db:para>The writer or organization wishes to avoid managing multiple files.</db:para>
</db:listitem>
<db:listitem>
<db:para>The current tools don’t support variable into common.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>How successful a common with conditions approach will be also depends on what you choose for your conditional expressions. Generally, subject domain conditions will be much more stable and manageable than document domain conditions. For instance, conditions that relate to different vehicles (subject domain) are based in the real world and are therefore objectively true as long as the subject matter remains the same. Conditions that relate to different publications or different media, on the other hand, are not objectively true and can’t be verified independently. They only way to verify them is to build the different documents or media and see if you got the content you expected. This makes maintaining such conditions cumbersome and error prone – an indications that complexity is not being distributed in an optimal way.</db:para>
</db:section>
<db:section>
<db:title>Factor out the common</db:title>
<db:para>In <db:xref linkend="chapter.management-domain"/>, I noted that the subject domain alternative to using an insertion instruction for the warning text was to specify which procedures were dangerous, thus factoring out the constraint that the warning must appear.</db:para>
<db:programlisting language="sam">

procedure: Blow stuff up
    is-it-dangerous: yes
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting>
<db:para>In this case, the author does not have to identify the material to be included, either directly by file name or indirectly through an <db:indexterm><db:primary>ID</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>ID</db:secondary></db:indexterm>ID or a <db:indexterm><db:primary>key</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>key</db:secondary></db:indexterm>key. Instead, it is up to the algorithm to include it:</db:para>
<db:programlisting language="pseudo">

match procedure/is-it-dangerous 
    if is-it-dangerous = 'yes'
        output files/shared/warnings#warn_danger_domestic
</db:programlisting>
<db:para>To produce the foreign market version of the documentation, you simply edit the rule:</db:para>
<db:programlisting language="pseudo">

match procedure/is-it-dangerous 
    if is-it-dangerous = 'yes'
        output files/shared/warnings#warn_danger_foreign
</db:programlisting>
<db:para>Or, to further the partitioning of complexity in the code, you can use keys:</db:para>
<db:programlisting language="pseudo">

match procedure/is-it-dangerous 
    if is-it-dangerous = 'yes'
        $resource = find key '%warn_danger' in lookup-table
        output $resource      
</db:programlisting>
<db:para>The beauty of this approach is that the content is entirely neutral as to what kind of reuse may be going on or how dangerous procedures may be treated. Because the content contains only objective information about the procedure itself, you can implement any algorithm you like to publish or reuse the content in any way you like at any time based on this information. By making the content not specific to any form of reuse or any reuse mechanism, we effectively make it much more reusable and have partitioned the complexity of reuse much more neatly and reliably.</db:para>
<db:para>We are also making the content much easier to write, since this approach does not require the writer to know how the reuse mechanism works, how to identify reusable content, or even that reuse is occurring at all. All they have to do is answer a simple question about the content – is the procedure dangerous or not  -- to which they should already know the answer. In other words, this approach partitions the entire reuse mechanism from the writer. This is a really big win because the biggest problem with most reuse techniques is the amount of complexity they add to the writer’s task, directly compromising their finite and valuable attention.</db:para>
<db:para>This is very important from both a complexity point of view and a cost point of view. Where a writer is asked to consciously reuse content they have to go looking for that content every time the potential for reuse occurs. This cost is incurred whether or not they find reusable content, whereas any savings from reuse are realized only when reusable content is found. But with this approach, the writer is relieved of all responsibility for the reusable content. Locating that content is the job of an algorithm. If it does not exist, the algorithm will report that it is missing and it will be somebody’s job to create it, after which the algorithm will locate it automatically every time it is needed. This is far more efficient than writers looking for reusable content over and over and over.</db:para>
<db:para>The downside of this approach is that it is not as general. The <db:code>is-it-dangerous</db:code> metadata is applies only to dangerous procedures. It does not address the inclusion of reusable content in other places. You would need to factor out other interesting reuse cases in a similar way to create a complete subject-domain solution. Again we see that complexity always has to go somewhere. But as we have also seen, if writers cannot fully handle the complexity thrust on them, that complexity ultimately gets dumped on the reader.</db:para>
</db:section>
<db:section>
<db:title>Factor out the variable</db:title>
<db:para>You can also factor out the variable content. For example, in the case of the different models of a car, rather than conditionalizing the list of features in the document, like this:</db:para>
<db:programlisting language="sam">

The main features of the car are:

ol:
    li: Wheels
    li: Steering wheel
    li:(?deluxe) Leather seats
    li: Mud flaps
</db:programlisting>
<db:para>You can factor out the list entirely:</db:para>
<db:programlisting language="sam">

The main features of the car are:

&gt;&gt;&gt;(%main_features)
</db:programlisting>
<db:para>You can then maintain the features list in a database. The organization probably already has a database of features for each vehicle, so we don’t need to create anything new. We simply query the existing database. (After all, this is about reusing what already exists rather then recreating it!)</db:para>
<db:para>So now our algorithm looks something like this:</db:para>
<db:programlisting language="pseudo">

match insert with key
    $resource = lookup key in lookup-table
    output $resource
</db:programlisting>
<db:para>We then have a key lookup table where the resource is identified by a query on the database</db:para>
<db:programlisting language="sam">

keys:
    key:
        name: %main-features
        resource: from vehicles select features 
                  where model = $model
</db:programlisting>
<db:para>This retrieves a different set of features from the database depending on how the variable <db:code>$model</db:code> is defined for the build. Launch the build with <db:code>$model = 'compact'</db:code> and you get the feature set for the compact model. Launch the build with <db:code>$model = 'van'</db:code> and you get the feature set for the van model.</db:para>
<db:para>Naturally, this is leaving out a whole lot of detail about how this query gets executed and how the results get structured into a <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain list structure. But those are implementation details.</db:para>
</db:section>
<db:section>
<db:title>Assemble from pieces</db:title>
<db:para>In the assemble from pieces approach, there is no common vs. variable distinction and no single source document into which reused content is inserted or to which conditions are applied. Instead, there is a set of content units that are assembled to form a finished document.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/assemble.svg" contentwidth="5.25in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/assemble.png"/></db:imageobject><db:textobject><db:para>A diagram showing multiple pieces being combined in different ways to produce different outputs.</db:para></db:textobject></db:mediaobject>
<db:para>For example, if you have a range of products with common features, you might assemble the documentation for those products using a common introduction with a piece representing each feature of each model.</db:para>
<db:para>This could be a flat list, or it could be a tree structure. For instance, you might assemble a chapter of a manual with a introductory piece and then several sections below it in the tree.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/tree.svg" contentwidth="2in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/tree.png"/></db:imageobject><db:textobject><db:para>A diagram showing the tree structure of a book.</db:para></db:textobject></db:mediaobject>
<db:para>The assembly approach requires a structure to describe how the units are assembled. This structure is often called a map. (It is called a map in <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA, for instance.) Some applications may also refer to it as a table of contents.</db:para>
<db:programlisting language="sam">

map: Widget Wrangler Deluxe User Manual
   unit: units/ww/deluxe/intro
       unit: units/ww/shared/basic_features
       unit: units/ww/deluxe/deluxe_features
   unit: units/ww/shared/install/intro
       unit: units/ww/shared/requirements
       unit: units/ww/deluxe/requirements
       unit: units/ww/shared/install
       unit: units/ww/deluxe/install_options
</db:programlisting>
<db:para>Rather than using a map, you can allow the units themselves to pull in other units, which may in turn pull in other units. So the Widget Wrangler Deluxe install introduction unit might look like this:</db:para>
<db:programlisting>

unit: Installing the Widget Wrangler Deluxe

    You should be very careful when installing the 
    Widget Wrangler Deluxe. Follow these steps carefully:
    
    &gt;&gt;&gt;(unit units/ww/shared/requirements)
    &gt;&gt;&gt;(unit units/ww/deluxe/requirements)
    &gt;&gt;&gt;(unit units/ww/shared/install)
    &gt;&gt;&gt;(unit units/ww/deluxe/install_options)
</db:programlisting>
<db:para>This avoids the need for a map, but the downside is that it can make the units less reusable. In the above example, for instance, you would need a separate introduction unit for the regular Widget Wrangler since the introduction file imports all the requirements and procedural units. By assembling units with the map, you can use a shared install intro, which increases the amount of reuse you can do.</db:para>
</db:section>
<db:section>
<db:title>Combining multiple techniques</db:title>
<db:para>There is one problem with the idea of using a common install intro for both the regular and deluxe widget wrangler. The intro mentions the name of the product. To solve this problem without requiring two different units, we can use the variable into common or common with conditions reuse techniques within the intro unit. Here is an example using variable into common:</db:para>
<db:programlisting>

unit: Installing the &gt;($product_name)

    You should be very careful when installing 
    the &gt;($product_name). Follow these steps carefully:
    
    &gt;&gt;&gt;(unit unit/ww/shared/requirements)
    &gt;&gt;&gt;(unit unit/ww/deluxe/requirements)
    &gt;&gt;&gt;(unit unit/ww/shared/install)
    &gt;&gt;&gt;(unit unit/ww/deluxe/install_options)
</db:programlisting>
<db:para>There are a number of ways in which you can mix and match the basic reuse patterns to achieve an overall reuse strategies. Most systems designed to support reuse will allow you to do all these patterns and to combine them however you wish. However, you should not lose site of the amount of complexity that you are introducing into your content and into your writer’s work when you rely on a complex set of reuse techniques like this.</db:para>
</db:section>
<db:section>
<db:title>Content reuse is not a panacea</db:title>
<db:para>Content reuse can seem like an easy win, and in some cases it can return substantial benefits, but there are pitfalls to be aware of. You will need to plan carefully to make sure that you avoid the traps that await the unwary.</db:para>
<db:para>Many reuse techniques introduce a lot of complexity into the writer’s job and into the content itself. These techniques may address major sources of content complexity in your organization but they come with a high cost in terms of new complexity introduced. Even if the reuse tools look easy to use, they can introduce large amounts of complexity into your process.</db:para>
<db:section>
<db:title>Quality traps</db:title>
<db:para>There are three main quality traps with content reuse.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Making content too generic</db:para>
</db:listitem>
<db:listitem>
<db:para>Losing the narrative flow</db:para>
</db:listitem>
<db:listitem>
<db:para>Failure to address the audience appropriately</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Many works on content reuse casually recommend making content more generic or more abstract as a means to making it more reusable, without saying anything about the potential downside. This is very dangerous and can do serious harm to the quality of your content. Statements that are specific and concrete are easier to understand and communicate better than statements that are generic and abstract. Replacing specific and concrete statements with generic or abstract statements will reduce the effectiveness of your content significantly. This is a classic case of dumping complexity onto the reader.</db:para>
<db:para>Unfortunately, human beings suffer from <db:indexterm><db:primary>the curse of knowledge</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>the curse of knowledge</db:secondary></db:indexterm>the curse of knowledge. The curse of knowledge is a cognitive bias that makes it very hard for people who understand an idea to appreciate the difficulties that idea presents to people who do not understand it. The curse of knowledge makes the generic or abstract statement of an idea appear equally communicative, and perhaps more succinct and precise, than the concrete and specific statement of it. This is a problem for writers at all times, pulling them away from the kind of specific and concrete statement that make ideas easier to comprehend. The desire to make content reusable reinforces this temptation.</db:para>
<db:para>Replacing the specific and concrete with the generic and abstract always reduces content quality and effectiveness. You may decide that the economic benefits of content reuse outweigh the economic costs of less effective content, but you should at least be aware that there are real economic consequences to this choice.</db:para>
<db:para>Another potential quality problem comes with the loss of narrative flow. Not all content has or needs a lengthy narrative flow, but if you start breaking your content into reusable units and putting them back together in different ways, the narrative flow can easily be lost. In some cases you can avoid this problem by making the topics you present to your audience more self contained using an <db:indexterm><db:primary>Every Page is Page One</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>Every Page is Page One</db:secondary></db:indexterm>Every Page is Page One information design. But don’t assume that you have an effective Every Page is Page One design just because you have broken your content into reusable units. If that content was written in a way that assumed a narrative flow, it is not going to work when reused in a way that breaks that flow.</db:para>
<db:para>Finally, reuse can encourage you to come up with one way of telling our story that you present to all your audiences. But not all audiences are alike, and the way you tell your story to one audience may not work for another audience. Good content tells a good story to a particular audience. Two different tellings of the same story do not constitute redundant content if they address different audiences.</db:para>
</db:section>
<db:section>
<db:title>Cost traps</db:title>
<db:para>It is easy to see content reuse as a big cost saving. Reusing content means you do not have to write the same content over and over again. It is easy to add up the cost of all that redundant writing and regard that number as pure cost savings from a content reuse strategy.</db:para>
<db:para>But all of the reuse techniques create multiple artifacts that need to be managed. This includes both content and processing code. You need a mechanism to make sure that your content obeys the constraints required to make the pieces of content fit together reliably. You need a mechanism to make sure that way you have done reuse actually produces the documents you want. The cost of such management can be non-trivial and the consequences of the management breaking down can be significant.</db:para>
<db:para>While reuse is supposed to reduce the cost of modifying content when the subject matter changes, there are hidden cost traps here as well. It is often not until the subject matter changes that you find out if the content we have treated as common is really common. If not, you may have a complex management task to sort out what is really common and what isn’t. This can involve complex edits that then have to be tested and verified. If you get everything right, you can realize major savings when it comes time to modify your content, but if you get it wrong, it can multiply costs. Not only that, it also means that the money you spent factoring duplicate content out in anticipation a change that did not happen is wasted as well. Reacting to changes that actually happen is sometimes cheaper than preparing for multiple changes that never happen.</db:para>
<db:para>If your content collection and its web of reuse relationships is not audited and validated regularly, it can become chaotic over time and lose cohesion. This can make adding new content or changing existing content increasingly difficult and expensive.</db:para>
<db:para>Depending of the techniques you use, content reuse strategies can complicate the lives of writers, which may reduce the pool of writers you can use or reduce their productivity.</db:para>
<db:para>With many reuse techniques, the writer has to find the content to be reused each time. Not only does this take time and impose a piece of complexity on the writer, it is a cost that has to be paid every time the writer looks for content to reuse, whether they find any or not. Indeed, if a writer is expected to look for reusable content before they write anything at all, much of their time may be taken up with unsuccessful content queries. Reducing the expense of content queries, therefore, has to be a major component of any general reuse strategy. We will look more at this in <db:xref linkend="chapter.duplication"/>.</db:para>
<db:para>Localized and constrained forms of reuse can avoid this cost trap. For instance, reuse that is focused on producing different versions of a manual for different versions of a product, is doing reuse in constrained places for constrained reasons does not require frequent broad-based content queries to find reusable content. It merely requires that the writers on the project be aware of the specific reuse strategies being used in that project (unless the reuse has been factored out altogether).</db:para>
<db:para>Some content reuse techniques are easy to use in non-structured ways and early in a project it may seem like a non-structured approach to reuse speeds things up by allowing writers to reuse content wherever they find it. Over time, however, this approach can lead to a rat’s nest of dependencies and relationships between bits of content that makes it hard to update or edit the content with any confidence.</db:para>
<db:para>Once the cohesion and discipline of a content set starts to break down, the decline tends to accelerate. As it becomes harder to find content to reuse, more duplication occurs, which further complicates the search for reusable content, creating a vicious circle. As links and other content relationships break down, people tend to form ad hoc links and relationships to get a job finished, further tangling the existing rat’s nest. Under the gun, it is almost always easier to get the next document out by ignoring the discipline of the content set structure, but the effects of this are corrosive. Without consistent discipline, even in the face of deadlines, a reuse system can fail over time.</db:para>
<db:para>All of these issues can be managed successfully with the right techniques and the right tools, but they all introduce costs as well, both up-front costs and ongoing costs. Those costs have to be reckoned up and subtracted from the projected cost savings before you can determine if a content reuse strategy is really going to save you money.</db:para>
<db:para>One final trap: there may not be as much potential reuse as you thought. Some organizations have plunged into reuse strategies in hopes of a big payoff only to find that they had far less reusable content than they first thought. The cost of systems and the complexity added to the process by complex reuse techniques require a high level of reuse to pay off. If that level is not there, your systems will end up costing you more than it saves.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>Alternatives to reuse</db:title>
<db:para>There are three alternative to content reuse as a way of dealing with information that appears in more than one place:</db:para>
<db:variablelist>
<db:varlistentry>
<db:term>Duplicate but label</db:term>
<db:listitem><db:para>Allow the information to be expressed in more than one place but make sure that it is clearly and unambiguously labeled so that it is easy to find when updates are required. If this sounds like an inferior solution, reflect that in fact there is all kinds of repeated information in the content of any organization and reuse techniques cannot possibly eliminate all of it without adding way more complexity into the system than they eliminate. No matter how much reuse you do, you are still going to have to search your content set for instances of content that needs changing whenever a major change in subject matter occurs.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Reduce duplication</db:term>
<db:listitem><db:para>Content reuse is always content duplication. Reuse is predicated on the idea that you actually want to duplicate information in multiple publications. This is actually a somewhat out of date idea. In the paper world, it was important to give each customer a book with all the information they needed in it, even if the same information occurred in many different books. But in an online environment, you don’t need to duplicate information to make it available to every user who needs it. Maintaining the information once and linking to it whenever it is needed is a much less complex solution for a number of cases. To do this efficiently may require some of the techniques described in <db:xref linkend="chapter.linking"/>.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Combine and differentiate</db:term>
<db:listitem><db:para>Another approach to reducing duplication in your content is to combine information on multiple products into a single publication and differentiate them in the text. There are limits to this, obviously, and some organization got into content reuse specifically so that they could remove the complexity of multiple versions in a single manual. Still, there are times when it is an appropriate solution.</db:para></db:listitem>
</db:varlistentry>
</db:variablelist>
<db:indexterm class="endofrange" startref="idp1601934356"/><db:indexterm class="endofrange" startref="idp1601935252"/><db:indexterm class="endofrange" startref="idp1601934356x"/><db:indexterm class="endofrange" startref="idp1601935252x"/></db:section>
</db:chapter>
