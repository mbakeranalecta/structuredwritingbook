<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.metadata"><db:title>Metadata</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idm1964377756"><db:primary>metadata</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm1964377756x"><db:primary>concept</db:primary><db:secondary>metadata</db:secondary></db:indexterm>



<db:para>We live in the age of metadata, so much so that the word metadata has almost come to replace the word data itself and has come to be applied to almost any form of data that describes a resource. For example, we hear a lot about law enforcement getting access to metadata related to phone calls, which simply means the data about which number called which number and for how long.</db:para>
<db:para>The standard definition of metadata is “data that describes data”, but that definition misses the central point. Metadata does not merely describe data, metadata creates data. Metadata turns an undifferentiated set of values into useful data by telling us what they mean.</db:para>
<db:para>In the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, the ingredients of a recipe are just list items. The content of those list items are just strings of characters.</db:para>
<db:programlisting language="sam">
section: Ingredients
    * 12 eggs
    * 2 qt water
</db:programlisting>
<db:para>Adding <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain markup allows us to specify to algorithms exactly what these strings mean.</db:para>
<db:programlisting language="sam">
ingredients:: ingredient, quantity, unit
    eggs, 12, each
    water, 2, qt
</db:programlisting>
<db:para>This subject domain markup is metadata, and it turns what were just list items into a set of ingredient data. It is not that the data existed and the metadata came along afterward to describe it. It is that the data exists as data only because the metadata is there to describe it. While a human reader can recognize that the values in the list are ingredients, based on their familiarity with the recipe format, an algorithm sees only strings of characters until we apply the metadata that lets it recognize them as ingredients.<db:footnote>
<db:para>I am talking here about ordinary algorithms: simple rules written by humans to govern the processing of well defined data. Advances in AI are making inroads on enabling algorithms to read the way humans do. A sufficiently advanced AI algorithm might not need this level of explicit metadata to recognized list items are ingredients. Technically, though, such an AI would still be depending on metadata to interpret this data. It would just be using the same metadata that humans use, which we might fairly, if briefly, characterize as a combination of grammar and memory. Until such AIs are available to us, though, structured writing allows us to add more explicit metadata to content to make it accessible to simpler algorithms.</db:para>
</db:footnote></db:para>

<db:para>Structured writing is writing that obeys constraints and that records the constraints it obeys, so as to create an interface between partitions in your content system. In other words, structured writing is the application of metadata to content which turns content into data by constraining the interpretation of the content. If structured writing is writing that obeys constraints and records the constraints it obeys,  Metadata is the means by which those constraints are recorded. Metadata constrains the interpretation of values in content, making them accessible as data.</db:para>
<db:para>This is the basis for all partitioning of the complexity of content creation. The metadata we attach to content allows us to pass the content to different people or processes without letting any of the complexity drop. (This includes search engines and other downstream processes that we do not control but can inform.) We cannot partition complexity safely if we drop any of the complexity in the process. Metadata is how we ensure that all the complexity has been successfully transferred from one partition to another.</db:para>
<db:para>Another way of looking at this is: metadata preserves the information needed to make decisions about a piece of content. Preserving the fact that a piece of text records an ingredient lets us make decisions later about how to format ingredient listings or about which recipes to include in a collection. Explicitly recording which parts of that string are the quantity and unit of measure lets us make a decision later about which set of weights and measures should be used when presenting the recipe to a reader, allowing us to publish the content in other markets.  Partitioning the content system means moving complexity – decisions – from one partition to another. Metadata is how we record and transfer the information required to do that. If you want to transfer a decision from a writer to another person or process, for instance, you have to ask what information you need the writer to provide to that person or process in order for them to make and execute that decision. That information is the metadata that needs to be added to the content.</db:para>
<db:para>The subject domain <db:code>ingredient</db:code>, <db:code>quantity</db:code>, <db:code>unit</db:code> markup is metadata that turns the ingredients list into ingredient data. But this is is not to say that a <db:code>list</db:code> structure is not metadata also. <db:code>list</db:code> is document domain metadata. It formally identifies a piece of text as a list item. It allows us to partition the formatting of lists from the writing of recipes, and all kinds of other content. This makes it easy to write algorithms that recognize lists which allows you to reliably format list items in whatever media you choose to publish in. The operations we can perform on list item data are obviously far less sophisticated than those we can perform on ingredient data, but list item data is still data and still created by metadata.</db:para>
<db:para>There is a very important point here: The same set of values, the same string of letters, words, and numbers, can be turned into different kinds of data by applying different kinds of metadata to it. This means that we can choose what kind of data we turn our content into by choosing what type of metadata we apply to it. Moving content from one structured writing domain to another means turning it into different kinds of data by applying different metadata to it. By turning it into different kinds of data, we make it accessible to different kinds of algorithms.</db:para>
<db:section>
<db:title>The recursive nature of metadata</db:title>
<db:para>Metadata is a confusing concept because metadata is recursive. If metadata is the data that  creates data, then as data it too must be created by metadata. In other words, if the line <db:code>ingredients:: ingredient, quantity, unit</db:code> turns the ingredient lines into metadata in this markup:</db:para>
<db:programlisting language="sam">
ingredients:: ingredient, quantity, unit
    eggs, 12, each
    water, 2, qt
</db:programlisting>
<db:para>Then what makes <db:code>ingredients:: ingredient, quantity, unit</db:code> a piece of metadata and not just another string of characters? There is another piece of metadata that says that that string is a record set definition, and that metadata is the <db:indexterm><db:primary>SAM</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SAM</db:secondary></db:indexterm>SAM syntax specification. This metadata is different in that it is not part of the same file as the data it is defining, but metadata can be both inline and separate. Thus one piece of data can have a whole cascade of metadata defining it and the metadata that defines it.</db:para>
<db:para>In structured writing, we add structure to content to replace the things we have factored out. That structure is metadata to the data that is the text of the file. But if we store that file in any kind of repository, the information that identifies the file in that repository is metadata to the file as a whole. If the structure of the file is described by a <db:indexterm><db:primary>schema</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>schema</db:secondary></db:indexterm>schema, the schema is also metadata for the file.</db:para>
<db:para>But we’re not done yet because the specification of the schema language is the metadata that tells you what the schema means.  And then of course, there is the specification of the markup to consider. The XML specification is part of the metadata tree for every XML document in existence. And we are still not be done, because the XML specification uses a formal grammar description language, called <db:indexterm><db:primary>BNF</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>BNF</db:secondary></db:indexterm>BNF. The BNF specification is metadata for the schema language description.</db:para>
<db:para>How do we break out of this infinite recursion of metadata? Data is information that has been formalized for interpretation by algorithms. Fortunately, human beings can understand natural language without that degree of formalization. Eventually, then, we reach a point where the last piece of metadata is not described by metadata but by narrative. That narrative document essentially bootstraps the whole metadata cascade that eventually yields pieces of data that can be unambiguously interpreted by algorithms.</db:para>
<db:para>So, every piece of data has a spreading tree of metadata supporting it, which, if traced to its roots, eventually leads to narrative documents that explain things in human terms. Thus the XML specification combines narrative definitions with BNF, if if we go to the BNF specification we will find the plain narrative that describes BNF.</db:para>
<db:para>Data is a formalization of narrative and it is this relationship that allows structured writing to move information back and forth between data and narrative forms.</db:para>
</db:section>
<db:section>
<db:title>Where should metadata live?</db:title>
<db:para>One of the great questions about metadata is where it should live: with the data it describes or separate from it? As we noted above, much of the metadata in the metadata cascade supporting every piece of data is stored in a separate file. Either the data points to the metadata (as when an XML document declares what schema it uses), the metadata points to the data (as when a content management system store a metadata records describing a document), or the metadata is embedded in the content itself (as in structured writing).</db:para>
<db:para>The issue of where metadata should live is closely related to the issue of how responsibilities are partitioned in your content system. Since metadata is how complexity is transferred safely from one partition to another, the responsibility for creating the metadata lies with the person or process in the originating partition, while the metadata requirements are dictated by the needs of the receiving partition. By adjusting how the system is partitioned, you can adjust how onerous the metadata requirements are on any one actor in the system. The location of the metadata, therefore, is essentially dictated by the partitioning. It is located in the place that achieves the desired partitioning of complexity for the particular content system.</db:para>
<db:para>Most early graphic file formats only stored the image. Most modern format also store extensive metadata about the image. The pictures you take with your digital camera include lots of information about the camera and the settings that were used to take the shot, all of which can help rendering algorithms and graphic editing applications to handle the raw image data better. Having that metadata embedded in the file ensure that the picture and its metadata stay together. Separating them would greatly complicate the system. Keeping the image metadata in the image file is better partitioning than keeping it separate.</db:para>
<db:para>Unfortunately, tools are often designed with other priorities in mind. For one thing, many tool developers think almost exclusively in relational database terms. The idea that you could store metadata anywhere other than relational tables is foreign to them. For another, system vendors have a vested interest in a partitioning of the process that requires every user to be interacting with their system all day long because this forces people to buy every contributor a licensed seat for their tool. Both these things encourage them to implement models in which the metadata is separate from the content, ensuring that you need access to the system to have access to the metadata.</db:para>
<db:para>For example, should the history of a file be stored in the file or in the repository? Storing it in the file lessens the file’s dependence on the repository and makes it more portable. But a repository vendor may prefer to sell you a system in which to uninstall their repository would be to lose all your file history. If file status information is only stored in a workflow system, for instance, it is very hard to move away from that system. It it is stored in the file, it is easy to move away, and also to edit when not connected to the system, which can save you on licenses.</db:para>
<db:para>In the case of the photo, the metadata is in the file because the camera is the best placed instrument to record it. This is the best partitioning of the complexity of the recording and transferring this information, both in terms of its convenience of creation and in terms of ease of access and management. The location of the metadata should be determined by the best partitioning of the content system, not the convenience of a tool vendor.</db:para>
<db:para>Writing your content in the subject domain means that more of your metadata is stored in the same file as the content, increasing its independence and portability. Also, as we have seen, the use of subject domain structures can lessen the need for management domain structures for algorithms like <db:indexterm><db:primary>single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>single sourcing</db:secondary></db:indexterm>single sourcing and <db:indexterm><db:primary>content reuse algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content reuse algorithm</db:secondary></db:indexterm>content reuse, which reduces the need for external management domain metadata. All of this contributes to improved functional lucidity, referential integrity, and change management.</db:para>
<db:para>But this does not mean that all metadata related to an piece of content belongs in the content file. For example, when we import a graphic into a document, we often give it a caption or a title and we specify the size it should be displayed at. These are all metadata about the graphic, but it would not make sense to include this information in the graphic file itself. This information is not actually describing the graphic itself, it is describing its relationship to the current document. In a different document, the same graphic might be displayed at a different size with a different caption or title. This information is therefore included in the file that imports the graphic, not the graphic file itself. In other words, the metadata is stored on the right side of the relationship between the two content objects. This is simply good partitioning. (In <db:xref linkend="chapter.wide"/> we  looked at another way of partitioning this metadata, again based on the nature of the relationship between the files, and on the way that the complexity of the content system is partitioned.)</db:para>
<db:para>Storing the metadata on the right side of the partition means that there are definitely types of metadata that belong on the repository or content management side of the relationship as well. If you store your content in a version control system (VCS) such as GIT (something that is increasingly popular in the “treat docs like code” movement), the VCS will record the difference between each version of the file you submit as well as who did each commit of the file. This will allow the VCS to do valuable management things like tell you exactly who changed an individual line of a file and on what date they changed it. Storing such metadata in the file itself would make it impossible complex to write. Again, the metadata is stored on the right side of the partition and the partitioning of complexity is correct.</db:para>
</db:section>
<db:section>
<db:title>Ontology</db:title>
<db:para>Finally it is worth saying a word about ontology. Ontology (in the information processing sense) is an attempt to create a formal mapping of the relationships between entities in the real world such that algorithms can draw inferences and reach conclusions about them.</db:para>
<db:para>In many way, therefore, an ontology is an attempt to do for algorithms what narrative does for humans. After all, one of the main reasons that we read is so that we can understand the world better, understand what various objects and institutions are and how they relate to each other, statically and in action, so that we can decide what to do.</db:para>
<db:para>In some sense, therefore, ontology is the ultimate in <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain markup. Indeed, one should also be able to generate human-readable narrative from an ontology, given a sufficiently sophisticated algorithm and a sufficiently sophisticated ontology.</db:para>
<db:para>All of this is very much outside our scope in this book. <db:indexterm><db:primary>Subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>Subject domain</db:secondary></db:indexterm>Subject domain markup is an attempt to capture certain aspects of the subject matter of a work. But it is not an attempt to model the argument of a work. Consider the passage:</db:para>
<db:programlisting language="sam">
In {Rio Bravo}(movie), {the Duke}(actor "John Wayne") 
plays an ex-Union colonel.
</db:programlisting>
<db:para>Here the subject domain markup formalizes the fact that Rio Bravo is a movie and that “the Duke” is a reference to the actor John Wayne. It does not model the relationship between the two. An ontology would want to model the “starred in” relationship between John Wayne and Rio Bravo, whereas  <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain structured writing is normally content to leave this to the text.</db:para>
<db:para>Similarly, this <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain markup does not bother to denote that Union is a reference to both a country and its armed forces, and that colonel is a rank in those armed forces. It does not denote these things because this particular markup language is concerned with movies and these facts are entirely incidental to the movie business. Actors, directors, and movies are significant subjects in the movie review domain. The names of nations and their armies that figure in the plot of individual movies are incidental in that domain. A full ontological treatment of the passage above, however, would need to model those relationships.</db:para>
<db:para>Structured writing does make certain aspects of content clear to algorithms, but not with the intention of making it possible for the algorithms to make real-world inferences and decisions based on the information in that content. It only does what is necessary to partition and redirect content complexity in a content system in which human authors to use algorithms as tools to improve the quality of the content they prepare for human readers.</db:para>
<db:indexterm class="endofrange" startref="idm1964377756"/><db:indexterm class="endofrange" startref="idm1964377756x"/></db:section>
</db:chapter>
