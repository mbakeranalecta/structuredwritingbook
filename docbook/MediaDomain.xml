<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.media-domain"><db:title>Writing in the Media Domain</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idm1886912892"><db:primary>media domain</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm1886912892x"><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idm1886908668"><db:primary>document domain</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm1886908668x"><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idm1886913532"><db:primary>subject domain</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm1886913532x"><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idm1886907388"><db:primary>formatting algorithm</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm1886907388x"><db:primary>concept</db:primary><db:secondary>formatting algorithm</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idm1886904316"><db:primary>presentation algorithm</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm1886904316x"><db:primary>concept</db:primary><db:secondary>presentation algorithm</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idm1886902780"><db:primary>rendering algorithm</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm1886902780x"><db:primary>concept</db:primary><db:secondary>rendering algorithm</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idm1886901884"><db:primary>structured writing domains</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm1886901884x"><db:primary>concept</db:primary><db:secondary>structured writing domains</db:secondary></db:indexterm>



<db:para>In the media domain, structures relate to the medium in which the content is displayed. Such content is often considered unstructured, but all content has structure, and you can find all the patterns and techniques of structured writing in the media domain. This makes it a good place to begin our study of the fundamentals of <db:indexterm><db:primary>structured writing</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>structured writing</db:secondary></db:indexterm>structured writing.</db:para>
<db:para>At its most basic, a hand guiding a pen over paper or a chisel into stone is working in the media domain through direct physical interaction with the medium. The writer guiding that pen both makes and executes decisions about the shape of letters, along with all the other decisions that fall on a writer.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/handwritten.jpg" contentwidth="3in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/handwritten-photo-ebook.jpg"/></db:imageobject><db:textobject><db:para>Photo of the word Dog.</db:para></db:textobject></db:mediaobject>
<db:para>The closest you get to pen and paper in the computer world is to use a paint program to directly place dots on the screen. You select the pen tool and use your mouse or a stylus to write. This records the text as a matrix of dots.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/handwritten-bitmap.png" contentwidth="1.5in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/handwritten-bitmap.png"/></db:imageobject><db:textobject><db:para>Showing what the word Dog looks like when drawn freehand in a raster graphics program.</db:para></db:textobject></db:mediaobject>
<db:para>There is little structure here. There’s just a pattern of dots, which represents text characters only in the sense that humans can recognize the pattern as text. The computer records the effect of your decisions about letter shapes, but it has no idea that they are letters.</db:para>
<db:para>This is an inefficient way to write. You can work faster if you use the paint program’s text tool.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/typed-bitmap.png" contentwidth="1.5in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/typed-bitmap.png"/></db:imageobject><db:textobject><db:para>Showing what the word Dog looks like when typed using the text tool in a raster graphics program.</db:para></db:textobject></db:mediaobject>
<db:para>The text tool is our first step into structure. It partitions the complexity of forming letter shapes from the task of writing letters and directs that complexity to an algorithm in the paint program, which does a better and more efficient job of it than the writer does, as you can see from the much neater letter shapes in the sample above. However, those letters are still recorded as a set of dots, not as characters, so you can’t go back and edit your text as text, only as dots. The paint program forms the letter shapes, but it records dots. Therefore, it discards the partitioning when it records the content.</db:para>
<db:para>This failure to maintain the partitioning is a common problem in structured writing. For example, some <db:indexterm><db:primary>wiki</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>wiki</db:secondary></db:indexterm>wiki systems allow you to define content templates but don’t record the structure of the template in the resulting page. The ability to maintain the partitioning of complexity is a key feature of a mature and reliable content system, but it is often neglected.</db:para>
<db:para>To partition the complexity of forming and editing letter shapes completely, you need to move away from dots and start using a tool that records characters as characters. You could go to a text editor, but a text editor does not keep any formatting information,<db:footnote>
<db:para>Unless you add markup to your text, but that would be getting ahead of ourselves.</db:para>
</db:footnote> thus dropping the complexity of shaping letters, not partitioning it. For most publishing purposes, plain text is inadequate. We need to maintain the ability to format the document.</db:para>

<db:para>One type of program that records text with formatting attached is a vector graphics program. A vector graphics program creates graphics as a collection of objects. For example, to represent a circle, a vector graphics program records an abstraction: a mathematical formula that encodes the essential properties of a circle – the center, diameter, line weight, etc. – rather than a set of dots. The program partitions the complexity of circle drawing into the circle object. The computer then lets you manipulate that abstraction as an object, only rendering it as actual dots when the graphic is displayed on screen or paper.</db:para>
<db:figure xml:id="objects-vs-dots"><db:title>Objects vs. dots</db:title><db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/Object-vs-dots.svg" contentwidth="4.5in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/Object-vs-dots.png"/></db:imageobject><db:textobject><db:para>Vector circle compared with dot circle.</db:para></db:textobject></db:mediaobject></db:figure>
<db:para>In <db:xref linkend="objects-vs-dots"/> you see a circle as an object displayed in a vector graphics program (Inkscape) on the left and a circle as a set of dots in a graphics program (Microsoft Paint) on the right.</db:para>
<db:para>In a typical vector graphics program, a shape is rendered into dots on screen instantly as you draw or edit the shape. Nonetheless, the computer is storing data describing the shape, not a circular pattern of dots, as it would in a paint program. In structured writing we call this <db:indexterm><db:primary>separating content from formatting</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>separating content from formatting</db:secondary></db:indexterm>separating content from formatting. The mathematical abstraction of a circle is the content; the dots that represent it on screen are the formatting or, rather, the result of applying formatting to the object.</db:para>
<db:para>By partitioning aspects of the content into a form that algorithms can work with, we can make it easier to create and manage the content. All the principles of structured writing are present in this basic piece of computer graphics.</db:para>
<db:section>
<db:title>Partitioning font information</db:title>
<db:para>Just as a vector graphics program represents a circle as a circle object, it represents text as a text object. A text object is a rectangular area that contains characters. It has numerous <db:indexterm><db:primary>media-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media-domain</db:secondary></db:indexterm>media-domain properties, such as margins, background and foreground colors, the text string, and the font face, size, and weight used to display that text (see <db:xref linkend="text-object"/>).</db:para>
<db:figure xml:id="text-object"><db:title>A vector graphics text object</db:title><db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/text-object.png" contentwidth="5in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/text-object.png"/></db:imageobject><db:textobject><db:para>A text object in a vector graphics program, showing object properties.</db:para></db:textobject></db:mediaobject></db:figure>
<db:para>A vector graphics program displays text in a chosen font. If you change the value of the text object’s font attribute, it immediately redraws the text in the new font. Not only has the drawing of letter shapes been partitioned, but the partitioning has been recorded in the source file, meaning you can change the font and font attributes as much as you like without editing the text itself.</db:para>
<db:para>The vector graphics program needs to know the shape of each character to render a text object in the media domain. However, that information is not stored as part of the text object. The representation of the text in the paint program includes the shape of the letters but in the vector graphics program it does not. That information has been partitioned out into a font file.</db:para>
<db:figure xml:id="merge_text_and_font"><db:title>Merging text and font information</db:title><db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/TextPlusFont.svg" contentwidth="4in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/TextPlusFont.png"/></db:imageobject><db:textobject><db:para>Diagram showing how information from a font file is combined with information from a content file to create formatted output.</db:para></db:textobject></db:mediaobject></db:figure>
<db:para>The shapes of the letters (technically, <db:emphasis>glyphs</db:emphasis>) that make up the font are stored in font files. Font files consist of a set of shape objects that describe each glyph together with metadata such as the name of the font and the name of each glyph. To display the text, the graphics program uses information in the text object to identify the correct font file, locate the right glyph in that font file, and then draw the appropriate glyph on the current medium (see <db:xref linkend="merge_text_and_font"/>).</db:para>
<db:para>Every modern operating system partitions the rendering of fonts into a separate font system that any application can use. By transferring font rendering complexity to the font system, the OS designers make it easier for developers to create applications that work with formatted text. Rather than programming font handling themselves, programmers call operating system APIs (<db:indexterm><db:primary>Application Programming Interfaces</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>Application Programming Interfaces</db:secondary></db:indexterm>Application Programming Interfaces) to do it for them. It also makes things easier for font designers, since it partitions off the problems of installing fonts and making them available to applications.</db:para>
<db:para>Font handling is a particularly powerful example of partitioning complexity, because it means that professionals working in the content domain – font-designers, tool-developers, and writers – no longer need to communicate or coordinate to contribute to the content delivery process.</db:para>
<db:para>This is a recurring pattern. We partition information that is constant for a particular application into a separate file – the shape of the capital letter C is consistent, no matter how many times it occurs in a text – so we can keep that information separate from the text. This simplifies the format of the information and keeps the downstream presentation more consistent.</db:para>
<db:para>Designing a content structure, regardless of the domain you choose to work in, essentially consists of identifying the places in the content where we can partition out these invariant properties into separate structures, distributing complexity to where it can be most effectively handled.</db:para>
<db:para>A vector graphics program does a great job of partitioning formatting complexity from text. But what happens when you want to create a document that spans multiple pages of if you edit the text and need to change how it flows from one page to the next? A vector graphics problem will force you to handle these pagination issue by hand. To factor them out, we need to look to the document domain.</db:para>
<db:indexterm class="endofrange" startref="idm1886912892"/><db:indexterm class="endofrange" startref="idm1886908668"/><db:indexterm class="endofrange" startref="idm1886913532"/><db:indexterm class="endofrange" startref="idm1886907388"/><db:indexterm class="endofrange" startref="idm1886904316"/><db:indexterm class="endofrange" startref="idm1886902780"/><db:indexterm class="endofrange" startref="idm1886901884"/><db:indexterm class="endofrange" startref="idm1886912892x"/><db:indexterm class="endofrange" startref="idm1886908668x"/><db:indexterm class="endofrange" startref="idm1886913532x"/><db:indexterm class="endofrange" startref="idm1886907388x"/><db:indexterm class="endofrange" startref="idm1886904316x"/><db:indexterm class="endofrange" startref="idm1886902780x"/><db:indexterm class="endofrange" startref="idm1886901884x"/></db:section>
</db:chapter>
