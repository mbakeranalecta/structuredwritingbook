<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.media-domain">
<db:title>Writing in the Media Domain</db:title>


<db:para>The media domain is the structured writing domain in which the structures relate to the media in which the content is displayed. Such content is often considered “unstructured”, but all content has structure, and we can actually find all the patterns and techniques of structured writing in the media domain. This makes it a good place to study the fundamentals of structured writing.</db:para>
<db:para>At its most basic, a hand guiding the pen over paper or chisel into stone is working in the media domain through direct physical interaction with the media. The writer guiding that pen is both making an executing decisions about the shape of letters, along with all the other decisions they make as a writer.</db:para>
<db:mediaobject><db:imageobject><db:imagedata fileref="../graphics/handwritten.jpg" contentwidth="5.25in" align="left"/></db:imageobject></db:mediaobject>
<db:para>The closest you can get to pen and paper in the computer world is to use a paint program to directly place dots on the screen. You can select the pen tool and use your mouse or a stylus to write your text. This will record the text as a matrix of dots.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/handwritten-bitmap.png" contentwidth="2in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/handwritten-bitmap.png"/></db:imageobject><db:textobject><db:para>Showing what the word Dog looks like when drawn freehand in a raster graphics program.</db:para></db:textobject></db:mediaobject>
<db:para>There is very little structure here. We are recording a pattern of dots. Those patterns of dots are text characters only in the sense that the patterns are recognizable as characters to the human eye. The computer is recording the effect of the author’s decisions about letter shapes, but he computer has no idea they are letters.</db:para>
<db:para>This is a pretty inefficient way to write. You can work faster if you use the paint program’s text tool.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/typed-bitmap.png" contentwidth="2in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/typed-bitmap.png"/></db:imageobject><db:textobject><db:para>Showing what the word Dog looks like when typed using the text tool in a raster graphics program.</db:para></db:textobject></db:mediaobject>
<db:para>The text tool is our first step into structure. It partitions off the complexity of forming letter shapes from the task of writing letters and directs that complexity to an algorithm in the paint program, which does a better and more efficient job of it than the author does, as you can see from the much neater letter shapes in the sample above. However, those letters are still recorded as a set of dots, not as characters, so you can’t go back and edit your text as text, only as dots. The act of forming letter shapes has been partitioned off, but the partitioning in not maintained in how the content is recorded.</db:para>
<db:para>This failure to maintain the partitioning of complexity in how content is recorded is a problem you may encounter many times in structured writing. For example, some wiki systems allow you to define content templates but do not record the structure of the template in the resulting page. The ability to maintain the partitioning of complexity is one of the key features of a mature and reliable content system, and one that is often neglected in the name of using simpler tools.</db:para>
<db:para>To partition the complexity of forming and editing letter shapes completely, you need to move away from dots and start working in a program that records characters as characters. You could go to a text editor, but a text editor does not keep any formatting information (unless you create markup – but that would be getting ahead of ourselves). That would not be partitioning the letter shape complexity, but dropping it. For most publishing purposes, plain text is inadequate. We need to maintain the ability to format the document.</db:para>
<db:para>One type of program that lets us record text as text and also lets us attach formatting to the text is a vector graphic program. A vector graphics (or “draw”) program creates graphics as a collection of  objects (“vector” meaning the mathematical representation of a shape or line). For example, it allows you to create a circle as a shape, described mathematically in computer memory, rather than as a set of dots. Rather than recording an actual circle, the program records an abstraction of a circle: the essential properties needed to reproduce an actual circle on a media, such as its center, diameter, and line weight. In other words, it partitions all the complexity of circle drawing into the circle object. The computer then lets you manipulate that abstraction as an object, only rendering it as actual dots when the graphic is displayed on screen or paper.</db:para>
<db:figure xml:id="objects-vs-dots"><db:title>Objects vs. dots</db:title><db:mediaobject><db:imageobject><db:imagedata fileref="../graphics/object-vs-dots.png" contentwidth="5.25in" align="left"/></db:imageobject><db:caption>
<db:para>A circle as an object, displayed in a vector graphics program (Inkscape), left, vs. a circle as a set of dots in a raster graphics program (Microsoft Paint), right.</db:para>
</db:caption></db:mediaobject></db:figure>
<db:para>In a typical vector graphics program, a shape is rendered into dots on screen instantly as you draw or edit the shape. Nonetheless, the computer is storing data describing the shape, not a circular pattern of dots, as it would in a paint program. This is an instance of what in structured writing is called separating content from formatting. The mathematical abstraction of a circle is the content; the dots that represent it on screen are the formatting, or rather, the result of applying formatting to the object.</db:para>
<db:para>By partitioning aspects of the content into a form that algorithms can work with, we can make it easier to create and manage the content. All the principles of structured writing are present in this basic piece of computer graphics.</db:para>
<db:section>
<db:title>Partitioning font information</db:title>
<db:para>Just as a vector graphics program represents a circle as a circle object, it represents text as a text object. A text object is a rectangular area that contains characters. It has numerous media domain properties, such as margins, background and foreground colors, the text string, and the font face, size, and weight used to display that text, as in this example from InkScape:</db:para>
<db:figure xml:id="text-object"><db:title>A vector graphics text object</db:title><db:mediaobject><db:imageobject><db:imagedata fileref="../graphics/text-object.png" contentwidth="5.25in" align="left"/></db:imageobject><db:caption>
<db:para>A text object in a vector graphics program, with object properties shown.</db:para>
</db:caption></db:mediaobject></db:figure>
<db:para>A vector graphics program displays text in a chosen font. If you change the value of the text object’s font attribute, it will immediately redraw the text in the new font. Not only has the drawing of letter shapes been partitioned, but the partitioning had been preserved in the way the content has been recorded in the source file, meaning we can redraw the letter shapes as much as we like without editing the text.</db:para>
<db:para>The shapes of the individual letters in the font are required information for rendering the text object in the media domain. However, they are not stored as part of the text object. The representation of the text in the paint program includes the shape of the letters. In the vector graphics program it does not. That information has been partitioned out.</db:para>
<db:para>The shape of the letters (technically, “glyphs”) that make up the font are stored separately in font files. Font files consist of a set of shape objects that describe each glyph, together with metadata such as the name of the font and the name of each glyph. To actually display the text block on screen, the graphics program (or rather the graphics system API to which it delegates this task) combines information from the font file with information from the text object by matching the metadata to find the right font and character, and then drawing the appropriate glyph on the current media.</db:para>
<db:figure xml:id="merge_text_and_font"><db:title>Merging text and font information</db:title><db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/TextPlusFont.svg" contentwidth="4in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/TextPlusFont.png"/></db:imageobject><db:textobject><db:para>Diagram showing how information from a font file is combined with informaiton from a content file to create formatted output.</db:para></db:textobject><db:caption>
<db:para>The vector graphic text object factors out letter shapes to a separate font file.</db:para>
</db:caption></db:mediaobject></db:figure>
<db:para>The font system represents a partitioning of the complexity of rendering formatted text that has been built into every modern operating system. By partitioning this complexity and transferring it to the operating system, the OS designers made it easier for every developer who wants their application to work with formatted text. Rather than programming font handling themselves, they simply call operating system APIs to do it for them. It also makes it much easier for anyone who wants to design fonts, since it partitions off the problems of installing fonts and making them available to applications. These are a particularly powerful example of partitioning and transferring complexity because they mean that the various sets of people, all working in the content domain – font-designers, tool-developers, and writers – no longer have to know anything about how the others work and no longer need to communicate or coordinate in order to make their individual contributions to the overall content delivery process.</db:para>
<db:para>This is a pattern we will see over and over again in the partitioning of content complexity. In order to simplify the objects that we create to store our content, we take part of the information needed to do the final rendering, and partition it to a separate file. By partitioning out information that is constant for a given application (the shape of a capital D is the same for all capital D’s for text in a given font), we simplify the format of the information we are preparing and keep the downstream presentation more consistent.</db:para>
<db:para>Designing a content structure, regardless of the domain you choose to work in, essentially consists of identifying the places in the content where we can partition out these invariant properties into separate structures, with the aim of distributing complexity – decision making and execution – to the most effective place.</db:para>
</db:section>
<db:section>
<db:title>Partitioning the complexity of pagination</db:title>
<db:para>Writing a document in a vector graphics program is certainly better than in a paint program – there are fewer decisions for the writer to make and execute – but you quickly run into a problem if you try to write a document that covers more than one page. A vector graphics program works purely in the media domain, and pretty much lets you put shapes and text boxes anywhere you like. This certainly allows you to create a new page whenever you need one, simply by creating a new drawing. But what happens when you want to edit the text and need to change how it flows from one page to the next? Pagination is a complex process, one requiring a lot of decisions about how and where to break, and it is tedious and time consuming to execute those decisions by hand. So we look for a way to partition that complexity from the writing task and distribute it elsewhere, preferably to an algorithm.</db:para>
<db:para>Word processors and desktop publishing programs partition the pagination process from the writing process by introducing some document domain constraints. A document is made up of a series of pages that have margins and contain text flows. Text flows are made up of blocks (paragraphs, headings) inside of which text can flow, even from one page to the next. Common features like tables are supported as objects than can exist in text flows. New pages are created automatically as text expands. In other words, the application creates a bunch of text containers and manages the basic decisions about how to fit text into those containers. This leaves authors free to focus on writing and leave pagination decisions to the program.</db:para>
<db:para>Pages, paragraphs, headings, and tables, are all document domain objects. Rather than working on a blank slate, as you do in a graphics program, the writer is now working within the constraints of these document domain objects.  These constraints remove or constrain decisions about positioning of elements, which makes creating documents faster and more consistent. Structured writing is about making content that obeys constraints, and these basic document domain constraints are the next step in that journey.</db:para>
<db:para>Partitioning off the pagination problem is not without its drawbacks, however. There are certain page layout effects that are difficult or impossible to achieve in Word or FrameMaker because you have given up some of the liberty of a vector graphics program. We also gave up some liberty when we moved from raster to vector graphics, which is why photo editing, which requires adjusting individual pixels, is done in raster rather then vector format.</db:para>
<db:para>There is an important lesson here. Handing regular decision making – meaning decisions based on rules – to an algorithm is a big advantage. But if you need to make completely ad hoc decisions on the same subject, you may no longer have available the structures to express an arbitrary decision. We are starting to see that different partitioning of the content creation process is appropriate for different kinds of content. There is no one universal correct partitioning and distribution of content complexity that works for every type of content or every organization. This will continue to be the case as we look at more advanced forms of structured writing.</db:para>
</db:section>
</db:chapter>
