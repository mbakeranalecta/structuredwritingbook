<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.extract"><db:title>Extract</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idm1421955596"><db:primary>extract</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm1421955596x"><db:primary>algorithm</db:primary><db:secondary>extract</db:secondary></db:indexterm>




<db:para>A great deal of the content we produce, particularly technical and business content, is essentially a report in human language on the specific features of a product, process, or data set. Much of the data that defines those things is contained in some kind of formal data set, such as a database or software source code.</db:para>
<db:para>In a traditional approach to publishing, a large amount of complexity and work is involved in researching and recreating the information in those systems in a content format, and then in trying to keep that content in sync with the original source.</db:para>
<db:para>The source data for those systems is, in effect, subject domain content for those products, processes, and data sets. Rather than researching and recreating that content, we can use structured writing techniques to extract information from those sources to create and/or validate content. This is essentially content generation based on externally sourced data. It partitions and redirects the complexity of dealing with these sources away from authors towards information architects and content engineers who create the algorithms that extract the data and generate content from it.</db:para>
<db:section>
<db:title>Tapping external sources of content</db:title>

<db:para>I have talked throughout this book about moving content from the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain to the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain and from the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain to the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain. We have seen the advantages that come from creating content in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, and we have looked at the processing algorithms that can use <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain content to produce various kinds of publications in different media.</db:para>
<db:para>Subject domain content is simply content that is created and annotated in structures that are based on the subject matter rather than on the structure of documents or media. Subject domain structures tell you what the content is about, rather than how it should be published. You can therefore write algorithms that processes it based on what it is about rather than how it is presented. It allows you to transfer and delay decisions about presentation and formatting and have algorithms make those decisions based on the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain markup.</db:para>
<db:para>Any data source that is contained in <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain structures is a source of subject domain content, whether it was intended to produce content from or not. This includes virtually all databases and quite a bit of software code. It also includes all authored content anywhere available (under an appropriate license) that contains any usable subject domain structures or annotations. All of this is potential material for generating content as part of your overall publishing process. As such, the extract algorithm can work effectively with many other structured writing algorithms.</db:para>
<db:para>As a source of <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain content, the extract algorithm also naturally <db:indexterm><db:primary>separates content from formatting</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>separates content from formatting</db:secondary></db:indexterm>separates content from formatting and contributes to the <db:indexterm><db:primary>differential single sourcing algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>differential single sourcing algorithm</db:secondary></db:indexterm>differential single sourcing algorithm.</db:para>
<db:para>By tapping existing information to build content, the extract algorithm also works hand in hand with the <db:indexterm><db:primary>content reuse algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content reuse algorithm</db:secondary></db:indexterm>content reuse algorithm. In fact, it is really the highest expression of reuse, since it not only reuses content in the content system, but information from the organization at large, or even beyond the organization – a process that further reduces duplication within the organization.</db:para>
<db:para>Because the extract algorithm taps directly into external sources of information, it is also a great source of information for content auditing (which I will talk about in <db:xref linkend="chapter.audit"/>). At one level, it provides a canonical source of information to validate existing content against. At another level, it factors out part of the conformance problem from the authoring function. It transfers the entire responsibility for maintaining the information to the creators of the source you are extracting content from, which is a responsibility they already have.</db:para>
</db:section>
<db:section>
<db:title>Information created for other purposes</db:title>

<db:para>There is nothing new, of course, about generating content from database records. Database reporting is a highly important and sophisticated field in its own right and it would be entirely correct to characterize it as a type of structured writing. What sets it apart, largely, from other structured writing practices, is that the databases it reports on serves other business purposes besides being sources of content. An insurance company policy database, for instance, may be used to publish custom benefit booklets for plan participants but it is also used for processing claims. The design of the structures and data entry interfaces of these systems has tended to fall outside the realm (and the notice) of writers and authoring system designers.</db:para>
<db:para>This is a pity, because it has often resulted in organizations developing separate processes, tools, and repositories for content creation in which the information already contained in databases is researched, validated, recorded, and managed entirely independently on the content side of the house. Rather than treating code and databases as sources of content, writers treat them as research sources. They look information up in these sources and then go away and write content (in a separate repository) to describe the information from those sources.</db:para>
<db:para>The essence of the problem is that many content organizations choose to work in the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain or the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain and have neither the tools not the expertize to bridge the gap to all this material already available in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain. But even when content organizations do extend their efforts into the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, they are often blind to the fact that the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain content they are proposing to create already exists in the systems of another department.</db:para>
<db:para>Another drawback is that content produced from these systems, for instance by a database reporting process, exists in isolation from the rest of the content produced by the organization. Such content can often be quite sophisticated and beautifully formatted and published. But it is the product of an entire structured publishing chain that has to be separately developed and maintained.</db:para>
<db:para>In the field of software documentation we see the same pattern in regard to programming language API documentation. Much of the material of an API reference guide is a description of each function, what information is required as input (its parameters or arguments), the information it produces as output, and the errors or exceptions that it can generate. All of this information already exists in the code that implements the function.</db:para>
<db:para>API documentation tools such as <db:indexterm><db:primary>JavaDoc</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>JavaDoc</db:secondary></db:indexterm>JavaDoc or <db:indexterm><db:primary>Sphinx</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>Sphinx</db:secondary></db:indexterm>Sphinx extract this information from code and comments and turn it into publishable content. This is an application of subject-domain structured writing and the API documentation tools that do this implement an entire structured publishing system, producing final output, often in multiple formats.</db:para>
<db:para>And here we see all the same problems again:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>An entire publishing chain is maintained separately from the main content publishing chain.</db:para>
</db:listitem>
<db:listitem>
<db:para>The content produced from this publishing chain is isolated from all the other content produced by the organization.</db:para>
</db:listitem>
<db:listitem>
<db:para>Much of the same information is often created and maintained separately in a different repository and tool chain in the form of programming guides and/or knowledge base articles.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>There are other cases of entirely separate publishing chains producing information that is isolated from the rest of an organization’s content. Technical support organizations create knowledge bases to answer commonly asked questions. The material in these knowledge bases is technical communication, plain and simple, yet it usually exists in isolation from the product documentation set, even to the extent that users may not be able to search both the documentation and the knowledge base from the same search box. Most users, however, have no way of guessing whether the answer they are looking for is going to be in the docs or the knowledge base (or in the users forum, often yet another independent publishing system).</db:para>
<db:para>There are a couple of ways to address these redundancies and the isolation that goes with them. One is to attempt to unify all content authoring and production in a single enterprise-wide system, often with a single set of content structures intended for use across all enterprise departments. However, this is a highly expensive and disruptive approach and tends to create interfaces and structures that are less usable and less specific to various business functions than the ones they replace. It ignores the local complexity of individual groups and subject matter, meaning that complexity gets shoved downstream, eventually to the reader. It also ignores the fact that many of the systems from which we wish to extract content exist for other purposes besides the content that is generated from them. Their subject-domain structures are specific and necessary to the database functions or software code generation they were built for.</db:para>
<db:para>Another approach is to leave the subject domain systems in place (and perhaps create more of them) and feed their output into a common <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain publishing tool chain. It is a normal part of the <db:indexterm><db:primary>publishing algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publishing algorithm</db:secondary></db:indexterm>publishing algorithm for <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain content to pass through the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain on its way to <db:indexterm><db:primary>media-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media-domain</db:secondary></db:indexterm>media-domain publication. <db:indexterm><db:primary>Subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>Subject domain</db:secondary></db:indexterm>Subject domain content, by its nature, is not strongly tied to a particular <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain structure, so integrating many sources of <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain content into a single publishing chain is not particularly onerous. (Specific <db:indexterm><db:primary>management-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management-domain</db:secondary></db:indexterm>management-domain features of certain tool chains make things more complicated, but since the subject domain tends to factor out a lot of the management domain, this is not an insurmountable problem.)</db:para>
<db:para>Most enterprise-wide content systems are based on <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain languages. (There is, after all, no way to create a single enterprise-wide <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain system, since an enterprise creates content on many subjects for many audiences.) In principle, a document-domain system should be capable of integrating content from domain-specific subject-domain systems.  Unfortunately, it is not common for either the subject domain systems or the enterprise content systems to be designed with this kind of integration in mind.</db:para>
<db:para>Because of this, we sometimes have to find ways to extract content from these sources and feed them into a unified publishing chain. This creates the need for extraction algorithms.</db:para>
<db:para>A common example of the extraction algorithm is found in API documentation tools such as <db:indexterm><db:primary>JavaDoc</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>JavaDoc</db:secondary></db:indexterm>JavaDoc. These tools parse application source code to pull out things like the names of functions, parameters, and return values, which it then uses to create the outline, at least, of reference documentation. Essentially, it generates a human language translation of what the computer language code is saying.</db:para>
<db:para>How the extraction algorithm works depends entirely on how the source data is structured, but it should usually create output in the subject domain that clearly labels the pieces of information it has culled from the source. For instance, a <db:indexterm><db:primary>Java</db:primary></db:indexterm><db:indexterm><db:primary>programming-language</db:primary><db:secondary>Java</db:secondary></db:indexterm>Java function definition is a piece of structured content in which the role and meaning of each element is known from the pattern and syntax of the <db:indexterm><db:primary>Java</db:primary></db:indexterm><db:indexterm><db:primary>programming-language</db:primary><db:secondary>Java</db:secondary></db:indexterm>Java language itself (its grammar):</db:para>
<db:programlisting language="java">
boolean isValidMove(int theFromFile, 
                    int theFromRank, 
                    int theToFile, 
                    int theToRank) {
        // ...body
    }
</db:programlisting>
<db:para>This same information can be extracted by an algorithm that knows the grammar of <db:indexterm><db:primary>Java</db:primary></db:indexterm><db:indexterm><db:primary>programming-language</db:primary><db:secondary>Java</db:secondary></db:indexterm>Java to produce something that looks more like <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain content:</db:para>
<db:programlisting language="sam">
java-function:
    name: isValidMove
    return-type: boolean
    parameters:: type, name
        int, theFromFile
        int, theFromRank
        int, theToFile
        int, theToRank
</db:programlisting>
<db:para>This is the same information, but in a different structure. In this structure, however, it is easily accessible by content processes and can then be processed through the rest of the publishing tool chain just like any other content.</db:para>
<db:para>Any structured data source that expresses the semantics of its data in a consistent way is a source of subject domain content. We just need to find a way to get at it.</db:para>
</db:section>
<db:section>
<db:title>The diversity of sources</db:title>

<db:para>When it comes to drawing content from diverse sources, the term <db:indexterm><db:primary>single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>single sourcing</db:secondary></db:indexterm>single sourcing can mislead us. Single source can lead us to think that it means all source content is kept in a single place. Some vendors of content management systems would like to encourage this interpretation. But a better definition is that each piece of information comes from a single source. That is to say, each piece of information comes from only one source, but there may be many sources, each maintaining different information.</db:para>
<db:para>Ensuring that content is only stored once is actually about making sure that the information, and the repository in which it is stored, meets an appropriate set of constraints. The constraints that establish the uniqueness of a piece of content are different for different types of content and different subject matter, so such constraints are better expressed and enforced by systems that are specific to their particular subject matter.</db:para>
<db:para>Of course, there can often be trivial differences between the ways in which different bodies within an organization store and manage information that could and should be rationalized. There are all kinds of isolated and ad hoc information stores in most organizations that could potentially be much more efficient and much more accessible, with a degree of rationalization and centralization. But it does not follow at all that absolute centralization into a single system or a single data model is appropriate, useful, or even possible.</db:para>
<db:para>The best way to ensure that information is stored once is to have it stored in a system with the right constraints and the right processes for the people who create and manage that information. This may mean that an integrated publishing system will draw from diverse sources of information and content. The ability to extract content from these sources and to merge it with other content for publication is therefore central to an effective strategy.</db:para>
<db:para>Still, while this model sounds grand, it also introduces a lot of complexity in terms of its integration and maintenance requirements. The point of the exercise, we should always remember, is to minimize the amount of unmanaged complexity in the system. Integrated system can manage complexity in sophisticated ways, but they introduce their own kinds of complexity that has to be factored into the calculation. Sometimes the optimal solution is less than total integration.</db:para>
<db:indexterm class="endofrange" startref="idm1421955596"/><db:indexterm class="endofrange" startref="idm1421955596x"/></db:section>
</db:chapter>
