<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.linking"><db:title>Linking</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp374911348"><db:primary>linking</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp374911348x"><db:primary>concept</db:primary><db:secondary>linking</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idp374910068"><db:primary>linking algorithm</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp374910068x"><db:primary>concept</db:primary><db:secondary>linking algorithm</db:secondary></db:indexterm>



<db:para>A large part of the complexity of content is that readers do not read in a straight line. Numerous studies<db:footnote>
<db:para>For a discussion of these studies and their implications for how we write, see my book <db:citetitle>Every Page is Page One: Topic-based Writing for Technical Communication and the Web</db:citetitle>.</db:para>
</db:footnote> have shown that readers often read opportunistically, looking for one piece of information or the answer to a particular question. Their behavior can best be described as <db:indexterm><db:primary>information foraging</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>information foraging</db:secondary></db:indexterm>information foraging. They are sniffing for the scent of the information they want and will follow its trail as long as the scent gets stronger and the trail is easy to follow.</db:para>

<db:para>The trail a reader follows through an information set has certain junction points, places where the reader can decide to keep going straight through the current document or turn aside to look at a different document. While the reader’s decision to switch documents can occur at any point, especially if they are simply abandoning the current document as unfruitful, the most common reason for switching is because they want more information on, or are simply more interested in, a specific subject mentioned in the current document.</db:para>
<db:para>If each document describes one subject, it mentions many other subjects in the course of describing its own subject. Thus a movie review mentions actors, directors, and other movies; a recipe mentions cooking techniques like whisking and grilling; a programming topic mentions functions and libraries and data structures. I call these points at which a document on a subject mentions other related subjects <db:indexterm><db:primary>subject affinities</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject affinities</db:secondary></db:indexterm>subject affinities. Subject affinities are the points at which the subjects of different pieces of content intersect. Subject affinities are the junction points in the information highway, the points were the reader may choose to turn or to go straight on.</db:para>
<db:para>Suppose a reader is reading a recipe and comes across the instruction “sweat the onions” but does not know how to do that. They cannot continue straight on through the document without that knowledge so they turn aside in search of it. The words “sweat the onions” are a point of subject affinity between the recipe and the cooking technique of sweating vegetables. The reader’s decision to turn here in search of additional information at this point is not an arbitrary one. It follows the relationship between the task of making the dish described in the recipe and a cooking technique used in that task. We can fully anticipate that some readers will need to make this turn at this point of subject affinity.</db:para>
<db:para>This particular subject affinity, between a particular recipe and a particular cooking technique, is not arbitrary or unique either. It is abundantly clear that there is a subject affinity between recipes and basic cooking techniques that applies universally and can be modeled in a structured way using structured writing techniques.</db:para>
<db:para>The reader’s need to seek more information on a subject or task they do not fully understand is part of the complexity of information seeking. The goal of information delivery is to make information seeking simpler. If you don’t make adequate provision for your readers to find this information when they need to, you are dumping the complexity of navigating the subject affinity onto the reader. Managing subject affinities, therefore, is an important part of managing the overall complexity of the content system. Making sure that every part of the complexity of the content system is handled by a person or process that has the skill, time, and resources to handle it extends to the reader. We don’t want to push any navigational complexity on the reader that they are not fully equipped to handle. Indeed, we want to make it as easy as we can for them to handle it.</db:para>
<db:para>The most obvious, and generally the most powerful, way of handling subject affinities is to create links from the text that marks the point of affinity to a suitable resource that provides the information the reader needs. If you force them to use search again or to go to a table of contents or an index when you could easily provide a direct link, you are dumping complexity on the reader.</db:para>
<db:para>But linking is not the only way to handle subject affinities, nor is linking an option in all media. The writer may also choose to use footnotes, cross references, sidebars, or parenthetical material to provide additional information. They may even attempt to anticipate and forestall the reader’s information need by using information about the individual reader to dynamically reorder the content. A discussion of linking, therefore, needs to take account of other ways of handling subject affinities which may be appropriate in particular circumstances.</db:para>
<db:para>If we <db:indexterm><db:primary>single-source</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>single-source</db:secondary></db:indexterm>single-source content between different media, we might want to handle subject affinities differently between paper and hypertext outputs. We may want to include the a chunk of explanatory content in line or in a sidebar in multiple paper documents but link to a single copy of it when creating a <db:indexterm><db:primary>hypertext</db:primary></db:indexterm><db:indexterm><db:primary>media</db:primary><db:secondary>hypertext</db:secondary></db:indexterm>hypertext. (Linking, in other words, is a kind of <db:indexterm><db:primary>reuse</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm>reuse: reuse by reference rather than copying.)</db:para>
<db:para>Thus we should not be thinking solely in terms of  managing links. We should be thinking about managing subject affinities, and supporting subject affinities in the way that works best in each of our outputs.</db:para>
<db:para>One of the biggest problem with managing links is that link management is itself highly complex and often time consuming. Thus many organizations do not link their content adequately and do not provide adequate alternative handling of subject affinities either. They just dump the complexity finding the next piece of information right back on the reader.</db:para>
<db:para>However, there are ways to partition the complexity of link management and of subject affinity management that make it much easier for writers to provide good subject affinity support in a economical fashion. To understand the differences, it is useful to look at link and/or subject affinity management works in each of the <db:indexterm><db:primary>structured writing domains</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>structured writing domains</db:secondary></db:indexterm>structured writing domains.</db:para>
<db:section>
<db:title>Subject affinities in the media domain</db:title>
<db:para>In the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain, we simply record the various devices used to express subject affinities, as such: cross references, tables, links, etc. For example, in HTML a link simply specifies a page to load:</db:para>
<db:programlisting language="html">
&lt;p&gt;In Rio Bravo, 
&lt;a href="https://en.wikipedia.org/wiki/John_Wayne"&gt;the Duke&lt;/a&gt; 
plays an ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>The phrase “the Duke” is a subject affinity. The reader may not know who “the Duke” is, or may want more information on him. The link supports the reader in navigating the subject affinity to find the information they want.</db:para>
<db:para>But if the HTML page is printed, the link is lost. The phrase “the Duke” is still a subject affinity, and the reader may still want more information. The reader can still get the information they need by doing a search for “the Duke”, perhaps, or asking a friend what it means. But the printed version lacks any support for the reader’s information need. It dumps the complexity of the search back on the reader.</db:para>
<db:para>If the content had been written for paper, the subject affinity might be supported in a different way. For example, it might be supported by adding an explanation in parentheses:</db:para>
<db:blockquote>
<db:para>In Rio Bravo, the Duke (John Wayne) plays an ex-Union colonel out for revenge.</db:para>
</db:blockquote>
<db:para>Or it might be handled with a footnote:</db:para>
<db:programlisting language="text">
In Rio Bravo, the Duke* plays 
an ex-Union colonel out for revenge.
        
...
        
* "The Duke" is the nickname of the actor John Wayne.
</db:programlisting>
<db:para>Clearly this is a case in which we would like to do <db:indexterm><db:primary>differential single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>differential single sourcing</db:secondary></db:indexterm>differential single sourcing and handle a subject affinity differently in different media. To accomplish this, we need to move the content out of the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain.</db:para>
</db:section>
<db:section>
<db:title>Subject affinities in the document domain</db:title>
<db:para>Moving to the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain is about factoring out the formatting specific structures of the media domain. But a link is not really a piece of formatting, so conventional refactoring into abstract document structures is not going to apply. For this reason, people working in the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain often enter hypertext links exactly the way they would in the media domain: by specifying a URL. Thus in DITA you might enter a link as:</db:para>
<db:programlisting language="DITA">
&lt;p&gt;In Rio Bravo, 
&lt;xref href="https://en.wikipedia.org/wiki/John_Wayne" 
 format="html"&gt;The Duke&lt;/xref&gt; 
plays an ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>The difference from HTML is slight here. The link element is called <db:code>xref</db:code> rather than <db:code>a</db:code>. But the meaning of <db:code>xref</db:code> is bit more general. The HTML <db:code>a</db:code> element is saying, create a hypertext link to this address. The DITA <db:code>xref</db:code> element is saying, create some sort of reference to this resource. (As we will see in a moment, it is capable of linking to things other than HTML pages, which is why it requires the <db:code>format</db:code> attribute to specify that in this case the target is an HTML page.) This generality gives us a little more leeway in processing. We can legitimately create print output from this markup that looks like this:</db:para>
<db:blockquote>
<db:para>In Rio Bravo, the Duke (see: https://en.wikipedia.org/wiki/John_Wayne) plays an ex-Union colonel out for revenge.</db:para>
</db:blockquote>
<db:para>This is not the way we would handle the subject affinity if we were designing for paper, but it is a definite improvement from a <db:indexterm><db:primary>differential single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>differential single sourcing</db:secondary></db:indexterm>differential single sourcing point of view. At least the link is now visible to the reader.<db:footnote>
<db:para>Technically we could do this from the HTML markup as well, but that would be cheating. The HTML markup is not really giving us permission to do this. It is telling us to create a hypertext link and nothing else. The problem with cheating is that you are basing your algorithm on constraints that are not being promised or enforced, and this can fail in ways you may not expect or catch. Some cheats are more reliable than others, but you probably don’t want to get into the habit. Better to move your content creation to a format where cheating is not required to get the output you want.</db:para>
</db:footnote></db:para>

<db:para>Fundamentally, though, this is not a satisfactory <db:indexterm><db:primary>differential single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>differential single sourcing</db:secondary></db:indexterm>differential single sourcing solution. Unless there were no alternative (such as when you are citing a specific source), you would not normally direct a reader of paper to the web for more information, nor vice versa. Linking to an already published file, such as an HTML page, means linking to the address where the published file resides. It commits us to a particular format for the link target. If instead of linking to the published address, we link to the address of the unpublished source file, or to an identifier for that file, we gain the freedom to link to any format of that content that we choose to publish.</db:para>
<db:para>In DITA, you can link to another DITA file (the default format, so we don’t need the <db:code>format</db:code> attribute):</db:para>
<db:programlisting language="html">
&lt;p&gt;In Rio Bravo, &lt;xref href="John_Wayne.dita"&gt;The Duke&lt;/xref&gt; 
plays an ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>We don’t yet know if that DITA file will be published to paper or the Web, what the address of the published topic will be, or if that topic will stand alone or be assembled into a larger page or document for publication. This means that the publishing system is taking on responsibility for both ends of the link. It has to make sure that the target page is published in a way the source page can link to, and that the source page links to the right address.  But transferring this responsibly to an algorithm gives us the leeway to publish this link as we see fit.</db:para>
<db:para>If we publish as a book on paper and the target resource ends up as part of a chapter in the same book, we can render the <db:code>xref</db:code> as a cross reference to the page that resource appears on. We could format that cross reference inline or as a footnote. These are all legitimate interpretations of the <db:code>xref</db:code>’s instruction to create a reference to a resource.</db:para>
<db:para>If we publish to a help system and the target resource ends up as a topic in the same help system, we could render the <db:code>xref</db:code> as a hypertext link to that topic.</db:para>
<db:para>This is a big step forward, but it still does not let us do this:</db:para>
<db:blockquote>
<db:para>In Rio Bravo, the Duke (John Wayne) plays an ex-Union colonel out for revenge.</db:para>
</db:blockquote>
<db:para>In other words, we can render the <db:code>xref</db:code> as a cross reference or a link or a footnote, but we can only handle the subject affinity as a reference to the specified resource. We can’t decide to link to a different resource or handle it by parenthetical clarification instead. To give ourselves the ability to link to different resources, we can turn to the <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain.</db:para>
</db:section>
<db:section>
<db:title>Subject affinities in the management domain</db:title>
<db:para>Linking to a source file rather than to an address gives us more latitude about how the link or cross reference is published, but we are still always linking to the same resource. If we are doing <db:indexterm><db:primary>content reuse algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content reuse algorithm</db:secondary></db:indexterm>content reuse, this is a problem because we do not know if the same resource will be available everywhere we reuse our topic. We need to be able to link to different resources when our topic is used in different places.</db:para>
<db:para>To accommodate this, we can factor out the file name and replace it with an ID or a key. IDs and keys are <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain structures that we looked at in <db:xref linkend="chapter.reuse"/>. They allow us to refer to resources indirectly. Using IDs lets us use an abstract identifier rather than a file name to identify a resource. Using keys lets us remap the resources we point to. This makes keys the more efficient way to address this problem. So instead of referring to a specific resource on John Wayne, we refer to the key <db:code>John_Wayne</db:code> using a reference to a key. In DITA this would look like this:</db:para>
<db:programlisting language="DITA">
&lt;p&gt;In Rio Bravo, &lt;xref keyref="John_Wayne"&gt;The Duke&lt;/xref&gt; 
plays an ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>Somewhere in the <db:indexterm><db:primary>DITA map</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>DITA map</db:secondary></db:indexterm>DITA map for each publication, the key <db:code>John_Wayne</db:code> points to a topic. Publications link the <db:code>keyref</db:code> to the resource pointed to by that key in each of their DITA maps. This allows you to link to different resources in each publication.</db:para>
</db:section>
<db:section>
<db:title>The problem with IDs and Keys</db:title>
<db:para>However, there is still a problem with linking based on IDs and keys. Keys will let you vary which resource a <db:code>keyref</db:code> resolves to, but what happens when there is no resource to which that key can reasonably be assigned? The <db:code>xref</db:code> demands that a reference to a resource be created, but there is no resource to link to. We are going to have a broken link, and fixing it is not easy. We can’t simply go in and remove the <db:code>xref</db:code> from the source for one publication, because it defeats the purpose of <db:indexterm><db:primary>content reuse algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content reuse algorithm</db:secondary></db:indexterm>content reuse if we have to edit the content every time we reuse it. Removing the key reference would fix our broken link in one publication, but that would result in the link being removed from all the publications, even where the resource does exist and the link ought to be created.</db:para>
</db:section>
<db:section>
<db:title>Relationship tables</db:title>
<db:para>One approach to the link-only-when-resource-available problem is to use a relationship table. In a conventional linking approach, the source page contains an embedded link structure pointing to the target page. The source  knows it is pointing to the target, but the target does not know it is being pointed to.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/simplelink.svg" contentwidth="2in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/simplelink.png"/></db:imageobject><db:textobject><db:para>Diagram showing how a simple link works.</db:para></db:textobject></db:mediaobject>
<db:para>The idea that the target resource does not know it is being pointed to is important because it means it does not have to do anything in order for other resources to point to it. The fact that only the source and not the target has to know about the link is fundamental to the rapid growth of the Web. If the target resource had to participate in the link process, every link would require negotiation between authors and the agreement of the author of the target resource to edit it to accept the link. It would be impossible for the Web to grow explosively and organically as it has under these conditions.</db:para>
<db:para>A relationship table takes this one step further. When we create a link using a relationship table, we factor the link out of the source document and place it in a separate table. The relationship table says resource A links to resource B, but neither resource A nor resource B knows anything about it.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/linktable.svg" contentwidth="4in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/linktable.png"/></db:imageobject><db:textobject><db:para>Diagram showing how a link table connects two resources.</db:para></db:textobject></db:mediaobject>
<db:para>Once the links are factored out of a piece of content, we can reuse it anywhere we like. If there is a suitable resource available to link to, we enter it in a relationship table for that build and have the presentation algorithm create the link at build time. If no suitable resource is available for a different publication, no entry is made in the relationship table for that publication, and the presentation algorithm does not create a link.</db:para>
</db:section>
<db:section>
<db:title>The problem with relationship tables</db:title>
<db:para>The problem with relationship tables is that they separate the link from the subject affinity it supports. The link that was created to serve the subject affinity in the content, the point at which the reader encountered something they might not understand, or might need more information on, or might find more appropriate to their needs that what they are reading now.  But the relationship table does not record the subject affinity, it says that there is some connection between topic A and topic B. It does not say where in topic A the subject affinity that creates the relationship is located. The subject affinity itself has not been marked up, so there is no way to put the link back where it belongs. Links generated by relationship tables end up in a block, usually at the end of the page.<db:footnote>
<db:para>It is not impossible to imagine a markup system in which you could markup the source of the subject affinity in topic A, and then have the relationship table reference that point by ID, thus allowing you to put the link at the subject affinity. But this is clearly cumbersome for writers to implement and would complicate the management task. I don’t know of any systems that work this way.</db:para>
</db:footnote></db:para>

<db:para>The fundamental problem here is that links exist as a way to service subject affinities in content. If we lose sight of this and think only in terms of managing links between resources, it makes sense to pull links out of the content and manage them separately. But this is to ignore the reason the links exist in the first place – which is to provide the reader with support at a point of subject affinity. Using relationship tables is a classic case of partitioning that focuses on one part of the problem without adequate regard for the complexity that is being redirected. By moving the link away from the subject affinity, we simplify link management, but in doing so we make finding supporting information harder for the reader, thus dumping that navigational complexity onto the reader, damaging content quality in the name of process efficiency.</db:para>
<db:para>The other problem with the relationship table approach is that it is time consuming. You have to rewrite the links for each content set, and because the subject affinities are not recorded in the content source, you have to figure out the appropriate links each time. This goes against the spirit of recording something once and using it many times. A mechanism intended to help you reuse content ends up forcing you to redo the work of linking for each publication you create. In other words, this mechanism does not partition the complexity of link management very well.</db:para>
</db:section>
<db:section>
<db:title>Conditional linking</db:title>
<db:para>Before we leave the management domain, it is worth mentioning a management domain approach that we could use to address our differential single sourcing problem and get the appropriate handling of subject affinities for both online and paper publishing. We could use conditional structures to define both options in the source file. With a little <db:indexterm><db:primary>DITA specialization</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>DITA specialization</db:secondary></db:indexterm>specialization to support <db:code>media</db:code> as a conditional attribute, you could do this in DITA:</db:para>
<db:programlisting language="DITA">
&lt;p&gt;In Rio Bravo, 
&lt;ph media="online"&gt;&lt;xref keyref="John_Wayne"&gt;The 
Duke&lt;/xref&gt;&lt;/ph&gt;&lt;ph media="paper"&gt;The 
Duke (John Wayne)&lt;/ph&gt; plays an ex-Union 
colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>In DITA, the <db:code>ph</db:code> element is used to delineate an arbitrary phrase in the content that you want to apply management domain attributes to. Here we define two different versions of the phrase “the Duke”, each with different forms of support for additional information (parenthetical expression for paper, link for online), and each with a corresponding media condition. The <db:indexterm><db:primary>synthesis algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>synthesis algorithm</db:secondary></db:indexterm>synthesis algorithm would then choose the appropriate version of the phrase for each publication based on the conditions set for the build.</db:para>
<db:para>There are some pretty obvious problems with this approach. It is twice the work for authors to handle every subject affinity, and it doubles the maintenance cost of the content as well. It also flies in the face of the idea of creating formatting-independent content.</db:para>
<db:para>Unfortunately, in a general purpose <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain markup language with <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain support, it is pretty much impossible to prevent writers from doing things like this in order to achieve the effects they want. And in practice writers do end up using conditional markup like this for all kinds of differential single sourcing and reuse problems that are not easy to solve in the document and management domains. In some cases this can lead to tangles of conditions that are hard to maintain and debug.</db:para>
<db:para>The inescapable fact is that the <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain approach does not do a great job of partitioning the complexity of links, and of subject affinity handling in general.</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Like all management domain structures, the management domain link structures are artificial. They don’t correspond to things in the writer’s everyday world, which makes them harder to learn and use. They introduce complexity into the writer’s world, which is sufficient to make most authors severely limit the links they create.</db:para>
</db:listitem>
<db:listitem>
<db:para>You can’t link to a key or an ID that does not exist. This means that as you are developing a set of content, the first pages you write have very few other pages to link to. Authors cannot enter links to content that has not been written yet. This introduces the complexity of system dependencies into the writer’s world.</db:para>
</db:listitem>
<db:listitem>
<db:para>In <db:indexterm><db:primary>reuse</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm>reuse scenarios, the use of <db:indexterm><db:primary>IDs</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>IDs</db:secondary></db:indexterm>IDs and <db:indexterm><db:primary>keys</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>keys</db:secondary></db:indexterm>keys does not solve the whole problem because it cannot guarantee that the resource that an ID or key refers to will be present in the final publication. You can use relationship tables to address this problem, but they create additional complexity for authors and don’t correctly handle subject affinities in the middle of the content.</db:para>
</db:listitem>
<db:listitem>
<db:para>Unless you resort to ugly conditional structures, you can’t use media-appropriate method of handling subject affinities for differential single sourcing.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>Subject affinities in the subject domain</db:title>
<db:para>As we have seen before (<db:xref linkend="chapter.reuse"/>), we can often remove the need for management domain structures by moving content to the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain. The same is true with subject affinities. In the subject domain, we can mark up subject affinities as subject affinities. This means that we can move away from managing links as links and manage subject affinities instead. Here is what this looks like in <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm><db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML:</db:para>
<db:programlisting language="xml">
&lt;p&gt;In &lt;movie&gt;Rio Bravo&lt;/movie&gt;, 
&lt;actor name="John Wayne"&gt;the Duke&lt;/actor&gt; 
plays an ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>And in <db:indexterm><db:primary>SAM</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SAM</db:secondary></db:indexterm>SAM:</db:para>
<db:programlisting language="sam">
In {Rio Bravo}(movie), 
{the Duke}(actor "John Wayne") 
plays an ex-Union colonel out for revenge.
</db:programlisting>
<db:para>This markup clarifies that the phrase “the Duke” (a subject affinity) refers to the actor named John Wayne (its subject). It specifies both the type of the subject (actor) and its value (John Wayne).</db:para>
<db:para>This is <db:indexterm><db:primary>subject annotation</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>subject annotation</db:secondary></db:indexterm>subject annotation, not link markup. Unlike <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain <db:code>xref</db:code> markup, it does not insist that a reference should be created nor does it specify any resource to link to. Instead, it simply specifies what the subject of the text is. Specifically, it clarifies that the phrase “the Duke” refers to the actor named John Wayne (and not the Duke of Wellington or the Duke of Earl) and that the phrase “Rio Bravo” refers to the movie (and not to the city in Texas or the nature reserve in Belize<db:footnote><db:para>https://en.wikipedia.org/wiki/R%C3%ADo_Bravo_\(disambiguation\)</db:para></db:footnote>).</db:para>
<db:para>Given this markup, we can easily create the paper-style handling of the subject affinity that we have been looking for. We simply have the <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>presentation algorithm</db:secondary></db:indexterm>presentation algorithm take the value of the <db:code>specifically</db:code> attribute (as it is called in <db:indexterm><db:primary>SAM</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SAM</db:secondary></db:indexterm>SAM) and output it between parentheses:</db:para>
<db:programlisting language="html">
&lt;p&gt;In Rio Bravo, The Duke (John Wayne) plays an 
ex-Union colonel out for revenge.&lt;/p&gt;
</db:programlisting>
<db:para>Marking up a phrase as a subject affinity does not oblige the publishing algorithm to create a link. If you decide to have the publishing algorithm create a link on the Web and a cross reference on paper, nothing in the markup obliges you to use any particular formatting or target any particular resource. (We’ll look at how to create a link from a subject annotation in a moment.)</db:para>
<db:para>In all our previous examples, mentions of “Rio Bravo” were not marked up, even though the names of movies are clearly subject affinities in a movie review. This reflects the author’s decision not to create a link to support this subject affinity. But what if we want to make a different choice later? By marking up “Rio Bravo” with a subject annotation, we keep our options open (transfer the information needed to make the decision in a different partition). We can tell the <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>presentation algorithm</db:secondary></db:indexterm>presentation algorithm to create links on the names of movies if we want to, or not if we don’t want to.</db:para>
<db:para>But there are additional reasons to annotate Rio Bravo as a subject, because that annotation can be used for other purposes as well.</db:para>
<db:orderedlist>
<db:listitem>
<db:para>The subject annotation says that “Rio Bravo” is the title of a movie. In the media domain, the titles of movies are commonly printed in italics. We can use the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain <db:code>movie</db:code> tags to generate <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain italic styling.</db:para>
</db:listitem>
<db:listitem>
<db:para>We could use this subject annotation to generate <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain index markers so that we can automatically build an index of all mentions of movies in a work.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>Subject annotation thus serves multiple purposes, and correspondingly reduces the amount of markup that is required to support all these different publishing functions. This is a common feature of subject domain markup. None of it is directly tied to specific document domain or media domain structures which will be required to publish the content. Each piece of subject-domain markup may be used to generate multiple document domain and media domain structures. For example, we could generate the following document domain markup from from the subject domain markup above (the example is in DocBook):</db:para>
<db:programlisting language="DocBook">
&lt;para&gt;
    In 
    &lt;indexterm&gt;
       &lt;primary&gt;Rio Bravo&lt;/primary&gt;
       &lt;secondary&gt;Movies&lt;/secondary&gt;
    &lt;/indexterm&gt;
    &lt;citetitle pubwork="movie"&gt;Rio Bravo&lt;/citetitle&gt;,
    &lt;indexterm&gt;
        &lt;primary&gt;John Wayne&lt;/primary&gt;
        &lt;secondary&gt;Actors&lt;/secondary&gt;
    &lt;/indexterm&gt;
    &lt;ulink url="https://en.wikipedia.org/wiki/John_Wayne"&gt;
        The Duke
    &lt;/ulink&gt;
    plays an ex-Union colonel out for revenge.
&lt;/para&gt;        
</db:programlisting>
<db:para>This sample contains index markers, formatting of movie titles, and links on actor’s names, all generated based on the subject annotations in the source text. It should be clear how much less work it is for an author to create the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain version of this content than the <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook version, how many fewer decisions they have to make and how much less knowledge and skill they have to possess. Yet all the same publishing ability is maintained in both versions.</db:para>
<db:para>Generating links from subject annotations has a number of other advantages:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>In a <db:indexterm><db:primary>reuse</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm>reuse scenario, you never have to worry about broken links or creating relationship tables. The <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>presentation algorithm</db:secondary></db:indexterm>presentation algorithm generates whatever links are appropriate to whatever topics are available.</db:para>
</db:listitem>
<db:listitem>
<db:para>In a <db:indexterm><db:primary>differential single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>differential single sourcing</db:secondary></db:indexterm>differential single sourcing scenario, you are never tied to one mechanism for handling the subject affinity. You can generate any mechanism you like in whatever media you like.</db:para>
</db:listitem>
<db:listitem>
<db:para>You don’t have to worry about maintaining the links in your content because your source content does not contain any links. The subject annotations in your content are objective statements about your subject matter, so they don’t change. All the links in the published content are generated by the linking algorithm, so no management is required.</db:para>
</db:listitem>
<db:listitem>
<db:para>There is no issue with wanting to link to content that has not been written yet. The subject annotation refers to the subject matter, not a resource. Links to content that is written later will appear once that content becomes available to link to.</db:para>
</db:listitem>
<db:listitem>
<db:para>It is much easier for authors to write because they do not have to find content to link to or manage complex link tables or keys. They just create subject annotations when the text mentions a significant subject. This requires no knowledge of the publishing or content management system. It does not even require knowledge of any other resources in the content set. It only requires knowledge of the subject matter, which the author already has, and the format of subject annotations, which is easy to learn.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>Finding resources to link to</db:title>
<db:para>The <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain approach represents a radically different partitioning of the complexity of linking and <db:indexterm><db:primary>subject affinity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject affinity</db:secondary></db:indexterm>subject affinity handling. Most notable, it partitions and redirects the responsibility for finding content to link to away from the writer. All partitioning introduces some new form or complexity to replace the one that has been partitioned out. In this case, it is the complexity of doing the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain annotations of the text. But this is a particularly effective piece of partitioning both because that annotation only requires knowledge the writer already has, but also because that same annotation is useful for so many other algorithms as well. This is one of the best features of the subject domain – its structures tend to serve multiple algorithms rather than just one, which is, in itself, a highly effective piece of partitioning of complexity.</db:para>
<db:para>But since we have partitioned off the responsibility of finding resources to link to, we also have to look at how the people and processes in that partition go about locating appropriate resources.  They do this by looking up resources based on the subject information (type and value) captured by the subject annotation. For this we need content that is indexed using those types and values (or their semantic equivalents). So naturally this means that we need to index our content. If you have a page on John Wayne, you can index it like this:</db:para>
<db:programlisting language="sam">
topic: 
    title: Biography of John Wayne
    index:
        type: actor
        value: John Wayne
    body:
    
        John Wayne was an American actor known for westerns.
</db:programlisting>
<db:para>Now the linking algorithm looks like this:</db:para>
<db:programlisting language="pseudo">
match actor
    $target = find href of topic 
               where type = actor 
               and name = @name
    create xref
        attribute href = $target
        continue
</db:programlisting>
<db:para>However, content stored in the subject domain may already be indexed effectively enough by its inherent subject domain structures. Suppose your content collection includes this subject-domain actor bio:</db:para>
<db:programlisting language="sam">
actor: 
    name: John Wayne
    bio: 
        John Wayne was an American actor known for westerns.
    filmography:
        film: Rio Bravo
        film: The Shootist
</db:programlisting>
<db:para>Here the topic type is actor, and the <db:code>name</db:code> field specifies the name of the actor in question. This is all the information we need to identify this topic as a source of information on the actor John Wayne.</db:para>
<db:para>Only very minor changes to the linking algorithm are required to use this:</db:para>
<db:programlisting language="pseudo">
match actor
    $target = find href of actor topic where name = @name
    create xref
        attribute href = $target
        continue
</db:programlisting>
<db:para>There is a lot more to how this mechanism works in practice, including what you do about imperfect matches and what happens when the query returns multiple resources. But that takes us into the specifics of individual systems and that is more detail than we need for present purposes.</db:para>
<db:para>Indexing of topics may also be done by a <db:indexterm><db:primary>content management system</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>content management system</db:secondary></db:indexterm>content management system, in which case the linking algorithm would query to CMS to find topics to link to.</db:para>
<db:para>A useful feature of this approach is that you can have the <db:indexterm><db:primary>publishing algorithm</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>publishing algorithm</db:secondary></db:indexterm>publishing algorithm fall back to creating a link to an external resource if an internal one is not available. If a search of the index of your own content fails, you can search indexes of external content. You can build such an index yourself, but some external sites may also provide indexes, APIs, or search facilities that you can use to locate appropriate pages to link to.</db:para>
<db:para>Of course, building these linking algorithms is a piece of additional complexity in your content system. The effect of the subject domain is to partition complexity away from writers and distribute it to <db:indexterm><db:primary>information architects</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>information architects</db:secondary></db:indexterm>information architects and <db:indexterm><db:primary>content engineers</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>content engineers</db:secondary></db:indexterm>content engineers.</db:para>
</db:section>
<db:section>
<db:title>Different domain, different algorithm</db:title>
<db:para>What the linking algorithm, or, to be more precise, the subject affinity handling algorithm, illustrates perhaps better than any other is that the movement from one domain to another represents are significantly different partitioning of content complexity, which means that it changes the structured writing algorithms in fundamental ways. While the algorithm has the same purpose in each domain, the way it achieves that purpose can be significantly different.</db:para>
<db:para>In the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, the data structures tend to have a one to one correspondence with their algorithms. As system designers determine they need a particular algorithm, they create structures to support that algorithm. Thus document domain languages that require support for linking, reuse, indexing, and single sourcing have separate data structures for linking, for reuse, for indexing, and for single sourcing. (Some of these may be <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain structures, of course.)</db:para>
<db:para>In the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, though, the data structures reflect the subject matter. If you go looking for a one-to-one correspondence between a structure and the algorithm it supports, you won’t find it. Thus you will not find link markup or <db:indexterm><db:primary>reuse</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm>reuse markup or index markup or <db:indexterm><db:primary>single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>single sourcing</db:secondary></db:indexterm>single sourcing markup in the subject domain. You will find subject annotations that clarify and delineate the subject matter of the content. Any algorithm we want to apply has to interpret that <db:indexterm><db:primary>subject annotation</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>subject annotation</db:secondary></db:indexterm>subject annotation and use it as the basis for creating whatever kind of document or <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain structure you want for publishing.</db:para>
<db:para>System designers do still have to think about what algorithms they want to apply, but that is to make sure that the aspects of the subject matter needed to drive the algorithms are captured. Since every subject structure can potentially drive many publishing algorithms, however, you will often find your <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain content already supports any new algorithms you want to apply. This helps <db:indexterm><db:primary>future proof</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>future proof</db:secondary></db:indexterm>future proof your content.</db:para>
<db:para>Moving from the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain to the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain is not a matter of asking what the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain equivalent of a document domain structure is, therefore, but a matter of asking what information in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain drives the creation of <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain structures. Subject domain content can look very different from its document domain counterpart and will often be starkly simpler and easier to understand. This represents a better partitioning of complexity. But as noted before, all complexity has to go somewhere, and the use of the subject domain tends to transfer more of the complexity to the <db:indexterm><db:primary>information architect</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>information architect</db:secondary></db:indexterm>information architect or <db:indexterm><db:primary>content engineer</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>content engineer</db:secondary></db:indexterm>content engineer.</db:para>
<db:indexterm class="endofrange" startref="idp374911348"/><db:indexterm class="endofrange" startref="idp374910068"/><db:indexterm class="endofrange" startref="idp374911348x"/><db:indexterm class="endofrange" startref="idp374910068x"/></db:section>
</db:chapter>
