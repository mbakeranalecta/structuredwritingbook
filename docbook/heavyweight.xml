<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.heavyweight"><db:title>Heavyweight markup languages</db:title>


<db:para>I am using the term “heavyweight” here as an obvious contrast to the commonly used “lightweight”, even though the term “heavyweight” is not used commonly of markup languages. Nonetheless, it fits. Both the abstract language XML and the concrete languages like <db:indexterm><db:primary>DocBook</db:primary></db:indexterm>DocBook and <db:indexterm><db:primary>DITA</db:primary></db:indexterm>DITA are heavyweights in the sense that they have a lot of capability that comes at the expense of a large footprint.</db:para>
<db:para>Having said that, I should make the distinction between the heavyweight syntax of XML and the heavyweight semantics of a <db:indexterm><db:primary>DITA</db:primary></db:indexterm>DITA or <db:indexterm><db:primary>DocBook</db:primary></db:indexterm>DocBook. It would certainly be possible to create the semantics of DITA or DocBook in a more lightweight syntax. And it is certainly possible to create very simple markup languages (with semantics much more lightweight than something like reStructuredtext, for instance) using XML. Despite this, there is a definite connection between heavyweight syntax and heavyweight semantics, perhaps because the more heavyweight languages have more need of the capabilities of a fully abstract syntax of XML and the processing tools that go with it.</db:para>
<db:para>I’m going to briefly survey some of the heavyweight languages. One thing to note about heavyweight languages is that they often contain structures from more than one domain. Their core is usually in the document domain, but they typically contain some <db:indexterm><db:primary>media domain</db:primary></db:indexterm>media domain structures for things like tables that are hard to abstract from the <db:indexterm><db:primary>media domain</db:primary></db:indexterm>media domain in a generic way. They also typically contain some subject domain structures, typically related to technology, since many heavyweight languages originated for documenting technical products. Finally, most contain some management domain structures, particularly for things like conditional text.</db:para>
<db:para>Why is the structured writing landscape dominated by a few very large and quite loosely constrained markup languages?</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Partly because big loosely constrained document domain markup languages are the smallest step into the document domain from the word processors and desktop publishing applications that most writers have used for years. They thus represent a relatively small conceptual change for writers. This also means that they do relatively little to partition and redirect complexity away from the writer. They exchange some formatting complexity for structural complexity, which may or may not be an overall win, but they do nothing to enhance rhetorical repeatability or drive information architecture, for instance.</db:para>
</db:listitem>
<db:listitem>
<db:para>Partly because a lot of the adoption of structured writing it not motivated by a desire to lessen the amount of complexity that goes unhandled in the content system (with the aim of improving content quality) but by a desire to improve some aspect of content management, particularly content reuse. While it is possible to do these things without resorting to structured writing for a format, structured writing formats ease the integration of the various parts. They also ease fears about having your content locked into the system of a single vendor.</db:para>
</db:listitem>
<db:listitem>
<db:para>Partly it is because constraints are onerous if you don’t get them right, and the benefits of getting them right are often under-appreciated, especially in content management applications where the consequences of a lack of constraints tends to show up years down the road (and it is all too easy to blame the problems that emerge on human failure rather than poor system design).</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>For all these reasons, it is worthwhile to look at where the big public languages fit in the structured writing picture.</db:para>
<db:para>For large systems like DocBook, DITA, and S1000D, there is not nearly enough space in this book to do them full justice or to fully characterize them in terms of the structured writing domains and algorithms described in this book. This chapter is therefore not to be taken as a buyers guide. Rather, this book as a whole is an attempt to provide a framework for thinking and talking about structured writing that will allow you to understand your requirements independently of any system, and then to evaluate, compare, and contrast systems in more or less neutral terms.</db:para>
<db:section>
<db:title>DITA</db:title>
<db:para>There are two ways of looking at DITA. You can look at it as a complete structured writing system which can be used more or less out of the box. (Even packaged applications like Word or FrameMaker are not used completely out of the box for serious content creation: some customization of styles and output format is needed at least, and the same is true of DITA.)</db:para>
<db:para>Alternatively, you can look at as what its name proclaims it to be: an information typing architecture. The acronym DITA stand for Darwin Information Typing Architecture, with the word “Darwin” representing DITA’s approach to the extensibility of markup: specialization.</db:para>
<db:para>With out-of-the-box DITA, you get a fixed set of topic types provided by the DITA specification and implemented in the DITA Open Toolkit and other tools. With DITA as an information typing architecture, you get the capability to create a unbounded number of information types. I will discuss DITA as an information typing architecture in <db:xref linkend="chapter.extensible"/>. Here I will look at out-of-the-box DITA.</db:para>
<db:para>Out-of-the-box DITA comes in two main forms.</db:para>
<db:orderedlist>
<db:listitem>
<db:para>The DITA Open Toolkit. You can download the DITA Open Toolkit for free and use it to produce content. The <db:indexterm><db:primary>formatting</db:primary></db:indexterm>formatting stylesheets that come with the toolkit are very basic, so you will likely want to do some customization of the output as a minimum.</db:para>
</db:listitem>
<db:listitem>
<db:para>Packaged DITA tools. There are a variety of tools that package DITA. Most of these are essentially content management systems of one degree of sophistication or another. These may add additional capabilities over what is supplied by the DITA Open Toolkit and may hide the underlying DITA structures to one extent or another. I don’t intend to say anything about any of these tools here. The package they offer may differ from the DITA Open Toolkit and should be evaluated on its own merits.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>The key features of out-of-the-box DITA that will determine how well its fits with your needs are its topic model and its focus on the <db:indexterm><db:primary>reuse algorithm</db:primary></db:indexterm>reuse algorithm. The description of the <db:indexterm><db:primary>document-domain</db:primary></db:indexterm>document-domain/<db:indexterm><db:primary>management-domain</db:primary></db:indexterm>management-domain approach to reuse in <db:xref linkend="chapter.reuse"/> is based on the DITA model, which provides comprehensive support in those domains.</db:para>
<db:para>As described in <db:xref linkend="chapter.blocks"/>, the DITA topic model is based on the concept of information typing, which is the idea that information can be usefully broken down into different abstract types, and that there is value in clearly separating the different types. (This is an approach to partitioning the complexity of information design.) One of the problems with this theory, and consequently with the application of DITA’s topic model, is that it is not clear how big an information type is, and whether an information type constitutes a rhetorical block or just a semantic block. Specializing DITA may allows you to be more specific on this point, but if you are using out-of-the-box DITA you are probably using the basic concept, task, and reference topic types (though out-of-the-box DITA now includes a number of other topic types such as Machine industry task and Troubleshooting). There is no clear answer to whether these topic types constitute semantic blocks or rhetorical blocks. In practice they are used both ways.</db:para>
<db:para>The principal thing that sets out-of-the-box DITA apart from other approaches to structured writing is its map and topic architecture. In most other systems, the unit that the writer writes and the unit that the reader reads are the same. For very long works, there may be a mechanism for breaking up and assembling pieces. For instance, in DocBook, you can write a book using a <db:code>book</db:code> document type in which you can include various <db:code>chapter</db:code> document types to create a complete book out of multiple files. In this model, a chapter is a rhetorical block, though it may also be an element of a larger rhetorical block which is the whole book. But DITA partitions this document assembly function into a separate file type, the map. In a DocBook book document, there is a lot of book content in addition to the included chapters. Indeed, you could write the entire book in one book file if you wanted to. The content model of a <db:indexterm><db:primary>DocBook</db:primary></db:indexterm>DocBook document is described by a single schema and the content model of the chapters is simply part of the content model of the book. In other words, a DocBook book is a single document structure that just happens to be made up of individual files. A DITA map file, on the other hand, is an independent structure. It does not create a single logical document structure. It does not usually contain any actual content, and you can’t write an entire book in a single map file. Instead, a map file is an instruction to a publishing tool chain about how to assemble a larger work out of component pieces.</db:para>
<db:para>This distinction is very important. In the DocBook model, there is a continuity of constraint between the book and its chapters. In DITA, the constraints on the map and the constraints on the topics in the map, are completely separate. This means that in DITA, the topic is the largest unit of content to which content constraints can be applied (at least in the conventional way). This represents a partitioning of the conformance, quality, and composition algorithms with leaves responsibility for larger units entirely with the writer.</db:para>
<db:para>Maps are structured like a tree so they can construct hierarchies an arbitrary number of layers deep. This means you have a choice about what parts of your structure you create using a map and what part you create inside a topic. If you have a list of four items, each of which needs two or three paragraphs of description, you can create one topic with the list of four items in it or you can create one topic for each item and then tie them together using a map. This is particularly important when we remember that the topic is the largest unit of content constraint in DITA. If we break the content down to this fine a level, we lose the ability to apply constraints to it. On the other hand, we are now able to <db:indexterm><db:primary>reuse</db:primary></db:indexterm>reuse each of these items separately.</db:para>
<db:para>This presents something of a dilemma. We have already talked about structure writing as dividing content into blocks and made a distinction between semantic blocks and rhetorical blocks (<db:xref linkend="chapter.blocks"/>). In the design of a markup language, rhetorical blocks are made up of semantic blocks which may be made up of smaller semantic blocks or structural blocks. This works fine for developing the structure of a rhetorical block, which is the work that will be presented whole to the reader. In that scenario, the unit that the writer writes is the rhetorical block. The semantic blocks are just elements of the model.</db:para>
<db:para>But things become more difficult when you attempt to do fine-grained reuse of content. Then you may want to write individual semantic blocks and combine them to produce rhetorical blocks. DITA will let you do this one of two ways. The first (which is frequently discouraged) is to nest one topic inside another. The second is to combine topics using a map, with the map representing the rhetorical block. However, DITA does not provide a high-level way to constrain the structure of a rhetorical block that is built this way.</db:para>
<db:para>If you want a constrained rhetorical block, you have to model it as a single DITA topic type. You can certainly do this by specializing from the base <db:code>topic</db:code> topic type, but in doing so you will probably move away from the “information typing” idea of keeping different types of information separate, as a full rhetorical topic often requires different types of information (as in the recipe example we have used so frequently).</db:para>
<db:para>This leads to the confusion about whether a DITA topic is a semantic block or a rhetorical block. For people who use out-of-the-box DITA this can be a problem because the default Web presentation of DITA places each topic on a separate page, which is not an appropriate presentation if your individual DITA topics are not rhetorical blocks. If your rhetorical block is made up of multiple DITA topics strung together by a map, and you want that rhetorical block to appear on a single page, you need to use a procedure called chunking, which is not as straightforward as it should be. (Chunking is one of the things on the agenda to be fixed in DITA 2.0.<db:footnote><db:para>http://docs.oasis-open.org/dita/dita-1.3-why-three-editions/v1.0/cn01/dita-1.3-why-three-editions-v1.0-cn01.html#future-of-dita</db:para></db:footnote>)</db:para>
<db:para>The idea that blocks are reusable is a very attractive one. But it is important to think through exactly what the reusable unit of content is. It is one thing to reuse rhetorical blocks whole (perhaps with some variations in the text). It is quite a different thing to reuse semantic blocks below the level of the rhetorical block, particularly if it is important to constrain the rhetorical block or to apply any of the other structured writing algorithms at the level of the rhetorical block.</db:para>
<db:para>Quality should be a serious concern with this model. If rhetorical blocks are being assembled out of smaller reusable units without proper attention to the rhetorical integrity or completeness and consistency of the result, quality can be seriously affected. If the author no longer sees, thinks, or works in the context of the rhetorical block, and if the structure of the rhetorical block is not constrained, content quality is very difficult to maintain. Complexity is being dumped on the reader because the cure for the reuse problem did not consider where the rhetorical complexity of <db:indexterm><db:primary>composition</db:primary></db:indexterm>composition would go.</db:para>
<db:para>DITA, as a technology, does not prevent you from working in whole rhetorical blocks, or from constraining your blocks in any way you want (using its information typing capabilities). But the block and map model (whether implemented by DITA or any other system) presents this inherent tension between creating smaller semantic blocks to optimize for reuse vs creating constrainable rhetorical blocks to optimize for content quality. And because it provides no facilities for imposing constraints above the topic level, it makes it difficult to partition and redirect this complexity away from the writer.</db:para>
<db:para>But merely doing reuse of content blocks does not require either kind of constraint. The constraints may improve quality and reliability of the system if used correctly and consistently, but the actual act of composing larger blocks out of smaller blocks does not require them. This has led many organizations to use DITA for its reuse capabilities without paying any particular attention to its constraint capabilities or its information typing roots. People taking this approach will sometime write their content in the base <db:code>topic</db:code> topic type rather than a more constrained specialization. Quite simply, they are not finding that the partitioning of information design provided by DITA’s information typing to be useful and so are ignoring it. Of course, this means that they are laying the responsibility for composability on the writers, but this does not make them any worse off if DITA’s information typing was not helping the writers, or DITA’s approach did not fit the material.</db:para>
<db:para>The growing popularity of this approach to reuse has led to the development of alternatives to DITA that provide the same reuse-management capabilities but remove the constraint mechanisms. One example of this trend is <db:indexterm><db:primary>Paligo</db:primary></db:indexterm>Paligo, a reuse-focused component content management system that uses <db:indexterm><db:primary>DocBook</db:primary></db:indexterm>DocBook as its underlying content format, specifically for the purpose of minimizing constraints on the content.<db:footnote><db:para>http://idratherbewriting.com/2016/08/01/paligo-the-story-xml-ccms-in-the-cloud/</db:para></db:footnote> Such systems can reduce the up-front complexity of component-based content-reuse, though possibly at the expense of costs down the road due the failure to apply constraints up front. In other words, more unhandled complexity falling through to readers.</db:para>
</db:section>
<db:section>
<db:title>DocBook</db:title>
<db:para><db:indexterm><db:primary>DocBook</db:primary></db:indexterm>DocBook is an extensive, largely document-domain language with a long history and an extensive body of processing tools and support. As we have noted, <db:indexterm><db:primary>DocBook</db:primary></db:indexterm>DocBook is not a tightly constrained language. Instead it is focused on providing very broad capability for describing document structures. In other words, it is mainly concerned with partitioning the document domain from the media domain in as comprehensive manner as possible. It makes no attempt to constrain the rhetoric of content in any way, and therefor makes no attempt to partition and distribute any part of the creative aspects of the content system.</db:para>
<db:para>Unlike <db:indexterm><db:primary>DITA</db:primary></db:indexterm>DITA, <db:indexterm><db:primary>DocBook</db:primary></db:indexterm>DocBook does not ascribe to any information typing theory. It does not have an opinion about how content should be written or organized. It is very much about the structure of books, and leaves it to the author to decide what the rhetorical structure of the text should be. In other words, DocBook makes no attempt to constrain the rhetorical structure of a work, and in fact makes every attempt to avoid constraining it. The downside of this hands-off approach is that DocBook is a complex system, and the writer is forced to deal with this tool complexity without any of the benefit of other aspects of their task being partitioned and directed away.</db:para>
<db:para>Of course, this is not to say that the tool complexity of DocBook is any worse than that of similarly complex and capable publishing tools like FrameMaker. It may well be less so. DocBook is, nonetheless, can be quite challenging to learn and use. Because of this, writers often use simplified subsets of DocBook. (Where DITA is sometimes customized by the addition of elements, DocBook is often customized by their subtraction.) However, DocBook remains popular with many for its lack of constraint combined with its rich feature set.</db:para>
<db:para>Because of its lack of constraint, <db:indexterm><db:primary>DocBook</db:primary></db:indexterm>DocBook is not a particularly great fit with the idea of structured writing as a means to partition and redirect the complexity of the content system. However, it can play a very useful role in a structured writing tools chain as a language for the <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm>presentation algorithm. This is exactly how it is used in the production of this book. The book is written in SAM in a small, constrained language developed just for the purpose, which is then transformed by the presentation algorithm into DocBook, which then feeds the publisher’s standard publishing tools.  The DocBook created by this method matches the publisher’s exact specifications as required to make the tools work correctly.</db:para>
<db:para>In using this approach I was partitioning the complexity of meeting the Publisher’s DocBook requirements from my task of writing the book and providing myself with a much simpler authoring interface (both syntactically and semantically simpler). Of course, I was transferring that complexity to myself in another role (information architect or content engineer), since I had to write the algorithm that transformed my SAM source from my simple book authoring language to the publisher’s preferred form of DocBook. But this was a big win for me, because writing that algorithm was a separate activity that did not impinge on my attention when I was engaged in the writing task. Another benefit was that because my little book writing language is highly constrained, conformance was much easier, and that meant that the DocBook produced by my algorithm was much more consistent and conformed much better to the publisher’s requirements than if I had written in DocBook directly.</db:para>
<db:para>I wrote my previous book (<db:emphasis>Every Page is Page One</db:emphasis>) directly in DocBook (an experience that contributed to my decision to develop SAM) but it took a lot of revision to get the DocBook I wrote into the form that the publication process required. In other words, the publishing process has a set of constraints that are not enforced by DocBook itself, and have to be imposed by human oversight and editing when an author writes in DocBook. But in my highly constrained SAM-based markup language, all those constraints were factored out, which enabled me to translate it reliably into the DocBook that the publisher needed. And to work without having to remember any of these constraints.</db:para>
</db:section>
<db:section>
<db:title>S1000D</db:title>
<db:para>S1000D is a specification developed in the aviation and defense industries specifically for the complex documentation tasks of those industries, and intended to support the development of the Interactive Electronic Technical Manuals (IETMs) that are typically required in that space. While it obviously has a fair amount of <db:indexterm><db:primary>subject domain</db:primary></db:indexterm>subject domain structures for the target domains, it also has media domain structures targeted at the production of IETMs and extensive management domain structures designed to support the common source database (CSDB), the content management architecture which is part of the S1000D specification. S1000D, in other words, is much more than a structured writing format. It is a specification for a complete document production system for a specific industrial sector. S1000D, in other words, represents a particular partitioning of the content system designed for a particular industry.</db:para>
</db:section>
<db:section>
<db:title>HTML</db:title>
<db:para>HTML is widely used as an authoring format for content. For the most part this is a pure <db:indexterm><db:primary>media domain</db:primary></db:indexterm>media domain usage: people writing for the web in its native format, often using a WYSIWYG HTML editor.</db:para>
<db:para>But HTML is still a document domain language, and efforts have been made over the years to factor out the media domain aspects of the languages and leave the formatting to CSS stylesheets. This makes HTML a legitimate <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain markup language. In particular, people interested in using HTML this way often use XHTML, the version of HTML that is a valid instance of XML. Being an instance of XML is important because it means you can write XHTML in an XML editor and process it with XML processing tools. This means that you can potentially publish content written in XHTML by processing it into other formats or by modifying its structure for use in different HTML-based media such as the Web and ebooks.</db:para>
</db:section>
<db:section>
<db:title>Subject domain languages</db:title>
<db:para>There are hundreds of public subject domain languages written in XML. Most of these are more data oriented than content oriented, but you might be able to derive content from some of them using the <db:indexterm><db:primary>extract and merge</db:primary></db:indexterm>extract and merge algorithms. Wikipedia maintains an extensive list at <db:link xlink:href="https://en.wikipedia.org/wiki/List_of_markup_languages">https://en.wikipedia.org/wiki/List_of_markup_languages</db:link>. However, most subject domain languages used for content are developed in house to suit a particular subject matter and reader base.</db:para>
</db:section>
</db:chapter>
