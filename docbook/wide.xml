<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.wide"><db:title>Wide Structures</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp1472212244"><db:primary>tables</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1472212244x"><db:primary>structure</db:primary><db:secondary>tables</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idp1472218644"><db:primary>graphics</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1472218644x"><db:primary>structure</db:primary><db:secondary>graphics</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idp1472220052"><db:primary>code blocks</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1472220052x"><db:primary>structure</db:primary><db:secondary>code blocks</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idp1472223252"><db:primary>pre-formatted text</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1472223252x"><db:primary>concept</db:primary><db:secondary>pre-formatted text</db:secondary></db:indexterm>




<db:para>The notion of separating content from formatting works quite well when the content is a string of words. A string of words has only one dimension: length. A printed string, of course, has two dimensions: length and height, since each letter has a height and a width. But the height and the width of letters is a pure <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media-domain concern. Fitting a one-dimensional string of characters into a two dimensional font on a two dimensional page is one of the first things that gets factored out as we begin to structure content. When we separate content from formatting, we separate the font from the character and are left with a string of characters whose length is measured not in inches or centimeters but in character count.</db:para>
<db:para>Once these formatting dimensions are factored out, it becomes easy to create and manage text in the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document and <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domains without thinking about how it will eventually flow onto a page or screen.</db:para>
<db:para>But when it comes to content that has dimensions that cannot be factored out, things get more difficult. The main problem cases are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>tables</db:para>
</db:listitem>
<db:listitem>
<db:para>pre-formatted text, such as a program listing, that has meaningful line breaks</db:para>
</db:listitem>
<db:listitem>
<db:para>graphics and other media</db:para>
</db:listitem>
</db:itemizedlist>
<db:section><db:title>Tables</db:title>


<db:para>Tables are one of the more complex problems in structured writing, particularly in the document domain. A table laid out for presentation in one publication can easily get messed up when an algorithm tries to fit it into another, as in <db:xref linkend="broken-table-formatting"/>, which comes from a commercially published book on my Kindle.</db:para>
<db:figure xml:id="broken-table-formatting"><db:title>Broken table formatting</db:title><db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/tableformatting.jpg" contentwidth="3.75in" align="center"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/tableformatting.jpg"/></db:imageobject><db:textobject><db:para>Badly formatted table.</db:para></db:textobject></db:mediaobject></db:figure>
<db:para>This table is difficult because one wide thing (a table) contains another wide thing (pre-formatted program code). I don’t know exactly how this table was marked up, which domain the content was written in, or how the <db:indexterm><db:primary>formatting algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>formatting algorithm</db:secondary></db:indexterm>formatting algorithm failed, resulting in the mess above, but including pre-formatted text in a table cell creates a no-win situation for a rendering algorithm. Does it:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>violate the formatting of the program code by introducing extra line breaks.</db:para>
</db:listitem>
<db:listitem>
<db:para>give the code the space it needs by squeezing all the other columns impossibly narrow.</db:para>
</db:listitem>
<db:listitem>
<db:para>resize the columns proportionally and let the pre-formatted text overlap the next column, but truncate it at the edge of the table.</db:para>
</db:listitem>
<db:listitem>
<db:para>resize the columns proportionally and truncate the pre-formatted text at the column boundary.</db:para>
</db:listitem>
<db:listitem>
<db:para>shrink the entire table so everything formats correctly, even if it is shown in three point type.</db:para>
</db:listitem>
<db:listitem>
<db:para>let the table expand outside the viewport so that it is either cut off or the reader has to scroll horizontally. (Web browsers tend to take this approach, but will it work on an e-reader? It certainly won’t work on paper.)</db:para>
</db:listitem>
<db:listitem>
<db:para>make the table into a graphic so readers can pan and zoom like they do with a large picture. (Some e-books take this approach.)</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>If you are thinking that there is no good option in the bunch, you appreciate the extent of the problem. For existing books being transferred to e-readers, you can’t do much to salvage the situation, short of completely restructuring the file. Those books were probably prepared in a word processor on the more abstract edge of the media domain, and the tables were prepared for a known page width in the printed book.</db:para>
<db:para>Because many people read on small devices such as tablets, e-readers, and phones, wide tables cause problems. On a phone, the amount of a table that is visible on screen at any one time may be so small as to make the table essentially unnavigable and useless for such common tasks as looking up values or presenting an overview of a subject at a glance.</db:para>
<db:para>Tables can cause problems with height as well as width. While most authors would never import a graphic that was six feet tall, we sometimes create tables that are that long or longer. On a web browser, readers can simply scroll the table. But as soon as you start scrolling, you lose sight of the column headers and it becomes harder to read data across the table. On paper, you can repeat the headings at the top of each page when a table flows over several pages. This works, and you can imitate the effect in a web browser by placing the body of the table in a scrollable frame under a fixed heading. But what happens if the height of a table row is larger than the height of the page? How do you break the text in each cell in that row? In traditional typesetting, you can make adjustments by hand on a case-by-case basis, but getting a rendering algorithm to do this gracefully in every case is very challenging.</db:para>
<db:para>Creating tables in the document domain creates problems even when the intended output is paper, and you assume a sufficiently wide viewport. Since a table divides content into multiple columns, there is always a question of how wide each column should be relative to the others and whether or not the table should occupy the full width of the viewport. For example, you probably don’t want a table with just a few numeric values to span a full page width because that would spread the numbers out too far and make comparisons difficult. One the other hand, a table with a lot of text in each cell needs to be full width and needs to have column widths roughly proportional to the amount of text in the each column. However, suppose the first column is a side head with far fewer words than the other columns. You probably don’t want to compress that column proportional to its word count because then the side headings will be unreadable.</db:para>
<db:para>In a media-domain editor, which shows the formatting of the content as it will appear on paper, a writer can create a table at a fixed width and drag the column widths around to get the aesthetics of column boundaries right by eye. But tables created like this are not likely to format correctly on other devices, as <db:xref linkend="broken-table-formatting"/> shows. And if you move content creation out of the media domain and into the document domain, you can no longer present writers with a WYSIWYG page width that would allow them to adjust column widths by eye. (You can fake it, but adjustments made on screen bear no relationship to how the table displays on any output page.) At this point you have to leave column-width calculation to the rendering algorithm. The best you can do it to give it some hints.</db:para>
<db:figure xml:id="cals-table-example"><db:title>CALS table markup language column and row span example (from Wikipedia)</db:title><db:programlisting language="xml">
&lt;table&gt;
  &lt;title&gt;Table title&lt;/title&gt;
    
  &lt;tgroup cols="3"&gt;
    &lt;colspec colname="_1" colwidth="1*"/&gt;
    &lt;colspec colname="_2" colwidth="3*"/&gt;
    &lt;colspec colname="_3" colwidth="2*"/&gt;
    
    &lt;thead&gt;
      &lt;row&gt;
        &lt;entry&gt;1st cell in table heading&lt;/entry&gt;
        &lt;entry&gt;2nd cell in table heading&lt;/entry&gt;
        &lt;entry&gt;3rd cell in table heading&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;1st cell in table heading&lt;/entry&gt;
        &lt;entry&gt;2nd cell in table heading&lt;/entry&gt;
        &lt;entry&gt;3rd cell in table heading&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/thead&gt;
    
    &lt;tbody&gt;
      &lt;row&gt;
        &lt;entry&gt;1st cell in row 1 of table body&lt;/entry&gt;
        &lt;entry&gt;2nd cell in row 1 of table body&lt;/entry&gt;
        &lt;entry&gt;3rd cell in row 1 of table body&lt;/entry&gt;
      &lt;/row&gt;
    
      &lt;row&gt;
        &lt;entry nameend="_2" namest="_1"&gt;cell spanning two columns&lt;/entry&gt;
        &lt;entry morerows="1"&gt;cell spanning two rows&lt;/entry&gt;
      &lt;/row&gt;
    
      &lt;row&gt;
        &lt;entry&gt;1st cell in row 3 of table body&lt;/entry&gt;
        &lt;entry&gt;2nd cell in row 3 of table body&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/tbody&gt;
  &lt;/tgroup&gt;
&lt;/table&gt;
</db:programlisting></db:figure>
<db:para>This need to give the rendering algorithm hints about how to fit tables to pages has resulted in the creation of some very complicated table markup languages. <db:xref linkend="cals-table-example"/> contains an example using the <db:indexterm><db:primary>CALS table model</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>CALS table model</db:secondary></db:indexterm>CALS table model. It shows a table that has one cell spanning two columns and one cell spanning two rows. As you can tell, this is not exactly obvious from the markup. In practice, few writers create CALS tables by writing the markup by hand. Instead, they use the table drawing tools in a graphical XML editor.</db:para>
<!--  >>> screen shot -->
<db:para>However, although graphical XML editors can display tables in a manner that looks the same as a word processor like <db:indexterm><db:primary>Microsoft Word</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>Microsoft Word</db:secondary></db:indexterm>Microsoft Word, they cannot allow writers to make the kinds of <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media-domain adjustments that they can make with a word processor. A word processor’s graphical display is based on the actual page currently set up in printer settings and on the font the document will be printed in. Therefore, a writer can see how a table fits on an actual page and make <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media-domain adjustments. An XML editor cannot know the page size or the font. So while the display looks like it allows writers to make the same <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media-domain adjustments, this is an illusion, and the table will not print as shown on screen. This gives a false impression of the real complexity of the table problem, hiding complexity from the person who is supposed to deal with it.</db:para>
<db:para>Other markup languages take a different approach to tables. For instance, <annotation type="markup-language">reStructuredText</annotation> allows you to create a table using markup that looks like <db:xref linkend="restructuredtext-table-example"/>.</db:para>
<db:figure xml:id="restructuredtext-table-example"><db:title>reStructuredText table markup language column and row span example</db:title><db:programlisting language="reST">
+------------+------------+-----------+ 
| Header 1   | Header 2   | Header 3  | 
+============+============+===========+ 
| body row 1 | column 2   | column 3  | 
+------------+------------+-----------+ 
| body row 2 | Cells may span columns.| 
+------------+------------+-----------+ 
| body row 3 | Cells may  | - Cells   | 
+------------+ span rows. | - contain | 
| body row 4 |            | - blocks. | 
+------------+------------+-----------+
</db:programlisting></db:figure>
<db:para>Like the CALS example, reStructuredText allows you to span rows and columns, and in this example, the effect is obvious. Equally obvious is that editing or creating a table with any significant amount of text in the cells is going to be very difficult. Nor does reStructuredText solve any of the table rendering challenges described above.</db:para>
</db:section>
<db:section><db:title>Alternatives to tables</db:title>


<db:para>Structured writing is about partitioning and redirecting the complexity of content so that it is always handled by someone with the attention, knowledge, and resources to handle it. As the discussion above demonstrates, table markup dumps a lot of complexity on writers, complexity they are not fully able to handle because they don’t control the final formatting of content in all the media and devices it will be presented on. The best way to partition the problem, therefore, is to factor out the decision to present information as a table. Let writers capture information, and move the decision on whether to present that information as a table or in some other form down the road.</db:para>
<db:para>What can you factor the content into? There are a number of alternatives, depending on what the table was being used for.</db:para>
<db:section><db:title>Alternate presentations</db:title>


<db:para>In many cases, tables simply aren’t necessary. There are other ways to present the content with no loss of comprehensibility or quality. Sometimes, tables are just used to format lists, particularly lists with two levels of nesting. If a list is an equally effective way of presenting content, choose a list rather than a table when writing in the document domain. Sometimes only part of the content needs to be in tabular format and can be express just as well as other, simpler structures that contain a table or tables within them.</db:para>
</db:section>
<db:section><db:title>Subject-domain structure</db:title>


<db:para>One way to present the list of ingredients in a recipe is to create a table with the ingredient name aligned left and the quantity aligned right. But as we have seen in our recipe examples, you can create a subject-specific ingredient list structure to capture your ingredient information, which you can then format any way you like for output.</db:para>
<db:figure xml:id="subject-specific-recipe"><db:title>Subject-domain ingredient listing</db:title><db:programlisting language="sam">
ingredients:: ingredient, quantity, unit
    eggs, 3, each
    salt, 1, tsp
    butter, .5, cup
</db:programlisting></db:figure>
<db:para>A structure such as the one shown in <db:xref linkend="subject-specific-recipe"/> is a table in a different sense of the word: it is a database table and the <db:code>ingredients</db:code> structure creates a mini database table inside the body of the content. The difference between this table and a media-domain table is that we know exactly what type of information each column contains. This allows the <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>presentation algorithm</db:secondary></db:indexterm>presentation algorithm to make intelligent choices about column widths and all the other rendering issues that arise with tables and then pass on appropriate hints to the <db:indexterm><db:primary>rendering algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>rendering algorithm</db:secondary></db:indexterm>rendering algorithm. Of course, this structure also supports presentation using a list rather than a table.</db:para>
<db:para>Tables are also sometimes used in procedures. With a table, you can create side heads for step numbers in one column and a description for each step in another column. However, instead of this, consider using explicit procedure markup, which can be formatted differently depending on the output medium. If you choose a table as the output format, knowing that the contents are a procedure allows the <db:indexterm><db:primary>formatting algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>formatting algorithm</db:secondary></db:indexterm>formatting algorithm to provide appropriate layout hints to the <db:indexterm><db:primary>rendering algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>rendering algorithm</db:secondary></db:indexterm>rendering algorithm.</db:para>
</db:section>
<db:section><db:title>Record data as data</db:title>


<db:para>Many reference works have traditionally been presented as tables on paper. But most such works are really databases. They are designed to be queried, not read. That is, they are used to look up individual pieces of data in a large set. For a database of this sort, <db:indexterm><db:primary>differential single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>differential single sourcing</db:secondary></db:indexterm>differential single sourcing requires that you provide the best method of querying the data for each output medium; that is, the method whose interface fits best in the available viewport. To support differential single sourcing, you should not record data in tables, at least, not in <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media-domain tables. You should record it in whatever database format best suits the data and the kinds of queries your readers want to make.</db:para>
<db:para>If you want to support printed tables for print media, then you should <db:indexterm><db:primary>extract</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>extract</db:secondary></db:indexterm>extract content from the database to create the printed table. The additional semantic information available from the database structure allows the <db:indexterm><db:primary>formatting algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>formatting algorithm</db:secondary></db:indexterm>formatting algorithm to supply appropriate rendering hints to the <db:indexterm><db:primary>rendering algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>rendering algorithm</db:secondary></db:indexterm>rendering algorithm.</db:para>
<db:para>When you have done all of that, you will probably be left with two kinds of tables to deal with: small ad-hoc grid layouts and one-of-a-kind database tables. These are tables that occur just once and don’t justify the overhead of creating a subject-domain data structure. For these, you need some form of document-domain table markup. Which markup you choose will come down to how much fancy formatting of tables you require and how willing you are to let the rendering algorithm format your tables without extensive hinting.</db:para>
</db:section>
</db:section>
<db:section><db:title>Code</db:title>


<db:para>There are some texts, particularly computer code and data, in which line breaks are meaningful. (Poetry is another example, but its issues are simpler than those of code, so I will stick to talking about code.) Code is a form of structured writing and, in many languages, whitespace – meaning line breaks, spaces, and indentation – is part of the markup that defines the structure of the program. Therefore, when you present code in a document, you have to respect whitespace.</db:para>
<db:para>Furthermore, programmers usually work in a fixed-width font, meaning that all the letters are the same width when displayed. Programmers align similar structures with whitespace to make them easier to read; using a proportional width font for code in documentation messes up formatting and looks weird to programmers. It also makes the code less recognizable as code, which could reduce <db:indexterm><db:primary>information scent</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>information scent</db:secondary></db:indexterm>information scent.</db:para>
<db:para>Therefore, computer code, data, and other similar formats where whitespace is meaningful must be presented in a fixed-width font with line breaks placed where they are supposed to be. That makes code samples wide objects, just like tables, with many of the same issues when it comes to rendering them on small devices. One saving grace is that programming examples are less likely to have issues with height.</db:para>
<db:para>There is not much you can do to help the <db:indexterm><db:primary>rendering</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>rendering</db:secondary></db:indexterm>rendering algorithm when it comes to code. The options for fitting wide code on a narrow display are: shrink to fit, scroll to view, or truncate. You probably do not want your <db:indexterm><db:primary>rendering</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>rendering</db:secondary></db:indexterm>rendering algorithm to make a different choice for different kinds of code. Needless to say, putting a code block inside another wide structure, such as a table, is a recipe for disaster, as <db:xref linkend="broken-table-formatting"/> shows. It would be wisest not to allow this in your markup language design.</db:para>
<db:para>What is essential is that your document-domain or subject-domain markup clearly indicate when a piece of text is code. Preferably it should also indicate what kind of code it is, since knowing this can allow the formatting algorithm to do syntax highlighting for code in a known language and can allow the linking algorithm to detect and link API calls to the API reference. In some cases it might even allow an algorithm to validate the code to make sure it runs or uses the current version of the API.</db:para>
</db:section>
<db:section><db:title>Pictures and graphics</db:title>


<db:para>Pictures and graphics are naturally wide objects. There are two basic formats: <db:indexterm><db:primary>raster graphics</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>raster graphics</db:secondary></db:indexterm>raster and <db:indexterm><db:primary>vector graphics</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>vector graphics</db:secondary></db:indexterm>vector. Raster graphics are made up of pixels, like a photograph, and have a fixed resolution. Vector graphics are stored as a set of lines and curves and can be scaled to meet any output requirement.</db:para>
<db:para>The publishing algorithm needs to know how big the graphic is and how large it is supposed to be on the page. With raster files, the resolution – that is, the number of pixels – is set. However, its size on the page can vary. Is a graphic that is 600 pixels by 600 pixels a 1x1 inch picture at 600 dpi, a 2x2 inch picture at 300 dpi, or a 6x6 inch picture at 100 dpi? This is important if you are inserting a headshot into a document that will be published on both paper and the web. Rendering that photo on paper as a 1x1 inch image makes sense, but you don’t want that photo to blow up to a 6x6 image when you add it to a web page, where it will be displayed it at a typical 96dpi unless something intervenes to scale it appropriately.</db:para>
<db:para>Then there is the question of the intended size of the image, which is a design consideration independent of the resolution of the raster file. The intention of the graphic artist who created the picture and the intention of a writer using it to create a deliverable both play a role here. Diagrams showing complex relationships should not be shrunk down to where the relationships are unreadable. Simple diagrams should not be blown up to the size of a full page. Diagrams containing text should not be reduced or expanded so that the text becomes invisible or out of proportion with the text on the page.</db:para>
<db:para>The writer may have some discretion, based on the role the graphic has to play, but the result should stay within the range prescribed by the artists’s intention. In other words, you have to correctly partition the concerns of both the creator and the user of a graphic, and you have to make sure both parties can communicate effectively so that none of the complexity of the relationship gets dropped.</db:para>
<db:para>If the <db:indexterm><db:primary>rendering algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>rendering algorithm</db:secondary></db:indexterm>rendering algorithm does not know how big a graphic should be, it has limited choices, depending on whether the graphic is too big or too small for the viewport:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Show a raster graphic at 100% of its resolution, regardless of whether it fits in the viewport (which may require cropping it or forcing readers to scroll it).</db:para>
</db:listitem>
<db:listitem>
<db:para>Scale the graphic to the viewport (which may require stretching or shrinking it).</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Since neither of these options produces consistently good results, you generally need to give the rendering engine information to help it render the graphic appropriately.<db:footnote>
<db:para>Many web designers take an opposite approach, preparing a graphic to the exact size required for a specific web page layout. This is strictly a media-domain approach, of course. In structured writing, we need a more flexible solution to avoid what we have all seen happen when a meticulously designed desktop website gets displayed on a phone screen.</db:para>
</db:footnote></db:para>

<db:para>The simplest way to supply this information is to include it in the markup that inserts the graphic. Thus, HTML lets you specify the height and width of a graphic (see <db:xref linkend="fig.html-height-width"/>).</db:para>
<db:figure xml:id="fig.html-height-width"><db:title>HTML image markup</db:title><db:programlisting language="html">
&lt;img 
    src="http://www.example.com/images/example.png" 
    height="150" 
    width="140" /&gt;
</db:programlisting></db:figure>
<db:para>But do these values represent the size of the graphic or the size at which is it to be displayed in a particular medium? In other words, do they tell a processor the size of the image itself or do they describe the size of the box (viewport) the image should fit in?<db:footnote>
<db:para>This is actually quite a complicated question, and the meaning has changed between various version of HTML. For some hints of the complexities involved, see http://www.w3.org/TR/html5/single-page.html#attr-dim-width.</db:para>
</db:footnote></db:para>

<db:para><annotation type="markup-language"><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook</annotation> allows you to make this distinction. Its <db:code>imagedata</db:code> tag supports attributes for specifying the size of the viewport (<db:code>height</db:code> and <db:code>width</db:code>) and the size of the image (<db:code>contentheight</db:code> and <db:code>contentwidth</db:code>). The specification also contains additional attributes related to scaling and alignment and complex rules about how the <db:indexterm><db:primary>rendering algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>rendering algorithm</db:secondary></db:indexterm>rendering algorithm is supposed to behave based on which combination of these attributes you specify.<db:footnote><db:para>http://www.docbook.org/tdg/en/html/imagedata.html</db:para></db:footnote> In other words, DocBook contains a sophisticated language to describe the sizing and scaling of graphics. It not only deals with <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media-domain properties, it actually gives <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media-domain instructions.</db:para>
<db:para>Of course, working in the media domain can cause problems. It interferes with <db:indexterm><db:primary>functional lucidity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functional lucidity</db:secondary></db:indexterm>functional lucidity and makes <db:indexterm><db:primary>differential single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>differential single sourcing</db:secondary></db:indexterm>differential single sourcing more difficult. But there is another issue to consider. In addition to needing different scaling values for different output media, sometimes the best approach to <db:indexterm><db:primary>differential single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>differential single sourcing</db:secondary></db:indexterm>differential single sourcing is to use different versions of the same graphic for different media. For instance, you may want to use a vector format for print and a raster format for online media.</db:para>
<db:para>For all these reasons, we need to distinguish the source of an image from the rendering of that image. For raster images, the source is the original high-resolution file recorded by a camera, a screen shot, or a raster file produced by an image editing program. For vector graphics, it is the original vector drawing file. From these source images, you can render a wide range of images.</db:para>
<db:para>What if you need a vector version for some media and a raster version for others? One approach is to generate a raster version of the appropriate size from the vector version. This can be done at build time, but most of the time you store multiple versions and select the right one to publish. To create the best image in each format, the artist may even create several renderings of the same image idea, optimizing each for different uses. For instance, you may need a separate gray-scale version of your company logo, because the automatic gray-scale rendering of a color logo may not look good. You may also want to use different resolutions of the same raster graphic for different media or for different purposes. And you may want to manually redraw a graphic at different resolutions to add or remove detail, rather than simply scaling it mechanically.</db:para>
<db:para>In these cases, how do you include the image in your source content? You can’t simply include the source file and scale it, since there are now several source files. You have to go back to the idea of the image – the image that was in the artist’s head – rather than any of the individual renderings of that image. How do you do that?</db:para>
<db:para>In <annotation type="markup-language"><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook</annotation> you can use conditional processing, as shown in see <db:xref linkend="ex.docbook-conditional-image"/>. In this example, the <db:code>condition</db:code> attribute on the <db:code>imageobject</db:code> element specifies a different file to be used for two versions of a book (this book, actually). The <db:code>epub</db:code> version is for eReaders, most of which cannot render <db:indexterm><db:primary>SVG</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SVG</db:secondary></db:indexterm>SVG drawings, and so require a raster format (<db:indexterm><db:primary>PNG</db:primary></db:indexterm><db:indexterm><db:primary>format</db:primary><db:secondary>PNG</db:secondary></db:indexterm>PNG in this case), while the <db:code>fo</db:code> version is for print publication using the <annotation type="language-language">XSL-FO</annotation> <db:indexterm><db:primary>page description language</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>page description language</db:secondary></db:indexterm>page description language and uses the vector format <db:indexterm><db:primary>SVG</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SVG</db:secondary></db:indexterm>SVG for high-resolution rendering in print.</db:para>
<db:figure xml:id="ex.docbook-conditional-image"><db:title>DocBook markup for conditional images</db:title><db:programlisting language="DocBook">
&lt;mediaobject&gt;
  &lt;imageobject condition="epub"&gt;
    &lt;imagedata 
        fileref="../graphics/assemble.png"/&gt;
  &lt;/imageobject&gt;
  &lt;imageobject condition="fo"&gt;
    &lt;imagedata 
        fileref="../graphics/assemble.svg" 
        contentwidth="4in" 
        align="left"/&gt;
  &lt;/imageobject&gt;
&lt;/mediaobject&gt;
</db:programlisting></db:figure>
<db:para>However, this approach not only uses <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media-domain markup, it combines it with <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management-domain markup. Is it possible to factor all of this out of the authored format?</db:para>
<db:para>Yes, if the writer includes the idea of the image rather than a rendering of the image. There are several ways to do this. In fact, this is the same method described for the <db:indexterm><db:primary>reuse algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>reuse algorithm</db:secondary></db:indexterm>reuse algorithm where we factored out the filename of the content to be included and replaced it with a semantic representation of the reason for the content.</db:para>
<db:para>In <db:xref linkend="chapter.management-domain"/>, we factored out an explicit filename from this example:</db:para>
<db:programlisting language="sam">
procedure: Blow stuff up
    &gt;&gt;&gt;(files/shared/admonitions/danger)
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting>
<db:para>and replaced it with a management domain <db:indexterm><db:primary>key</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>key</db:secondary></db:indexterm>key in this example:</db:para>
<db:programlisting language="sam">
procedure: Blow stuff up
    &gt;&gt;&gt;(%warn_danger)
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting>
<db:para>Then we refactored that into a <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain assertion of fact in this example:</db:para>
<db:programlisting language="sam">
procedure: Blow stuff up
    is-it-dangerous: yes
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting>
<db:para>You can apply these techniques to insert graphics as well as text. Suppose you have a constraint that whenever a procedure mentions a dialog box, you must include a picture of that dialog box, and you need to support three different platforms, each of which has different dialog boxes.</db:para>

<?dbfo-need height="2in"?>

<db:para>You can factor out the platform-specific version of the image by using a key to insert the image:</db:para>
<db:programlisting language="sam">
procedure: Save a file
    step: 
        From the File menu, choose 
        Save. The *Save As* 
        dialog box appears. 
        
        &gt;&gt;&gt;(%dialog.save-as)
</db:programlisting>
<db:para>Now the presentation algorithm can use a key lookup table to select the right version of the <db:emphasis role="bold">Save As</db:emphasis> dialog box for the version of the documentation you are building. If you port the product to a new platform, all you need is a new set of screen shots and a new key lookup table. You don’t have to change the content at all.</db:para>
<db:para>There is a simple rhetorical pattern at work in this passage. When a step mentions a dialog box, you show a picture of that dialog box. You can exploit this pattern to factor the insert command out of the content altogether by annotating the mentions of UI components in the text:</db:para>
<db:programlisting language="sam">
procedure: Save a file
    step: 
        From the {File}(menu) menu, choose 
        {Save}(menu-item). The {Save As}(dialog-box) 
        dialog box appears. 
</db:programlisting>
<db:para>Now you can insert the correct screen-shot graphic for the current platform with an algorithm:</db:para>
<db:programlisting language="pseudo">
match procedure/step/dialog-box
    $dialog-box-name = contents
    $graphic = find graphic where type = dialog box 
        and name = $dialog-box-name
        and platform = $current-build-platform
    insert graphic
</db:programlisting>
<db:para>There are several benefits to this partitioning of the image problem:</db:para>
<db:orderedlist>
<db:listitem>
<db:para>Authors do not have to worry about finding or inserting graphics or remembering the rules about when they are supposed to use screenshots. They just have to remember to mark up the names of dialog boxes when they mention them. If you only want to show screen shots for certain screens, you supply the screen shots for only those screens and have your algorithm pass silently over any <db:code>dialog-box</db:code> entry that does not have a screen shot in the collection. This allows you to adjust to reader feedback about how many screen shots are needed by simply adding them to or removing them from the collection; you don’t need to change the content at all – partitioning at work.</db:para>
</db:listitem>
<db:listitem>
<db:para>Updating graphics for UI changes is simpler because you just update the catalog of images. You don’t have to search through docs to find images that are affected by the change.</db:para>
</db:listitem>
<db:listitem>
<db:para>You don’t need any conditional logic in the text to include the right graphic for the platform.</db:para>
</db:listitem>
<db:listitem>
<db:para>In media where the screen shot would not fit in the viewport, you can suppress the image or handle it a different way.</db:para>
</db:listitem>
<db:listitem>
<db:para>If you decide that most readers won’t need to see the screenshot, you can use the markup to create a link to a topic describing the dialog box instead of putting a screenshot inline. In a <db:indexterm><db:primary>reuse</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm>reuse scenario, you might make different choices for content aimed at different levels of users (for instance, including screenshots only in material intended for novices).</db:para>
</db:listitem>
</db:orderedlist>
<db:para>In principle, there isn’t any difference between factoring out text and factoring out graphics. Indeed, beyond factoring out text or graphics, this partitioning also factors out the decision about whether to express a particular idea with text or a graphics. This means you can choose whether to use text or graphics depending on the audience or medium and implement that choice without changing your content.</db:para>
<db:para>However, when factoring out graphics, you still need to supply the metadata needed to render those graphics. One way to handle this is to create a metadata file for each image that provides the data for multiple renderings of the image and a path to each of the renderings.</db:para>
<db:para>The simplest way to implement this is to use an include instruction that points to the metadata file instead of the image file. This is what I did in writing this book. The strategy uses the DocBook technique shown in <db:xref linkend="ex.docbook-conditional-image"/>, which conditionally includes two different versions of a graphic, one for epub and one for print. But this book is not written in <annotation type="markup-language"><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook</annotation>, it is written in <annotation type="markup-language">SAM</annotation>. In the SAM source file, the image insertion looks like this:</db:para>
<db:programlisting language="sam">
&gt;&gt;&gt;(image ../graphics/assemble.xml)
</db:programlisting>
<db:para>This is not the full factoring out of the graphics as described in the previous example, because the inclusion still refers to an image, and I haven’t factored out the inclusion code. However, the file being included is not a graphics file; it is an XML file (see <db:xref linkend="fig.sam.inclusion"/>).</db:para>
<db:para>The XML file in <db:xref linkend="fig.sam.inclusion"/> describes the idea of the image, listing not only its source file and both of its renderings, but even a text description for use when the graphic cannot be displayed. By including this file instead of an image file, I was able to include the idea of the graphic in my content. When the content is processed, the <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>presentation algorithm</db:secondary></db:indexterm>presentation algorithm loads and reads the <db:code>assemble.xml</db:code> file and uses the information in it to generate the conditionalized <annotation type="markup-language"><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook</annotation> file that becomes the source file for the <db:indexterm><db:primary>formatting algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>formatting algorithm</db:secondary></db:indexterm>formatting algorithm, which is implemented by the publisher’s existing DocBook tool chain.</db:para>
<db:figure xml:id="fig.sam.inclusion"><db:title>Graphics inclusion example</db:title><db:programlisting language="xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;image&gt;
    &lt;source&gt;assemble.svg&lt;/source&gt;
    &lt;fo&gt;
        &lt;href&gt;assemble.svg&lt;/href&gt;
        &lt;contentwidth&gt;4in&lt;/contentwidth&gt;
        &lt;align&gt;left&lt;/align&gt;
    &lt;/fo&gt;
    &lt;epub&gt;
        &lt;href&gt;assemble.png&lt;/href&gt;
    &lt;/epub&gt;
    &lt;alt&gt;
        &lt;p&gt;A diagram showing multiple pieces being 
        combined in different ways to produce different 
        outputs.&lt;/p&gt;
    &lt;/alt&gt;
&lt;/image&gt;
</db:programlisting></db:figure>
<db:para>Could I have factored out the filename <db:code>assemble.xml</db:code> as well? Certainly. There are a number of other ways that I could have chosen to represent the idea of the graphic in the content. There are times when it makes a lot of sense to do that. If you are including screen shots in a procedure, for instance, the name of a dialog box is a good way of representing the idea of a graphic that is semantically relevant to the procedure itself.</db:para>
<db:para>But in the case of the images in this book, their relationship to the text is a little more arbitrary than the relationship of a screen shot to a step in a procedure, so factoring out the filename would have created an abstraction that was actually more difficult to remember as an author. The point is not to be as abstract as possible, but to combine the highest degree of <db:indexterm><db:primary>functional lucidity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functional lucidity</db:secondary></db:indexterm>functional lucidity with the constraints that improve content quality, and that will be different for different kinds of material and for different circumstances.</db:para>
<db:section><db:title>Inline graphics</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp1477729892"><db:primary>inline graphics</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1477729892x"><db:primary>term</db:primary><db:secondary>inline graphics</db:secondary></db:indexterm>



<db:para>One further wrinkle with graphics is that writers sometimes need to place small graphics in the flow of a sentence, rather that as a separate block object. For instance, when describing instructions that involve a keypad or keyboard, some writers use graphics of the keys rather than simply printing the character names. Under certain circumstances, this can make the content easier for a reader to follow.</db:para>
<db:para>Inline graphics can cause <db:indexterm><db:primary>rendering problems</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>rendering problems</db:secondary></db:indexterm>rendering problems. For instance, they may cause line spacing to be thrown off if the height of the graphics is greater than that of the font used. Writers can control and make judgments about inline graphics when writing in the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain, but using them may lead to unexpected and unwelcome consequences in document- or subject-domain content.</db:para>
<db:para>There are two techniques you can use to minimize problems with inline graphics. The first is to avoid them altogether, wherever practical. If you can present the same material just as effectively in some other way, choose that option.</db:para>
<db:para>The other technique is to factor out the graphic by using a structure to record its semantics. For instance, instead of including an <db:emphasis role="bold">Enter</db:emphasis> key graphic like this:</db:para>
<db:programlisting language="sam">
3. Press &gt;(image enter_key.png) to confirm the selection. 
</db:programlisting>
<db:para>Do this:</db:para>
<db:programlisting language="sam">
3. Press {Enter}(key) to confirm the selection. 
</db:programlisting>
<db:para>This leaves open the choice of how to represent the key in the output and allows for <db:indexterm><db:primary>differential single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>differential single sourcing</db:secondary></db:indexterm>differential single sourcing. For example, on a display that did not support graphics, or where graphics would be too fussy, the <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>presentation algorithm</db:secondary></db:indexterm>presentation algorithm could render this as:</db:para>
<db:blockquote>
<db:para>3. Press [Enter] to confirm the selection.</db:para>
</db:blockquote>
<db:para>But for media where the use of a graphic is appropriate, the presentation routine could use a lookup table of key names and graphics to select the graphic file to represent the <db:emphasis role="bold">Enter</db:emphasis> key.</db:para>
<db:blockquote>
<db:para>3. Press <db:inlinemediaobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/computer_key_Enter-epub.png" contentwidth=".4in" align="left"/></db:imageobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/computer_key_Enter.png" contentwidth=".4in" align="left"/></db:imageobject><db:textobject><db:para>A computer keyboard Enter key.</db:para></db:textobject></db:inlinemediaobject> to confirm the selection.</db:para>
</db:blockquote>
<db:para>This approach allows the document designer to select graphics that work best on different displays or at different scales. This partitions the graphic maintenance problem to the most qualified person. And authors don’t have to stop to think about which graphic to use.</db:para>
<db:para>The same approach could be used in another common case, which is describing tool bar icons in a GUI application.</db:para>
<db:programlisting language="sam">
4. Press {Save}(button) to save your changes.
</db:programlisting>
<db:para>This has the same advantages, with the additional benefit that if the interface designer decides to change an icon or to redefine the whole set of icons, you only have to update the lookup table used by the <db:indexterm><db:primary>presentation</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>presentation</db:secondary></db:indexterm>presentation algorithm. This could also be used to substitute different icons for different platforms if your application is run on more than one operating system. This is much more efficient than using conditional text to import different graphics for different configurations.</db:para>
<db:para>This is a good example of using the idea of the graphic rather than the graphic. The idea of the graphic is to represent the <db:emphasis role="bold">Enter</db:emphasis> key or <db:emphasis role="bold">Save</db:emphasis> button. You can do this in a number of ways, including using a photograph of the key, using a special font that creates the look of a key, representing the key using text such as <db:code>[Enter]</db:code>. The idea of a graphic is to represent a subject. So while you can insert the idea of a graphic in the form of a key or a reference to a file that records the idea of the graphic and its implementations, you can also simply identify the subject itself.</db:para>
<db:para>As always, a common principle is at work here: it’s better to capture the subject than a resource that represents the subject. Resources change more often than subjects, and you may want different resources to represent a subject under different circumstance. But as long as the content remains current with it subject matter, the identification of the subject will not change.</db:para>
<db:indexterm class="endofrange" startref="idp1477729892"/><db:indexterm class="endofrange" startref="idp1477729892x"/><db:indexterm class="endofrange" startref="idp1472212244"/><db:indexterm class="endofrange" startref="idp1472218644"/><db:indexterm class="endofrange" startref="idp1472220052"/><db:indexterm class="endofrange" startref="idp1472223252"/><db:indexterm class="endofrange" startref="idp1472212244x"/><db:indexterm class="endofrange" startref="idp1472218644x"/><db:indexterm class="endofrange" startref="idp1472220052x"/><db:indexterm class="endofrange" startref="idp1472223252x"/></db:section>
</db:section>
</db:chapter>
