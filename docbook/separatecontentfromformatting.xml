<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.separating"><db:title>Separating Content from Formatting</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp1659455460"><db:primary>separating content from formatting</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1659455460x"><db:primary>concept</db:primary><db:secondary>separating content from formatting</db:secondary></db:indexterm>



<db:para>If there is one phrase that most people associate with structured writing, it is “separating content from formatting.” This is the most basic and well-known method that we use to partition and redirect complexity, and it illustrates the method we use to do all the rest. Separating content from formatting separates decisions about the appearance of a document from decisions about its content. However, as we will see in this chapter, this is not as simple as it may seem.</db:para>
<db:section>
<db:title>Separate out style instructions</db:title>
<db:para>Let’s start with a fragment that includes a description of its format. I use CSS syntax to describe the format. I could use a variety of formats, but CSS is easy to understand and helps illustrate the separation. I also represent certain characters (bullets and tabs) by their names, so you can see exactly where everything is going:</db:para>
<db:programlisting>
{font: 10pt "Open Sans"}The box contains:
{font: 10pt "Open Sans"}[bullet][tab]Sand
{font: 10pt "Open Sans"}[bullet][tab]Eggs
{font: 10pt "Open Sans"}[bullet][tab]Gold
</db:programlisting>
<db:para>This file contains content and formatting, so let’s separate the two. Of course, when you remove the formatting, you need to add something in its place so you can add the formatting back later. The simplest method is to replace it with a named style:</db:para>
<db:programlisting>
{style: paragraph}The box contains:
{style: paragraph}[bullet][tab]Sand
{style: paragraph}[bullet][tab]Eggs
{style: paragraph}[bullet][tab]Gold
</db:programlisting>
<db:para>Then, you need to record the style; it isn’t being removed, just separated from the text:</db:para>
<db:programlisting>
paragraph = {font: 10pt "Open Sans"}
</db:programlisting>
<db:para>Once the style information is separated, you can change the formatting without changing the text; for example, you could choose a different font:</db:para>
<db:programlisting>
paragraph = {font: 12pt "Century Schoolbook"}
</db:programlisting>
</db:section>
<db:section>
<db:title>Separate out formatting characters</db:title>
<db:para>Cool, but suppose you need to change the style of the bullets. The bullet style is certainly formatting, but bullets are text characters. To change them you can’t just change the font, you have to change the characters themselves.</db:para>
<db:para>Some characters in your text are part of the content, and some are part of the formatting. Therefore, a style may include characters as well as formatting directives, as shown here:</db:para>
<db:programlisting>
paragraph = {font: 12pt "Century Schoolbook"}
bullet-paragraph = {font: 12pt "Century Schoolbook"}[bullet]
</db:programlisting>
<db:para>Now the content looks like this:</db:para>
<db:programlisting>
{style: paragraph}The box contains:
{style: bullet-paragraph}[tab]Sand
{style: bullet-paragraph}[tab]Eggs
{style: bullet-paragraph}[tab]Gold
</db:programlisting>
<db:para>However, you still must begin the bulleted lines with a tab, which is awkward and error prone, so let’s move that character to the style as well:</db:para>
<db:programlisting>
paragraph = {font: 12pt "Century Schoolbook"}
bullet-paragraph = {font: 12pt "Century Schoolbook"}[bullet][tab]
</db:programlisting>
<db:para>Now the content looks like this:</db:para>
<db:programlisting>
{style: paragraph}The box contains:
{style: bullet-paragraph}Sand
{style: bullet-paragraph}Eggs
{style: bullet-paragraph}Gold
</db:programlisting>
<db:para>And now you can change the bullet style:</db:para>
<db:programlisting>
bullet-paragraph = {font: 12pt "Century Schoolbook"}[em dash][tab]
</db:programlisting>
<db:para>Because the style now uses an em-dash, rather than a bullet, the name bullet-paragraph may not be the best choice. The content still contains a style named for a particular piece of formatting, which means writers are still making the formatting choice “bullet” when it would be better for them to focus on the content choice “list.”</db:para>
</db:section>
<db:section>
<db:title>Name your abstractions correctly</db:title>
<db:para>The names you choose for styles and other abstractions matter. The wrong name sets up a false expectation, which can lead to authors using a style incorrectly. So the first lesson about separating content from formatting is that naming matters. You are creating an abstraction, so you need to figure out what that abstraction is and name it appropriately.</db:para>
<db:para>What is the abstraction here? Sand, Eggs, and Gold are list items. So maybe we do this:</db:para>
<db:programlisting>
{style: paragraph}The box contains:
{style: list-item}Sand
{style: list-item}Eggs
{style: list-item}Gold
</db:programlisting>
<db:para>and</db:para>
<db:programlisting>
list-item = {font: 12pt "Century Schoolbook"}[em dash][tab]
</db:programlisting>
</db:section>
<db:section>
<db:title>Make sure you have the right set of abstractions</db:title>
<db:para>But then, of course, you run into lists like the following:</db:para>
<db:programlisting>
{style: paragraph}To wash hair:
{style: list-item}Lather
{style: list-item}Rinse
{style: list-item}Repeat
</db:programlisting>
<db:para>These list items should have numbers, not dashes or bullets. So the abstraction does not cover all list items. If you look at the different kinds of list items, group them into abstract types, and come up with names for those types, you probably come up with <db:code>ordered-list-item</db:code> and <db:code>unordered-list-item</db:code>. Then you have:</db:para>
<db:programlisting>
{style: paragraph}The box contains:
{style: unordered-list-item}Sand
{style: unordered-list-item}Eggs
{style: unordered-list-item}Gold
</db:programlisting>
<db:para>and</db:para>
<db:programlisting>
{style: paragraph}To wash hair:
{style: ordered-list-item}Lather
{style: ordered-list-item}Rinse
{style: ordered-list-item}Repeat
</db:programlisting>
<db:para>The style for ordered-list-items now looks something like this:</db:para>
<db:programlisting>
ordered-list-item = {font: 12pt "Century Schoolbook"}&lt;count&gt;.[tab]
</db:programlisting>
<db:para>But you need a way to increment the count and reset it to 1 for a new list, which leads to:</db:para>
<db:programlisting>
{style: paragraph}To wash hair:
{style: first-ordered-list-item}Lather
{style: ordered-list-item}Rinse
{style: ordered-list-item}Repeat
</db:programlisting>
<db:para>and</db:para>
<db:programlisting>
first-ordered-list-item = 
    {font: 12pt "Century Schoolbook"}&lt;count=1&gt;.[tab]
ordered-list-item = 
    {font: 12pt "Century Schoolbook"}&lt;++count&gt;.[tab]
</db:programlisting>
<db:para>(<db:code>++count</db:code> here means add one to <db:code>count</db:code> and then display it.)</db:para>
<db:para>This is pretty much how <db:indexterm><db:primary>FrameMaker</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>FrameMaker</db:secondary></db:indexterm>FrameMaker, <db:indexterm><db:primary>Microsoft Word</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>Microsoft Word</db:secondary></db:indexterm>Microsoft Word, and many other tools handle lists. The reason for going through this example in such detail is to point out how much is involved in even this simple bit of partitioning. We began by removing formatting commands, followed by characters, which forced us to include characters in our style definitions. And then we had to calculate the value of characters. At each step, we created abstractions and had to consider all the cases we might run into and create abstractions to handle them.</db:para>
</db:section>
<db:section>
<db:title>Create containers to provide context</db:title>
<db:para>As noted in <db:xref linkend="chapter.document-domain"/>, one problem with this approach to creating lists is that you have to apply a different style to the first item of a list. It would be better if you could use the same style for each list item and have the numbering just work. However, this is hard to do because nothing in the content says where one numbered list ends and the next begins. For this we need a new abstraction. So far, we have abstractions for ordered and unordered list items, but we don’t have an abstraction for lists themselves.</db:para>
<db:para>Up to this point, we have been separating content from formatting purely in the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain. We replaced direct formatting definitions with indirect definitions through styles. But now we start to venture into the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, creating the abstract idea of a list and inserting that abstract idea into our content.</db:para>
<db:programlisting>
paragraph: To wash hair:
list:
    ordered-list-item:Lather
    ordered-list-item:Rinse
    ordered-list-item:Repeat
</db:programlisting>
<db:para>There are a number of significant changes here. First, the structure is no longer flat. We have introduced a container. A list is a container for list items. Previously it was a series of paragraphs with different styles attached. Now we have a container, which, as far as the formatting is concerned, never existed in the original. The writer and reader knew that the sequence of bulleted paragraphs formed a list, but that was an interpretation of the formatting. Now we have taken that interpretation and recorded it explicitly in the content itself.</db:para>
<db:para>By creating the idea of a list, we further separate list formatting from the list content – now an algorithm can recognize a list and can make formatting decisions based on that knowledge.</db:para>
<db:para>The second important thing is that the content no longer refers to style names. Instead we have structures. <db:code>list</db:code> is a structure and so are <db:code>paragraph</db:code> and <db:code>ordered-list-item</db:code>.</db:para>
<db:para>By replacing styles with structures, you can give the same structure a different style depending on where it is in the document. The <db:indexterm><db:primary>formatting algorithm</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>formatting algorithm</db:secondary></db:indexterm>formatting algorithm determines if an ordered-list-item is the first one inside a list and formats it accordingly. (Which is how list formatting works in CSS.<db:footnote><db:para>https://css-tricks.com/numbering-in-style/</db:para></db:footnote>)</db:para>
<db:para>Now authors no longer apply styles to content, even styles with abstract names. Rather they place content in structures and allow the formatting algorithm to apply styles appropriately. This separates the content even more from the formatting.</db:para>
</db:section>
<db:section>
<db:title>Move the abstractions to the containers</db:title>
<db:para>But there is a problem here. What if an author inadvertently does this:</db:para>
<db:programlisting>
paragraph: To wash hair:
list:
    ordered-list-item:Lather
    unordered-list-item:Rinse
    ordered-list-item:Repeat
</db:programlisting>
<db:para>To avoid this, move the abstraction outward. Instead of ordered and unordered list items, you create ordered and unordered lists:</db:para>
<db:programlisting>
paragraph: To wash hair:
ordered-list:
    list-item:Lather
    list-item:Rinse
    list-item:Repeat
</db:programlisting>
<db:para>and</db:para>
<db:programlisting>
paragraph: The box contains:
unordered-list:
    list-item:Sand
    list-item:Eggs
    list-item:Gold
</db:programlisting>
<db:para>Now, you have a single <db:code>list-item</db:code> structure that you can use in either an unordered list or an ordered list; the <db:indexterm><db:primary>formatting algorithm</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>formatting algorithm</db:secondary></db:indexterm>formatting algorithm determines the formatting based on which type of list the list-item belongs to. The name <db:code>list-item</db:code> describes a role in the document that is entirely separate from formatting.</db:para>
<db:para>Moving the abstraction out to the container is an important part of the algorithm of separating content from formatting. It partitions ordered and unordered lists, making the construction of each simpler and more reliable. This helps keep things consistent and reduces the number of things authors have to remember. (Notice that this requires writers to decide whether a list is ordered or unordered, but they had to decide this anyway; the decision is implicit in the rhetoric of the piece.)</db:para>
<db:para>Some markup languages take better advantage of containers than others. For example, HTML and Markdown both provide six different heading levels. However, content under an <db:code>H2</db:code> or an <db:code>H5</db:code> heading is not in any container. The content simply comes after the heading. This means that is it perfectly possible and legal to use heading elements in any order you want. Writers must select the heading level and ensure that it fits the structure of their document.</db:para>
<db:para>By contrast, <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook has a <db:indexterm><db:primary>section</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>section</db:secondary></db:indexterm>section structure. Like a list, a section records your interpretation of what you are creating in the document. The <db:indexterm><db:primary>section</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>section</db:secondary></db:indexterm>section structure instantiates the concept of a section. And once you have the instantiation of a section, you don’t need six levels of heading. You can have one structure called <db:indexterm><db:primary>title</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>title</db:secondary></db:indexterm>title. Sections can be nested inside other sections, and the formatting algorithm applies the correct style to the title based on context:</db:para>
<db:programlisting>
section: 
    title:
    paragraph:
    section:
        title:
</db:programlisting>
<db:para>This eliminates decisions about which heading element to use; there is just one: <db:code>title</db:code>. This ensures that the headings in the output consistently reflect the section and subsection structure of the document.<db:footnote>
<db:para>Not everyone holds to the view that headings in a text must reflect a hierarchy of sections. Instead, headings may be simply signposts along the way, where the size of the sign reflects some quality – size of the town or the importance of the section – other than a strict hierarchy. If that is how you look at document structures, you should choose a different way to separate content from formatting.</db:para>
</db:footnote></db:para>

</db:section>
<db:section>
<db:title>Separate out abstract formatting</db:title>
<db:para>I noted that in the case of ordered and unordered lists, separating content from formatting actually involves separating out some of the content as well. Or rather, it involves separating out some of the characters. In other words, the distinction between content and formatting is not the same as the distinction between characters and the styles applied to them. Sometimes characters are part of the formatting rather than the content.</db:para>
<db:para>Consider a labeled-list structure:</db:para>
<db:blockquote>
<db:variablelist>
<db:varlistentry>
<db:term>Street</db:term>
<db:listitem><db:para>123 Elm Street</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Town</db:term>
<db:listitem><db:para>Smallville</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Country</db:term>
<db:listitem><db:para>USA</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Code</db:term>
<db:listitem><db:para>12345</db:para></db:listitem>
</db:varlistentry>
</db:variablelist>
</db:blockquote>
<db:para>The generic structure of a labeled list might look like this:</db:para>
<db:programlisting language="sam">
labeled-list:
    list-item:
        label: Street
        content: 123 Elm Street
    list-item:
        label: Town
        contents: Smallville
    list-item:
        label: Country
        contents: 123 USA
    list-item:
        label: Code
        contents: 12345
</db:programlisting>
<db:para>But what if you have hundreds of addresses, all with the same labels? Are the labels content or are they presentation? Since the labels don’t change from one list to another, you could look at them as being part of the presentation rather than the content. So let’s look for a way to separate them from the content.</db:para>
<db:para>As always, when you separate something from your content, you have to replace it with something else. In this case, we use named structures that reflect the subject matter of the entries, which moves this content into the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain (see <db:xref linkend="ex.separate-1"/>):</db:para>
<db:figure xml:id="ex.separate-1"><db:title>Address markup in the subject domain</db:title><db:programlisting language="sam">
address:
    street: 123 Elm Street
    town: Smallville
    country: USA
    code: 12345
</db:programlisting></db:figure>
<db:para>Here, once again, it is important to distinguish formatting and presentation. As discussed in <db:xref linkend="chapter.document-domain"/>, <db:emphasis>formatting</db:emphasis> refers to the precise details of a text’s appearance: the font chosen, the width of the text column, the size of the characters, the spacing between line, the size and shape of the bullet characters. <db:emphasis>Presentation</db:emphasis> refers to the organization of text. Deciding to use a list for a certain piece of information is a presentation decision, which is independent of the formatting details applied to lists. When you move content from the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain to the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, you separate the formatting of the content from its presentation. The decision to present the information as a list remains; the decision about what that list will look like has been separated out.</db:para>
<db:para>In contrast, moving content from the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain to the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain separates the <db:emphasis>information</db:emphasis> from the <db:emphasis>presentation</db:emphasis>. The subject-domain structure in <db:xref linkend="ex.separate-1"/> is not a labeled list. It is a data record that could be turned into many different forms of presentation.</db:para>
<db:para>The job of turning such structures into a specific form of presentation is the job of the presentation algorithm (see <db:xref linkend="chapter.publishing"/>). The presentation algorithm could turn it into a labeled list, a table, a paragraph, or an address label.</db:para>
<db:para>In the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, with the content separated from both formatting and presentation, you also gain the ability to query and reorganize the content in various interesting and useful ways (which I will explore in later chapters).</db:para>
<db:para>This is as far as you can go in separating content from formatting, and you can’t separate all content from formatting to quite this extent. Separating content from format is not a binary operation. There are various degrees of separation that you can apply for various reasons. It is important to understand exactly which degree of separation best serves your needs.</db:para>
<db:indexterm class="endofrange" startref="idp1659455460"/><db:indexterm class="endofrange" startref="idp1659455460x"/></db:section>
</db:chapter>
