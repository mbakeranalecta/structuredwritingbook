<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.separating"><db:title>Separating Content from Formatting</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idm1931927836"><db:primary>separating content from formatting</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm1931927836x"><db:primary>concept</db:primary><db:secondary>separating content from formatting</db:secondary></db:indexterm>



<db:para>If there is one phrase that most people associate with structured writing, it is “separating content from formatting.” This is the most basic and well-known structured writing algorithm and it can be used to achieve a number of process and rhetorical goals. It is a useful place to start the study of algorithms because it illustrates the strategies used for all the other algorithms. Separating content from formatting separates decisions about the appearance of a document from decisions about its content. However, as you will see in this chapter, doing this is not as simple as it may seem.</db:para>
<db:section>
<db:title>Separate out style instructions</db:title>
<db:para>Let’s start with a piece of text that includes a description of its format. I use CSS syntax to describe the format because but CSS is easy to understand and helps illustrate the separation, but don’t focus on the syntax, it is just there to illustrate the principle. I also represent certain characters (bullets and tabs) by their names, so you can see exactly where everything is going:</db:para>
<db:programlisting>

{font: 10pt "Open Sans"}The box contains:
{font: 10pt "Open Sans"}[bullet][tab]Sand
{font: 10pt "Open Sans"}[bullet][tab]Eggs
{font: 10pt "Open Sans"}[bullet][tab]Gold
</db:programlisting>
<db:para>This file contains content and formatting, so let’s separate the two. Of course, when you remove the formatting, you need to add something in its place so you can add the formatting back later. The simplest method is to replace the formatting with a named style:</db:para>
<db:programlisting>

{style: paragraph}The box contains:
{style: paragraph}[bullet][tab]Sand
{style: paragraph}[bullet][tab]Eggs
{style: paragraph}[bullet][tab]Gold
</db:programlisting>
<db:para>Then, you need to record the style information. You aren’t removing that information; you’re just separating it from the text:</db:para>
<db:programlisting>

paragraph = {font: 10pt "Open Sans"}
</db:programlisting>
<db:para>Once you separate the style information, you can change the formatting without changing the text; for example, you could choose a different font:</db:para>
<db:programlisting>

paragraph = {font: 12pt "Century Schoolbook"}
</db:programlisting>
</db:section>
<db:section>
<db:title>Separate out formatting characters</db:title>
<db:para>Cool, but suppose you need to change the style of the bullets. The bullet style is certainly formatting, but bullets are text characters. To change them you can’t just change the font, you have to change the characters themselves.</db:para>
<db:para>Some characters in your text are part of the content, and some are part of the formatting. Therefore, a style may include characters as well as formatting directives, as shown here:</db:para>
<db:programlisting>

paragraph = {font: 12pt "Century Schoolbook"}
bullet-paragraph = {font: 12pt "Century Schoolbook"}[bullet]
</db:programlisting>
<db:para>Now the content looks like this:</db:para>
<db:programlisting>

{style: paragraph}The box contains:
{style: bullet-paragraph}[tab]Sand
{style: bullet-paragraph}[tab]Eggs
{style: bullet-paragraph}[tab]Gold
</db:programlisting>
<db:para>However, you still must begin the bulleted lines with a tab, which is awkward and error prone, so let’s move that character to the style as well:</db:para>
<db:programlisting>

paragraph = {font: 12pt "Century Schoolbook"}
bullet-paragraph = {font: 12pt "Century Schoolbook"}[bullet][tab]
</db:programlisting>
<db:para>Now the content looks like this:</db:para>
<db:programlisting>

{style: paragraph}The box contains:
{style: bullet-paragraph}Sand
{style: bullet-paragraph}Eggs
{style: bullet-paragraph}Gold
</db:programlisting>
<db:para>And now you can change the bullet style:</db:para>
<db:programlisting>

bullet-paragraph = {font: 12pt "Century Schoolbook"}[em dash][tab]
</db:programlisting>
<db:para>Because the style now uses an em-dash, rather than a bullet, the name bullet-paragraph may not be the best choice. The content still contains a style named for a particular piece of formatting, which means writers are still making the formatting choice “bullet” when it would be better for them to focus on the content choice “list.”</db:para>
</db:section>
<db:section>
<db:title>Name your abstractions correctly</db:title>
<db:para>The names you choose for styles and other abstractions matter. The wrong name sets up a false expectation, which can lead to writers using a style incorrectly. So the first lesson about separating content from formatting is that naming matters. You are creating an abstraction, so you need to figure out what that abstraction is and name it appropriately.</db:para>
<db:para>What is the abstraction here? Sand, Eggs, and Gold are list items. So maybe you do this:</db:para>
<db:programlisting>

{style: paragraph}The box contains:
{style: list-item}Sand
{style: list-item}Eggs
{style: list-item}Gold
</db:programlisting>
<db:para>and</db:para>
<db:programlisting>

list-item = {font: 12pt "Century Schoolbook"}[em dash][tab]
</db:programlisting>
</db:section>
<db:section>
<db:title>Make sure you have the right set of abstractions</db:title>
<db:para>But then, of course, you run into lists like the following:</db:para>
<db:programlisting>

{style: paragraph}To wash hair:
{style: list-item}Lather
{style: list-item}Rinse
{style: list-item}Repeat
</db:programlisting>
<db:para>These list items should have numbers, not dashes or bullets. So the abstraction does not cover all list items. If you look at the different kinds of list items, group them into abstract types, and come up with names for those types, you probably come up with <db:code>ordered-list-item</db:code> and <db:code>unordered-list-item</db:code>. Then you have:</db:para>
<db:programlisting>

{style: paragraph}The box contains:
{style: unordered-list-item}Sand
{style: unordered-list-item}Eggs
{style: unordered-list-item}Gold
</db:programlisting>
<db:para>and</db:para>
<db:programlisting>

{style: paragraph}To wash hair:
{style: ordered-list-item}Lather
{style: ordered-list-item}Rinse
{style: ordered-list-item}Repeat
</db:programlisting>
<db:para>The style for ordered-list-items now looks something like this:</db:para>
<db:programlisting>

ordered-list-item = {font: 12pt "Century Schoolbook"}&lt;count&gt;.[tab]
</db:programlisting>
<db:para>But you need a way to increment the count and reset it to 1 for a new list, which leads to:</db:para>
<db:programlisting>

{style: paragraph}To wash hair:
{style: first-ordered-list-item}Lather
{style: ordered-list-item}Rinse
{style: ordered-list-item}Repeat
</db:programlisting>
<db:para>and</db:para>
<db:programlisting>

first-ordered-list-item = 
    {font: 12pt "Century Schoolbook"}&lt;count=1&gt;.[tab]
ordered-list-item = 
    {font: 12pt "Century Schoolbook"}&lt;++count&gt;.[tab]
</db:programlisting>
<db:para>(<db:code>++count</db:code> here means add one to <db:code>count</db:code> and then display it.)</db:para>
<db:para>This is pretty much how <db:indexterm><db:primary>FrameMaker</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>FrameMaker</db:secondary></db:indexterm>FrameMaker, <db:indexterm><db:primary>Microsoft Word</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>Microsoft Word</db:secondary></db:indexterm>Microsoft Word, and many other tools handle lists. The reason for going through this example in such detail is to point out how much is involved in even this simple bit of partitioning. You began by removing formatting commands, followed by characters, which forced you to include characters in the style definitions. And then you had to calculate the value of characters. At each step, you had to consider all possible cases and create abstractions to handle them.</db:para>
</db:section>
<db:section>
<db:title>Create containers to provide context</db:title>
<db:para>One problem with this approach to creating lists is that you have to apply a different style to the first item of a list. It would be better if you could use the same style for each list item and have the numbering just work. However, this is hard to do because nothing in the content says where one numbered list ends and the next begins. For this you need a new abstraction. So far, you have abstractions for ordered and unordered list items, but you don’t have an abstraction for lists themselves.</db:para>
<db:para>Up to this point, everything has been purely in the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain. You replaced direct formatting definitions with indirect definitions through styles. But now it’s necessary to venture into the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, creating the abstract idea of a list and inserting that abstract idea into your content.</db:para>
<db:programlisting>

paragraph: To wash hair:
list:
    ordered-list-item:Lather
    ordered-list-item:Rinse
    ordered-list-item:Repeat
</db:programlisting>
<db:para>There are two significant changes here. First, the structure is no longer flat. Previously a list was a series of paragraphs with different styles attached. Now there is a container, <db:code>list</db:code>, that, as far as the formatting is concerned, never existed in the original.<db:footnote>
<db:para>The SAM markup in this example uses indentation to identify hierarchy. The <db:code>list</db:code> container contains three instances of <db:code>ordered-list-item</db:code>.</db:para>
</db:footnote> The writer and reader knew that the sequence of bulleted paragraphs formed a list, but that was an interpretation of the formatting. Now that interpretation is recorded explicitly in the content itself.</db:para>

<db:para>By creating the idea of a list, you further separate list formatting from the list content. Now, an algorithm can recognize a list and make formatting decisions based on that knowledge.</db:para>
<db:para>The second important thing is that the content no longer refers to style names. Instead you have structures. <db:code>list</db:code> is a structure and so are <db:code>paragraph</db:code> and <db:code>ordered-list-item</db:code>. You can give the same structure a different style depending on where it is in the document. The <db:indexterm><db:primary>formatting algorithm</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>formatting algorithm</db:secondary></db:indexterm>formatting algorithm can determine which <db:code>ordered-list-item</db:code> is first and format it accordingly; this is how list formatting works in CSS.<db:footnote><db:para>https://css-tricks.com/numbering-in-style/</db:para></db:footnote></db:para>
<db:para>Now, writers no longer apply styles directly to content, even styles with abstract names. Rather they place content in structures and allow the formatting algorithm to apply styles appropriately. This separates the content even more from the formatting.</db:para>
</db:section>
<db:section>
<db:title>Move the abstractions to the containers</db:title>
<db:para>But what if a writer inadvertently does this:</db:para>
<db:programlisting>

paragraph: To wash hair:
list:
    ordered-list-item:Lather
    unordered-list-item:Rinse
    ordered-list-item:Repeat
</db:programlisting>
<db:para>To avoid this type of error, move the abstraction outward. Instead of creating ordered and unordered list items, create ordered and unordered lists:</db:para>
<db:programlisting>

paragraph: To wash hair:
ordered-list:
    list-item:Lather
    list-item:Rinse
    list-item:Repeat
</db:programlisting>
<db:para>and</db:para>
<db:programlisting>

paragraph: The box contains:
unordered-list:
    list-item:Sand
    list-item:Eggs
    list-item:Gold
</db:programlisting>
<db:para>Now, you have a single <db:code>list-item</db:code> structure that you can use in either an unordered list or an ordered list; the <db:indexterm><db:primary>formatting algorithm</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>formatting algorithm</db:secondary></db:indexterm>formatting algorithm determines the formatting based on which type of list the list-item belongs to. The name <db:code>list-item</db:code> describes a role in the document that is entirely separate from formatting.</db:para>
<db:para>Moving the abstraction out to the container is an important part of the algorithm for separating content from formatting. It partitions ordered and unordered lists, making the construction of each simpler and more reliable. This helps keep things consistent and reduces the number of things writers have to remember. (Notice that this requires writers to decide whether a list is ordered or unordered, but they had to decide this anyway; the decision is implicit in the rhetoric of the piece.)</db:para>
<db:para>Some markup languages take better advantage of containers than others. For example, HTML and Markdown both provide six different heading levels. However, content under an <db:code>H2</db:code> or an <db:code>H5</db:code> heading is not in any container. The content simply comes after the heading. This means that is it perfectly possible and legal to use heading elements in any order you want. Writers must select the heading level and ensure that it fits the structure of their document.</db:para>
<db:para>By contrast, <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook has a <db:indexterm><db:primary>section</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>section</db:secondary></db:indexterm><db:code>section</db:code> structure. Like a list, a section records your interpretation of what you are creating in the document. The <db:indexterm><db:primary>section</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>section</db:secondary></db:indexterm><db:code>section</db:code> structure instantiates the concept of a section. And once you have the instantiation of a section, you don’t need six levels of heading. You can have one structure called <db:indexterm><db:primary>title</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>title</db:secondary></db:indexterm><db:code>title</db:code>. Sections can be nested inside other sections, and the formatting algorithm applies the correct style to the title based on context:</db:para>
<db:programlisting>

section: 
    title:
    paragraph:
    section:
        title:
</db:programlisting>
<db:para>This eliminates decisions about which heading element to use; there is just one: <db:code>title</db:code>. This ensures that the headings in the output consistently reflect the section and subsection structure of the document.<db:footnote>
<db:para>Not everyone holds to the view that headings in a text must reflect a hierarchy of sections. Instead, headings may be simply signposts along the way, where the size of the sign reflects some quality – size of the town or the importance of the section – other than a strict hierarchy. If that is how you look at document structures, you should choose a different way to separate content from formatting.</db:para>
</db:footnote></db:para>

</db:section>
<db:section>
<db:title>Separate out abstract formatting</db:title>
<db:para>To separate content from formatting for ordered and unordered lists, you must separate out some of the content as well. Specifically, you must separate out some of the characters. The distinction between content and formatting is not the same as the distinction between characters and the styles applied to them. Sometimes characters are part of the formatting rather than the content.</db:para>
<db:para>Consider a labeled-list structure:</db:para>
<db:blockquote>
<db:variablelist>
<db:varlistentry>
<db:term>Street</db:term>
<db:listitem><db:para>123 Elm Street</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Town</db:term>
<db:listitem><db:para>Smallville</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Country</db:term>
<db:listitem><db:para>USA</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Code</db:term>
<db:listitem><db:para>12345</db:para></db:listitem>
</db:varlistentry>
</db:variablelist>
</db:blockquote>
<db:para>The generic structure of a labeled list might look like this:</db:para>
<db:programlisting language="sam">

labeled-list:
    list-item:
        label: Street
        content: 123 Elm Street
    list-item:
        label: Town
        contents: Smallville
    list-item:
        label: Country
        contents: 123 USA
    list-item:
        label: Code
        contents: 12345
</db:programlisting>
<db:para>But what if you have hundreds of addresses, all with the same labels? Are the labels content or are they presentation? Since the labels don’t change from one list to another, you could look at them as being part of the presentation rather than the content. So let’s look for a way to separate them from the content.</db:para>
<db:para>As always, when you separate something from your content, you have to replace it with something else. In <db:xref linkend="ex.separate-1"/>, named structures reflect the subject matter of the entries, which moves this content into the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain.</db:para>
<db:figure xml:id="ex.separate-1"><db:title>Address markup in the subject domain</db:title><db:programlisting language="sam">

address:
    street: 123 Elm Street
    town: Smallville
    country: USA
    code: 12345
</db:programlisting></db:figure>
<db:para>Here, once again, it is important to distinguish formatting and presentation. <db:emphasis>Formatting</db:emphasis> refers to the precise details of a text’s appearance: the font chosen, the width of the text column, the size of the characters, the spacing between line, the size and shape of the bullet characters, and so forth. <db:emphasis>Presentation</db:emphasis> refers to the organization of text.</db:para>
<db:para>Deciding to use a list for a certain piece of information is a presentation decision, which is independent of the formatting details applied to lists. When you move content from the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain to the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, you separate the formatting of the content from its presentation. The decision to present the information as a list remains; the decision about what that list looks like is separated out.</db:para>
<db:para>In contrast, moving content from the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain to the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain separates the <db:emphasis>information</db:emphasis> from the <db:emphasis>presentation</db:emphasis>. The subject-domain structure in <db:xref linkend="ex.separate-1"/> is not a labeled list. It is a data record that can be turned into many different forms of presentation.</db:para>
<db:para>Turning such structures into a specific form of presentation is the job of the presentation algorithm (see <db:xref linkend="chapter.publishing"/>). The presentation algorithm could turn it into a labeled list, a table, a paragraph, or an address label.</db:para>
<db:para>In the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, with the content separated from both formatting and presentation, you also gain the ability to query and reorganize the content in various interesting and useful ways (which I explore in later chapters).</db:para>
<db:para>This is as far as you can go in separating content from formatting, and you can’t separate all content from formatting to quite this extent. Separating content from format is not a binary operation. There are various degrees of separation that you can apply for various reasons. It is important to understand exactly which degree of separation best serves your needs.</db:para>
<db:indexterm class="endofrange" startref="idm1931927836"/><db:indexterm class="endofrange" startref="idm1931927836x"/></db:section>
</db:chapter>
