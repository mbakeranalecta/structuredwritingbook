<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.intro-to-algorithms"><db:title>Introduction to Algorithms</db:title>


<db:para>When you use structured writing to partition the complexity of the content system, you are partitioning much of that complexity to algorithms. Therefore, the study of structured writing is first and foremost the study of algorithms. The chapters in this section explore each of the main structured content algorithms, looking at each algorithm’s function and the interfaces that supply it with information. However, these are not chapters on programming. Defining an algorithm and writing software to implement that algorithm are two separate tasks. This section introduces you to the design and capability of structured writing algorithms, not to the coding of software.</db:para>
<db:para>Most of this part of the book deals with specific algorithms. However, it begins by considering <db:indexterm><db:primary>quality</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>quality</db:secondary></db:indexterm>quality (<db:xref linkend="chapter.quality"/>). The design of algorithms always begins with quality. The purpose of an algorithm is to produce a quality product. However, it is all too easy to lose sight of quality when you are down in the nitty gritty of algorithm design and to end up doing things merely because they are efficient, ignoring their impact on quality.</db:para>
<db:para>Another issue to keep in mind while designing a content process or algorithm is <db:indexterm><db:primary>writing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>writing</db:secondary></db:indexterm>writing (<db:xref linkend="chapter.writing"/>). Writing is at the heart of any content process. An algorithm is not merely a program running on a computer system. An algorithm is an interaction – a conversation – between a human being and a machine. This is why interface design and user experience design are fundamental to system and application design. No algorithm can perform successfully if it is hobbled at the start by a poor interaction with the human. An algorithm that is designed solely for efficiency, at the expense of the user interface, is doomed to be neither efficient nor effective. <db:xref linkend="chapter.writing"/> lays out the basic considerations that must be made for writers in the design of any structured writing algorithm.</db:para>
<db:para>Following the chapters on quality and writing, the rest of this part of the book covers the following:</db:para>
<db:section>
<db:title>The basics</db:title>
<db:para><db:xref linkend="chapter.separating"/> and <db:xref linkend="chapter.processing"/> review the basics of structured writing: how to partition content elements and put them back together again. This includes a look at a classic example of content partitioning: <db:indexterm><db:primary>separating content from formatting</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>separating content from formatting</db:secondary></db:indexterm>separating content from formatting. These chapters discuss the basic techniques that lay the foundation for all the other algorithms, including how to use pseudocode to represent algorithms.</db:para>
</db:section>
<db:section>
<db:title>Single sourcing and reuse</db:title>
<db:para>The next four chapters look at <db:indexterm><db:primary>single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>single sourcing</db:secondary></db:indexterm>single sourcing and content <db:indexterm><db:primary>reuse</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm>reuse. This includes the following topics:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:xref linkend="chapter.single-sourcing"/>: partitioning for single sourcing, including selecting the appropriate domain to get the most effective partitioning, and creating content for different audiences and media</db:para>
</db:listitem>
<db:listitem>
<db:para><db:xref linkend="chapter.reuse"/>: techniques for content <db:indexterm><db:primary>reuse</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm>reuse</db:para>
</db:listitem>
<db:listitem>
<db:para><db:xref linkend="chapter.composition"/>: techniques for creating content that can be assembled like building blocks</db:para>
</db:listitem>
<db:listitem>
<db:para><db:xref linkend="chapter.duplication"/>: strategies for detecting and <db:indexterm><db:primary>avoiding duplication</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>avoiding duplication</db:secondary></db:indexterm>avoiding duplication of content</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>Linking and the connections between subjects</db:title>
<db:para><db:xref linkend="chapter.linking"/> looks at <db:indexterm><db:primary>linking algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>linking algorithm</db:secondary></db:indexterm>linking, which is a larger problem than managing links. Linking is actually about managing the relationship between content and its subject matter. In a single-sourcing environment you may need to handle relationships differently, depending on the media, for example, using links in some media and other mechanisms in others. This requires a step back from thinking about links to thinking about the relationships between subjects and the content that describes them.</db:para>
</db:section>
<db:section>
<db:title>Quality control</db:title>
<db:para>Structured writing plays a huge role in controlling content quality. The next two chapters look at two quality control algorithms that have a big impact on quality and efficiency:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:xref linkend="chapter.conformance"/>: the <annotation type="process">conformance</annotation> algorithm helps ensure that everyone who contributes to your content, including your writers, consistently produces work that meets your quality standards. I look at three fundamental components of conformance: factoring out constraints, enforcing constraints, and enabling and encouraging voluntary conformance.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:xref linkend="chapter.audit"/>: the <db:indexterm><db:primary>auditing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>auditing</db:secondary></db:indexterm>auditing algorithm gives you the ability to determine the current state of your content set, including what content you have, what content you need, and how conformant your content is.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>Finding content</db:title>
<db:para>The ability to find content is essential for writers, content managers, readers, and algorithms. The key to finding things is the relevance algorithm (<db:xref linkend="chapter.relevance"/>). The relevance algorithm helps ensure that content is labeled correctly and that it is relevant to its intended audience.</db:para>
</db:section>
<db:section>
<db:title>Generating content</db:title>
<db:para>Not all content has to be written from scratch. Much commercial content is essentially the narration of company or product data, and algorithms can make the process of narrating that data much faster and more reliable. As a bonus, generated content can also be an enormously useful resource for auditing the rest of your content set.</db:para>
<db:para>There are three algorithms used in generating content:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:xref linkend="chapter.extract"/>: the <db:indexterm><db:primary>extract algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>extract algorithm</db:secondary></db:indexterm>extract algorithm pulls content out of existing data sources and puts it into a format that can be published.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:xref linkend="chapter.merge"/>: the <db:indexterm><db:primary>merge algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>merge algorithm</db:secondary></db:indexterm>merge algorithm combines written and extracted content.</db:para>
</db:listitem>
<db:listitem>
<db:para><db:xref linkend="chapter.modeling"/>: the <db:indexterm><db:primary>modeling algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>modeling algorithm</db:secondary></db:indexterm>modeling algorithm uses structured writing techniques to create a model of a real-world object that can be used as a data source for the extract and merge algorithms.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>Information architecture</db:title>
<db:para><db:indexterm><db:primary>information architecture algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>information architecture algorithm</db:secondary></db:indexterm>Information architecture is the overall arrangement of a content set so that readers can find information. It covers everything from the purpose and scope of individual documents to linking, search, and navigational aids. Maintaining a consistent and effective information architecture, especially on a large and constantly changing site, is dauntingly complex. Structured writing techniques can not only help you define and manage your information architecture, and audit its effectiveness, they can be used to generate and maintain architectural features that would not be possible by individual human effort. Again we will see that the choice of domain is crucial to both quality and efficiency in information architecture.</db:para>
</db:section>
<db:section>
<db:title>Managing content and process</db:title>
<db:para>Content has to be manged, and the management of content introduces lot of complexity into the content process. As we will see in these chapters, the effective management of content cannot be separated from its structure. In fact, its structure is key to its manageability.</db:para>
<db:para>One of the largest sources of complexity in the content system is dealing with <db:indexterm><db:primary>change</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>change</db:secondary></db:indexterm>changes in subject matter and business requirements, a problem that has become much more acute in the age of the Web where everyone expects all content to be constantly up to date. The structure of content deeply effects your ability to find content that needs to change, to change it quickly and effectively, and to deal with the ripple effects of change.</db:para>
<db:para>In a large content organization, were the activities of many contributors have to be coordinated, the management of content assets themselves becomes a major source of complexity. <annotation type="process">Content management</annotation> system are themselves highly structured, and the structure of the content management system and the structures of the content meet and may overlap. Matching your content management strategy to the structure of your content is key to distributing content management complexity effectively.</db:para>
<db:para><db:indexterm><db:primary>Collaboration</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>Collaboration</db:secondary></db:indexterm>Collaboration has become an ever more important part of the content system as the Web forces us to deliver information in real time and to continually integrate the work of many different contributors. Without effective partitioning, the overhead of collaboration an overwhelm a system making it impossible to keep to schedule and maintain quality. Specific approaches to structured writing, particularly in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain can greatly reduce collaboration overhead and allow diverse contributions from diverse contributors to be integrated smoothly into the content collection.</db:para>
<db:para>The immediacy of the Web and the speed of modern commerce make <db:indexterm><db:primary>timeliness</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>timeliness</db:secondary></db:indexterm>timeliness and indispensable aspect of modern content. Yet handling the complexities of the content process can significantly slow the pace at which content goes from requirement to writing to publishing. All of the structured writing algorithms can contribute to enhanced timeliness, but most important of all is using them together in a way that ensures the no complexity is neglected in the process of getting content rapidly to market.</db:para>
<db:para>Finally, <db:indexterm><db:primary>repeatability</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>repeatability</db:secondary></db:indexterm>repeatability is the core goal of all management processes. Doing the right thing once is a work of craft. Ensuring that the right thing is done time after time is a work of management. But repeatability in content is about more than ensuring a efficient process. It is key to achieving consistent <db:indexterm><db:primary>quality</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>quality</db:secondary></db:indexterm>quality, and also the key to measuring the quality of your content and whether it is working effectively for your readers.</db:para>
</db:section>
<db:section>
<db:title>Publishing</db:title>
<db:para>In the end, of course, all content must be published in order to be accessible to readers. Publishing in a structured writing environment is complex, largely because so many of the other structured writing algorithms are actually executed during the publishing process. To facilitate this, most structured writing system implement a multi-step publishing process that allows different algorithms to be plugged in at the appropriate points in the process. This chapter will outline the partitioning of a structure publishing system, indicating were each of the other algorithms are executed in the process.</db:para>
<db:para>But publishing today is often about more than producing static outputs. In many cases, we publish <db:indexterm><db:primary>active content</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>active content</db:secondary></db:indexterm>active content, content that either shapes itself to the reader or allows the reader to manipulate it on the fly. All of the active content algorithms are actually the same structured writing algorithms we have already looked at, but publishing active content changes were they fit in the publishing process. And preparing for active content means structuring your content for the algorithms that will be used to generate the active content. This is another area in which the structured writing domain you have chosen, as well as the specific structures you have implemented will make a huge difference in what you are able to deliver to the reader.</db:para>
</db:section>
<db:section>
<db:title>Translation</db:title>
<db:para>Finally, <db:indexterm><db:primary>translation</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>translation</db:secondary></db:indexterm>translation is a major source of complexity in many content systems. Translation deserves a book all to itself, but this chapter will show some of the basic ways in which structured writing, and the various structured writing algorithms, can make a big difference for translation quality and costs.</db:para>
<db:para>As you go through these algorithms, be careful not to get too attached to any one domain or any one algorithm. Quality in a modern content system is produced by partitioning the complexity of the whole system so that every part of that complexity is handled by the person or process with the most appropriate skills, time, and resources to handle it completely. Implementing any one algorithm in isolation can result in complexity being distributed out to parts of the content system that are not well equipped to handle it. The aim is not to optimize any one function, but to ensure that complexity is being handled effectively across the whole content system.</db:para>
</db:section>
</db:chapter>
