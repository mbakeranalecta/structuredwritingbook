<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.subject-domain"><db:title>Writing in the Subject Domain</db:title>



<db:para>The <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain is concerned with the subject matter of a text, including both the rhetoric of a subject – the way information on a subject is expressed and presented for a particular audience and purpose – and the identification of subjects expressed in the content.</db:para>
<db:para>Some of the most important decisions you make when writing are rhetorical ones: what to say and how to say it. In the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, you make all these decisions, but you don’t explicitly record them. You record only the text that results from making those decisions. In the subject domain, however, you record exactly what you are writing about.</db:para>
<db:para>A recipe is a useful example for illustrating the subject domain. <db:xref linkend="ex.subj-restructured"/> is a recipe written in <db:indexterm><db:primary>reStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>reStructuredText</db:secondary></db:indexterm>reStructuredText, a lightweight general purpose <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain markup language:</db:para>
<db:figure xml:id="ex.subj-restructured"><db:title>Recipe for hard-boiled eggs marked up in reStructuredText</db:title><db:programlisting language="reStructuredText">
Hard-Boiled Eggs
================
A hard-boiled egg is simple and nutritious. 
Prep time, 15 minutes. Serves 6.

Ingredients
-----------
    ======  ========
    Item    Quantity
    ======  ========
    eggs    12
    water   2qt
    ======  ========
    
Preparation
-----------
    1. Place eggs in pan and cover with water.
    2. Bring water to a boil.
    3. Remove from heat and cover for 12 minutes.
    4. Place eggs in cold water to stop cooking.
    5. Peel and serve.
</db:programlisting></db:figure>
<db:para>In <db:indexterm><db:primary>reStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>reStructuredText</db:secondary></db:indexterm>reStructuredText, a line underlined with equals signs is a major heading and one underlined with dashes is a minor heading. You create a table by using equals signs to mark the beginning and end of the table and the boundary between the table head and the table body. You place each row on a new line and mark columns by putting spaces in the rows of equals signs. You create ordered lists by putting numbers in front of lines of text. The equivalent HTML document to <db:xref linkend="ex.subj-restructured"/> would look like <db:xref linkend="ex.subj-html"/>.</db:para>
<db:figure xml:id="ex.subj-html"><db:title>Recipe for hard-boiled eggs marked up in HTML</db:title><db:programlisting language="HTML">
&lt;html&gt;
    &lt;h1&gt;Hard-Boiled Eggs&lt;/h1&gt;
    
    &lt;p&gt;A hard-boiled egg is simple and nutritious. 
    Prep time, 15 minutes. Serves 6.&lt;/p&gt;
    
    &lt;h2&gt;Ingredients&lt;/h2&gt;
    &lt;table&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;Item&lt;/th&gt;
                &lt;th&gt;Quantity&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            &lt;tr&gt;
                &lt;td&gt;eggs&lt;/td&gt;
                &lt;td&gt;12&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;water&lt;/td&gt;
                &lt;td&gt;2qt&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;h2&gt;Preparation&lt;/h2&gt;
    &lt;ol&gt;
        &lt;li&gt;Place eggs in pan and cover with water.&lt;/li&gt;
        &lt;li&gt;Bring water to a boil.&lt;/li&gt;
        &lt;li&gt;Remove from heat and cover for 12 minutes.&lt;/li&gt;
        &lt;li&gt;Place eggs in cold water to stop cooking.&lt;/li&gt;
        &lt;li&gt;Peel and serve.&lt;/li&gt;
    &lt;/ol&gt;
&lt;/html&gt;
</db:programlisting></db:figure>
<db:para>The document shown in <db:xref linkend="ex.subj-html"/> follows the normal rhetorical pattern of a recipe. That is, it has all the pieces of information a recipe normally has, in the order they normally occur in a recipe: introduction, list of ingredients, preparation steps. However, it does not record the fact that it follows this rhetorical pattern. There is nothing in the markup to say that this is not a novel, a car manual, or a knitting pattern. Nor does the markup constrain an author to follow the normal rhetorical pattern of a recipe while writing.</db:para>
<db:para>Moving this document to the subject domain allows you to impose these rhetorical constraints and to record that you have done so. Neither <db:indexterm><db:primary>reStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>reStructuredText</db:secondary></db:indexterm>reStructuredText nor <db:indexterm><db:primary>HTML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>HTML</db:secondary></db:indexterm><db:indexterm><db:primary>HTML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>HTML</db:secondary></db:indexterm>HTML gives you a way to do that, so you need a different markup language. <db:xref linkend="ex.subj-sam"/> shows what that might look like:</db:para>
<db:figure xml:id="ex.subj-sam"><db:title>Recipe for hard-boiled eggs marked up in a subject-domain language</db:title><db:programlisting language="sam">
recipe: Hard-Boiled Egg
    introduction:
        A hard-boiled egg is simple and nutritious. 
        Prep time, 15 minutes. Serves 6.
    ingredients:
        * 12 eggs
        * 2qt water
    preparation:
        1. Place eggs in pan and cover with water.
        2. Bring water to a boil.
        3. Remove from heat and cover for 12 minutes.
        4. Place eggs in cold water to stop cooking.
        5. Peel and serve.
</db:programlisting></db:figure>
<db:para>This structure breaks the document into a collection of named structures – introduction, ingredients, and preparation – which are contained in an overall structure called recipe. This is the basic rhetorical structure of a recipe. This markup clearly identifies this as a recipe (not a novel, a car manual, or a knitting pattern), and you are explicitly guided to follow this pattern. You also must present the ingredients as an unordered list and the preparation as a numbered list. (<db:xref linkend="chapter.conformance"/> looks at how to express and enforce such constraints.)</db:para>
<db:para>In other words, in this example, someone other than the writer has made certain basic rhetorical decisions about how to write a recipe – let’s call that person an <db:indexterm><db:primary>information architect</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>information architect</db:secondary></db:indexterm>information architect, though this is not always the responsibility of people with that title. By making this rhetorical structure explicit, the information architect communicates this requirement to writers, which simplifies their task because they no longer need to make this decision for each recipe they write. It also ensures that all recipes follow this pattern.</db:para>
<db:para>This is not necessarily an all-or-nothing distinction. This recipe markup language enforces a couple of basic rhetorical decisions about recipes, but leaves plenty of others to the writer. Few markup languages are entirely in one domain, though most are predominantly in the document domain or the subject domain. Later, you’ll see how to move this recipe markup further into the subject domain, capturing more rhetorical decisions in the markup language design.</db:para>
<db:para>But this markup does not just force you to follow a set of rhetorical decisions, it factors out some rhetorical decisions altogether. This means that you neither make nor implement those decisions. An <db:indexterm><db:primary>information architect</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>information architect</db:secondary></db:indexterm>information architect makes the decisions and then designs an algorithm to implement them.</db:para>
<db:para>Suppose you decide that the ingredients and preparation sections of each recipe should be titled “Ingredients” and “Preparation.” If you write recipes in the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain using a language such as <db:indexterm><db:primary>markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>markdown</db:secondary></db:indexterm>markdown, you have to remember to execute this decision each time. But in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, the titles are factored out. Instead you have markup structures called <db:code>ingredients</db:code> and <db:code>preparation</db:code> that don’t contain titles. A <db:indexterm><db:primary>publishing algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publishing algorithm</db:secondary></db:indexterm>publishing algorithm adds the titles.</db:para>
<db:para>Partitioning requires you to pass enough information to the partition so the publishing algorithm can do its job. Here the presence of the <db:code>ingredients</db:code> and <db:code>presentation</db:code> sections in the recipe structure provides the information the algorithm needs to insert the appropriate titles.</db:para>
<db:para>By factoring out titles, you also factor out the constraint on what those titles must be. You don’t need to remember the title text, and a whimsical author can no longer decide to re-title these sections “Stuff you need,” “Stuff you do,” or some other variant. And you can change these titles across all recipes, including those you have already written, by changing the algorithm.</db:para>
<db:para>If you publish a lot of recipes, you probably have many more constraints to consider. For instance, you might have a constraint that every recipe must state its preparation time and the number of people it serves. In our subject-domain markup, we can enforce and record that constraint by moving that information from the introduction section to separate fields (see <db:xref linkend="ex.subj-add-constraint"/>).</db:para>
<db:figure xml:id="ex.subj-add-constraint"><db:title>Recipe with preparation time and servings added</db:title><db:programlisting language="sam">
recipe: Hard Boiled Egg
    introduction:
        A hard boiled egg is simple and nutritious.
    ingredients:
        * 12 eggs
        * 2qt water
    preparation:
        1. Place eggs in pan and cover with water.
        2. Bring water to a boil.
        3. Remove from heat and cover for 12 minutes.
        4. Place eggs in cold water to stop cooking.
        5. Peel and serve.
    prep-time: 15 minutes
    serves: 1
</db:programlisting></db:figure>
<db:para>Now, you no longer have to remember that this information is required and where it should appear. The information is partitioned off into separate fields. The system prompts you for those fields and will raise errors if you forget. And the decision about where to include this information in output formats has been transferred to an algorithm.</db:para>
<db:para>This does not mean that the prep-time and serves information must be displayed as separate fields in the output. You could display this information in separate fields so that readers can find it more easily, but you could also have the publish algorithm construct sentences such as “Prep time, XX minutes. Serves YY.” using the <db:code>prep-time</db:code> and <db:code>serves</db:code> field values for XX and YY.</db:para>
<db:para>So, something interesting has happened here. To enforce a rhetorical constraint – that you must specify prep time and number of servings – we have moved away from markup that specifies presentation to markup that merely records data. In other words, <db:code>prep-time</db:code> and <db:code>serves</db:code> are data-oriented <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain structures that do not specify presentation at all. Partitioning this required information from the presentation of the recipe shifts responsibility for conformance from the author to a <db:indexterm><db:primary>conformance algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>conformance algorithm</db:secondary></db:indexterm>conformance algorithm, making the design more testable and <db:indexterm><db:primary>repeatable</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>repeatable</db:secondary></db:indexterm>repeatable – a welcome redistribution of complexity.</db:para>
<db:para>This is a recurring pattern in structured writing and one of the most important things to understand about how structured writing works. It is almost always better to factor out a constraint than to enforce it. This can be a difficult idea to adjust to. Our natural first instinct when trying to achieve a  particular presentation is to specify it in detail. But this can be difficult, especially for rhetorical constraints such as requiring a recipe to contain certain pieces of information. Nor is it flexible if you want to vary the presentation. When you look at these kinds of problems, the first question should be, “Is there any way to factor out this constraint”? Then, impose a constraint only if you cannot factor it out.</db:para>
<db:para>When you <db:emphasis>enforce</db:emphasis> a constraint, the information architect has made the decision, but the writer must execute that decision in the content. When you <db:emphasis>factor out</db:emphasis> a constraint, the information architect has still made the decision, but an algorithm executes the decision, rather than the writer. Not only does this make the writer’s job simpler, but it helps ensure conformance to the constraint and allows you to change the decision without changing the writer’s content.</db:para>
<db:para>Beyond factoring out constraints, using <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain markup enables some interesting publishing possibilities. For instance, you can easily create a cookbook of recipes that take 30 minutes or less, because you can query your recipes and select just those where the <db:code>prep-time</db:code> field has a value of 30 minutes or less.</db:para>
<db:para>There other elements of presentation that you can factor out of the recipe structure. For example, the reStructuredText version in <db:xref linkend="ex.subj-restructured"/> presents ingredients in a table, and the recipe structure in <db:xref linkend="ex.subj-sam"/> uses a simple list. The block that contains the list is labeled “ingredients,” but the list is just an ordinary unordered list. The ingredient list in a recipe has constraints, but the markup doesn’t impose or record those constraints.</db:para>
<db:para>You generally define each ingredient in a recipe using three pieces of information: the name of the ingredient, the quantity, and the unit of measure used to express the quantity. These can be presented as a list or a table. To factor out the presentation choice, you can create an ingredient structure that calls out each piece of information separately (see <db:xref linkend="ex.subj-ingredient-1"/>).</db:para>
<db:figure xml:id="ex.subj-ingredient-1"><db:title>Subject-domain markup for ingredients</db:title><db:programlisting language="sam">
ingredients:
    ingredient: 
        name: eggs
        quantity: 12
        unit: each
    ingredient:
        name: water
        quantity: 2
        unit: qt
</db:programlisting></db:figure>
<db:para><db:xref linkend="ex.subj-ingredient-2"/> shows a shortcut that makes this markup less verbose. (This is a markup syntax named <db:indexterm><db:primary>SAM</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SAM</db:secondary></db:indexterm>SAM that I will talk about later).</db:para>
<db:figure xml:id="ex.subj-ingredient-2"><db:title>Subject-domain shortcut for ingredient markup</db:title><db:programlisting language="sam">
ingredients:: ingredient, quantity, unit
    eggs, 12, each
    water, 2, qt
</db:programlisting></db:figure>
<db:para>This markup turns the ingredients into a set of records with named fields: ingredient, quantity, and unit. Both markups enforce the constraint and record that you have followed it. And because the markup is independent of any one form of presentation, you are now free to use an algorithm to present them as a table, as a list, or in some other form.</db:para>
<db:para>By adding and recording these constraints, you get the same benefits as before, but now you also have access to the data, which means you can write algorithms to handle tasks such as converting units from imperial to metric for markets where metric units are preferred.</db:para>
<db:section>
<db:title>Using subjects to establish context</db:title>
<db:para>In <db:xref linkend="chapter.document-domain"/>, I noted that you can use context to identify the role that structures play in a document, which allows you to get away with fewer structures. For instance, you can use a single <db:code>title</db:code> tag for all titles because you can differentiate different types of titles from the context in which they occur. The same is true with subject-domain structures. They can provide context that allows you to treat basic text structures differently.</db:para>
<db:para>Consider our markup language for recipes (<db:xref linkend="ex.subj-recipe-sam"/>).</db:para>
<db:figure xml:id="ex.subj-recipe-sam"><db:title>Subject-domain markup for recipes</db:title><db:programlisting language="sam">
recipe: Hard Boiled Egg
    introduction:
        A hard boiled egg is simple and nutritious.
    ingredients:: ingredient, quantity, unit
        eggs, 12, each
        water, 2, qt
    preparation:
        1. Place eggs in pan and cover with water.
        2. Bring water to a boil.
        3. Remove from heat and cover for 12 minutes.
        4. Place eggs in cold water to stop cooking.
        5. Peel and serve.
    prep-time: 15 minutes
    serves: 6
</db:programlisting></db:figure>
<db:para>With the ingredients we saw that you need to add additional structure to factor out whether the ingredients would be presented as a list or a table. For the preparation, the steps are currently marked up as a numbered list.  Suppose you want to present the steps as steps, rather than just as a generic numbered list (for instance, by labeling them as <db:emphasis role="bold">Step 1.</db:emphasis>, etc, rather than just <db:emphasis role="bold">1.</db:emphasis>). Do you need to create an additional <db:code>step</db:code> structure to do this? Not necessarily. In this case, you can distinguish an ordinary ordered list from a set of preparation steps based on context and write a rule in the <db:indexterm><db:primary>publishing algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publishing algorithm</db:secondary></db:indexterm>publishing algorithm that creates special formatting for ordered lists that are the children of <db:code>preparation</db:code> elements that are children of <db:code>recipe</db:code> elements. This uses the same method we used in <db:xref linkend="chapter.document-domain"/> to format a nested list differently from its parent list based on context. This is another example of how partitioning creates context that you can use to simplify processing.</db:para>
</db:section>
</db:chapter>
