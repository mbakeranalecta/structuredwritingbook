<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.translation"><db:title>Translation</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idm405770140"><db:primary>translation</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm405770140x"><db:primary>algorithm</db:primary><db:secondary>translation</db:secondary></db:indexterm>




<db:para>Translation is a major source of complexity for organizations that deliver content in multiple languages. Complexity comes not only from the translation process but also from integrating the  translated content back into your <db:indexterm><db:primary>publishing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publishing</db:secondary></db:indexterm>publishing process.</db:para>
<db:para>Translation is a huge subject in its own right, and I have neither the space nor the expertise to do it full justice. Therefore, I will make just a couple of points about how structured writing can help partition and transfer certain aspects of the complexity of translation.</db:para>
<db:section>
<db:title>Avoiding trivial differences</db:title>

<db:para>Trivial differences in how the same thought is worded make little difference to a reader, but they can run up translation costs. Structuring content to avoid these trivial differences can reduce translation costs.</db:para>
<db:para>There are two principle ways you can do this with structured writing:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para><db:indexterm><db:primary>Reuse</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>Reuse</db:secondary></db:indexterm>Reuse the same piece of content every time the same thought is expressed. However, as we have seen, this approach comes with complexities of its own. The smaller you make the pieces of content, the more reuse you can get, but the more pieces you have to manage, the more pieces writers have to look through to find reusable content. And it is hard to constrain and maintain rhetorical quality when writers write in tiny fragments.</db:para>
</db:listitem>
<db:listitem>
<db:para>Factor out the content that repeats the thought. We have seen several examples in this book. When we moved the recipe example into the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, we factored out the titles of the recipe sections, eliminating any trivial differences in the titles that writers might introduce. In <db:xref linkend="chapter.reuse"/> we factored out a repeated safety warning by adding an <db:code>is-it-dangerous</db:code> field to the <db:code>procedure</db:code> structure. This removed the need for writers to think about reusing the warning, and it also factored out any issues regarding the file name for the different language versions. (Something similar could be achieved using the <db:indexterm><db:primary>keys</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>keys</db:secondary></db:indexterm>keys approach described in the same chapter.)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>Isolating content that has changed</db:title>

<db:para>When you revise text, such as when you bring out a new version of a product, some of the text changes, but much of it remains the same. You can save time and money on translation if you only translate the content that has changed. However, to do this you need a way to isolate the content that has changed from that which has not, and you need a way to integrate the changed material back into your content after it has been translated.  Structured writing allows you to clearly define structures in your content set and deliver just those structures that have changed.</db:para>
</db:section>
<db:section>
<db:title>Continuous translation</db:title>

<db:para>If you write a book and then send it for translation, the translated version will be ready to release long after your first language version is ready. This delay can result in missed opportunities. To bring out first language and translated versions simultaneously, or close to it, you need translation to occur simultaneously with the development of the first language content.</db:para>
<db:para><db:indexterm><db:primary>Continuous translation</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>Continuous translation</db:secondary></db:indexterm>Continuous translation is not just about getting all versions of a book released at the same time. On the web, you may be releasing new pieces of content every day. If you maintain translated versions of that content, you want them to go out at the same time. You may also want to provide links between the different language versions of the same content because searches and links do not always send readers to content in their preferred language. A structured approach to <db:indexterm><db:primary>publishing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publishing</db:secondary></db:indexterm>publishing and <db:indexterm><db:primary>information architecture algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>information architecture algorithm</db:secondary></db:indexterm>information architecture can accommodate these requirements.</db:para>
<db:indexterm class="endofrange" startref="idm405770140"/><db:indexterm class="endofrange" startref="idm405770140x"/></db:section>
</db:chapter>
