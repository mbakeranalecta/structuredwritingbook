<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.translation"><db:title>Translation</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp141084916"><db:primary>translation</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp141084916x"><db:primary>algorithm</db:primary><db:secondary>translation</db:secondary></db:indexterm>



<db:para>Many organizations deliver content in multiple languages. Translation is a major source of complexity in the content processes of those organizations. It is not only the complexity of doing the translation, but the complexity of integrating the translation process into the overall content process, and of integrating the translated content into the <db:indexterm><db:primary>publishing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publishing</db:secondary></db:indexterm>publishing process. Translation is a huge subject in its own right and I have neither the space not the expertise to do it full justice. Therefore I will make just a couple of points about how structured writing can help partition and transfer certain aspects of the complexity of translation.</db:para>
<db:section>
<db:title>Extracting content for translation</db:title>
<db:para>Translators generally do not work in the the original source format of the content. A translation agency works with many customers and thus content in many file formats, so it would be onerous for translators be be fluent in all of them. Besides, the translators donâ€™t need any of the features of these programs. In many cases, though, they do need features specific to translation, such as access to translation memory. Thus text to be translated is often extracted from its source format, translated in a separate tool, and then reinserted into the original source application.</db:para>
<db:para>There is an <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm><db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML standard that is used to do this round-trip, called <db:indexterm><db:primary>XLIFF</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XLIFF</db:secondary></db:indexterm>XLIFF. It records the metadata necessary to extract and replace the content in its original format after publishing. The ability of your source format to work with XLIFF can therefore be an important consideration. (XLIFF represents a neat partitioning and transfer of the complexity of file formats in translation.)</db:para>
<db:para>If your source format is a desktop publishing format, however, inserting the translated content back into the source format may leave the layout looking wrong since the translated text may be longer or shorter, or may require a completely different layout from the original text. This need to redo the formatting of the translated content can add significantly to translation time and costs. Using a structured writing format that factors out the the <db:indexterm><db:primary>formatting algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>formatting algorithm</db:secondary></db:indexterm>formatting can reduce these costs by allowing each translated version to be formatted algorithmically. But as we saw in <db:xref linkend="chapter.separating"/>, there are various degree of separation that you can achieve using different kinds of structure to factor out more of the formatting. The different <db:indexterm><db:primary>presentation</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>presentation</db:secondary></db:indexterm>presentation and <db:indexterm><db:primary>formatting algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>formatting algorithm</db:secondary></db:indexterm>formatting needs of different languages and cultures could require a higher degree of separation that you might otherwise have created, so make sure to account for this when choosing which content structures to use.</db:para>
</db:section>
<db:section>
<db:title>Avoiding trivial differences</db:title>
<db:para>Trivial differences in how the same thought is worded make little difference to a reader, but they can run up translation costs. Structuring content to avoid these trivial differences can reduce translation costs.</db:para>
<db:para>There are two principle ways you can do this with structured writing. The first is to <db:indexterm><db:primary>reuse</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm>reuse the same piece of content every time the same thought is expressed. As we have seen, though, this approach comes with complexities of its own. The smaller you make the pieces of content you reuse, the more reuse you can get, but the more pieces you have to manage and the more pieces the writer has to look through to find reusable content.</db:para>
<db:para>The second is to factor out the content that repeats the thought. We have seen examples of this a number of times in this book. As we moved our recipe example into the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, we factored out the titles of the recipe sections, eliminating any trivial differences in the titles writers might use. In <db:xref linkend="chapter.reuse"/> we factored out a repeated safety warning by adding a <db:code>is-it-dangerous</db:code> field to our <db:code>procedure</db:code> structure. This not only removes the need for writers to think about the reuse of the warning, it also factors out any issues regrading the file name for the different language versions. (Something similar could be achieved using the <db:indexterm><db:primary>keys</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>keys</db:secondary></db:indexterm>keys approach we also looked at in that chapter.)</db:para>
</db:section>
<db:section>
<db:title>Isolating content that has changed</db:title>
<db:para>When a text is revised, such as when you bring out a new version of a product, some of the text is changed, but much of it remains the same. You can save time and money on translation if you only translate the content that has changed. To do this, though, you need a way to isolate the content that has changed from that which has not, and a way to integrate them again after the changed material has been translated.  Structured writing allows you to clearly define structures in your content set and deliver just those structures that have changed.</db:para>
</db:section>
<db:section>
<db:title>Continuous translation</db:title>
<db:para>If you write a book and, when it is finished, send it for translation, you translated version will we ready to release quite a long time after your first language version is ready. This delay can represent serious missed opportunities. To bring out first language and translated versions simultaneously, or close to it, you need the translation to occur simultaneously with the development of the first language content.</db:para>
<db:para><db:indexterm><db:primary>Continuous translation</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>Continuous translation</db:secondary></db:indexterm>Continuous translation is not just about getting all version of a book released at the same time. On the web, you may be releasing new pieces of content into your content collection every day. If you are maintaining translated versions of that content, you want them to go out at the same time. You may also want to provide links between the different language version of the same content as searches and links do not always send readers to their own language version of your content. A structured approach to <db:indexterm><db:primary>publishing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publishing</db:secondary></db:indexterm>publishing and <db:indexterm><db:primary>information architecture algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>information architecture algorithm</db:secondary></db:indexterm>information architecture can accommodate these requirements.</db:para>
<db:indexterm class="endofrange" startref="idp141084916"/><db:indexterm class="endofrange" startref="idp141084916x"/></db:section>
</db:chapter>
