<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.audit"><db:title>Auditing</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp33073652"><db:primary>auditing</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp33073652x"><db:primary>concept</db:primary><db:secondary>auditing</db:secondary></db:indexterm>



<db:para>While the appropriate structured writing techniques can help to avoid your content set falling into disorder, maintaining a healthy content collection and a well integrated information architecture still requires constant monitoring  to find and fix errors and to ensure that your processes are working as well as possible.</db:para>
<db:para>In <db:xref linkend="chapter.conformance"/> we looked at how structured writing techniques can improve the <db:indexterm><db:primary>conformance</db:primary></db:indexterm><db:indexterm><db:primary>process</db:primary><db:secondary>conformance</db:secondary></db:indexterm>conformance of individual pieces of content. In <db:xref linkend="chapter.metadata"/>, we looked at how they can assist in the maintenance of <db:indexterm><db:primary>metadata</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>metadata</db:secondary></db:indexterm>metadata and <db:indexterm><db:primary>taxonomy</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>taxonomy</db:secondary></db:indexterm>taxonomy across the entire information set. Now we will look at how they can be used to audit a content set as a whole to ensure it meets its constraints, and that its constraints are consistent with its goals.<db:footnote>
<db:para>Content strategists often use the term “content audit” to mean a current state analysis performed at the beginning of a website redevelopment project. A content strategy content audit is about cataloging, and possibly categorizing, the content you already have. I am using the word audit to refer to an ongoing and or recurring activity in which a you ensure that a content set is meeting or continuing to meet its goals.</db:para>
</db:footnote></db:para>
<db:para>It is not a given that if every item in a collection meets its individual constraints that the whole collection meets its constraints. Just because every item in your collection is conformant does not mean that the collection is complete, for instance, or that all the links that should exist do exist, or that they point to the best resources. For issues like these, you need both a sound strategy for creating and supporting your <db:indexterm><db:primary>information architecture algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>information architecture algorithm</db:secondary></db:indexterm>information architecture, and a sound <db:indexterm><db:primary>audit</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>audit</db:secondary></db:indexterm>audit process to make sure everything is in its place.</db:para>

<db:para>Auditing is about making sure that:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>The definition of the content set is correct (we know what types of content it should contain, and which instances of each type)</db:para>
</db:listitem>
<db:listitem>
<db:para>The content set is complete (it contains all the items of each type that it should)</db:para>
</db:listitem>
<db:listitem>
<db:para>The content set is uncontaminated (it does not contain any items or types it should not)</db:para>
</db:listitem>
<db:listitem>
<db:para>The content set is integrated (it expresses all of the relationships between items that it should)</db:para>
</db:listitem>
<db:listitem>
<db:para>Each item in the content set <db:indexterm><db:primary>conformance</db:primary></db:indexterm><db:indexterm><db:primary>process</db:primary><db:secondary>conformance</db:secondary></db:indexterm>conforms to its constraints</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Auditing a large content set is difficult and many CMS solutions are deficient in audit capabilities. The main reason for this is that with the way most content is recorded and stored (<db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain or generic <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain formats), it is very difficult to mechanically assess what content you have and what state it is in. It is hard to know if you have all the pieces you should have if you can’t tell exactly what each piece is.</db:para>
<db:para>One of the biggest, and least appreciated, benefits of structured writing is that it makes content more auditable. When content management systems fail or become unmanageable, the root cause is often either an incorrect distribution of complexity from day one or a failure to audit: either lack of attention to regular audits, or the lack of ability to audit effectively. Without the ability to audit effectively, content sets often end up incomplete, corrupt, and poorly integrated, which reduces quality and increases costs at every stage of the process. It creates a body of unmanaged complexity that every downstream process and person has to deal with, including, of course, the reader. And a vicious cycle can develop in which writers, frustrated with the difficulties of the system, create workarounds that further corrupt the information set. Unmanaged complexity breeds more complexity. Whatever expenses you may incur to implement a more structured structured writing approach could well be offset or even exceeded by the savings associated with more effective auditing of the content set.</db:para>
<db:section>
<db:title>Correctness of the definition of the content set</db:title>
<db:para><db:indexterm><db:primary>content strategy</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>content strategy</db:secondary></db:indexterm>Content strategists will spend a great deal of time and effort developing a content plan (usually this is for a website, but the same principle applies to any content set). How they do this is beyond the scope of this book, but the result should be a definition of the content set: which types of information it is supposed to contain and which instances of those types. (This definition is based, of course on the goals it is designed to achieve, which it is the business of the content strategist to define.)</db:para>
<db:para>The definition of a content set is not necessarily static. It is not necessarily a fixed list of topic types or of specific topics to be developed. For one thing, the subject matter may change during the course of content development, which would change the content pieces needed, and perhaps require new content types or modifications to existing types. Second, the exact set of pieces or types may not be knowable at the outset. Content development explores a complex set of relationships between subject matter and the needs and background of the reader that cannot be fully known without traveling the ground in detail.</db:para>
<db:para>It is hard to be disciplined and deliberate in evolving the big picture model of the content set if you are not disciplined and deliberate in how you create the pieces. If you ask a writer to write a piece and then ask them after they are finished to describe the job it does by assigning CMS metadata to it, they will tag it using the terms that seem like the closest fit to the content they have already written, but they will probably not revise the content to fit the labels they are applying to it. Their view will not be that the content is wrong, but that the labels don’t fit the content. And since the labels won’t fit the content, you won’t really know what type of content you have in your collection.</db:para>
<db:para>If you don’t really know what type of content you have, you can’t really tell if the definitions for your content set are correct. Some content may perform poorly because it does not fit the type definition properly. But you can’t tell whether it failed because it didn’t fit the type definition or because the type definition is wrong. Thus you don’t know what to fix.</db:para>
<db:para>Of course, a writer may come up with something that is better than the current type definition. This is a good thing. If it really is better, you want to change the type definition to match it so that all future content will be better as well. But if the author simply tags it according to the current CMS tags, you will never know that it is a different model, never have the chance to test the new model to see if it is better, and never have the chance to update the definition so that new content follows the successful new model. Unless your content types are codified and auditable, you won’t detect improvements in the types and they won’t carry over to other content. See <db:xref linkend="chapter.repeatability"/> for more on this.</db:para>
<db:para>Having strong well-defined content types makes it easier to audit your  types to make sure they are doing the job they were designed to do. Similarly, having strong well-defined content types means that you can have greater assurance that each item is doing the job it is supposed to do, which helps you make sure you have covered all the subjects you should have.</db:para>
</db:section>
<db:section>
<db:title>Completeness</db:title>
<db:para>But structured writing can do more than this to help you audit the definition of the content set. It can help you assess its completeness as well. If you create content in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, including <db:indexterm><db:primary>subject annotation</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject annotation</db:secondary></db:indexterm>annotating the subjects that you mention in the text, you can use algorithms to extract a list of the types and subjects that your content is actually talking about. In your initial top-down plan, you may not have thought about the need for content on a certain subject or to support a certain activity, but if that subject or that activity start showing up in the body of your content, that is a strong indication that those subjects and activities are related to the purpose of your content set and should probably be included in the definition of the content set.</db:para>
<db:para>Subject domain structured writing is how you know what your content is actually talking about, what every author is discovering or thinks needs saying. Content needs are ultimately driven by subject matter and it is your writers working with the subject matter every day who are on top of what the subject matter is and how it is changing. Bottom-up content planning distributes the responsibility for discovery outward and for coordination inward to keep you in touch with evolving content needs. Without this information flow it is very difficult to establish that the content set is meeting its coverage goals. (We saw the same pattern of information flow with bottom up taxonomy development in <db:xref linkend="chapter.taxonomy"/>.)</db:para>
<db:para>This actually attacks two audit problems. If writers are writing about things outside your current coverage definition, either your coverage definition needs updating, or writers are polluting the content set with irrelevant material.</db:para>
</db:section>
<db:section>
<db:title>Avoiding contamination</db:title>
<db:para><db:indexterm><db:primary>Subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>Subject domain</db:secondary></db:indexterm>Subject domain content structures and annotations can help you prevent contamination of the content set by irrelevant or poor quality material. But more important than catching writers in the act is catching the flaws in content types that allow for contamination to creep in.</db:para>
<db:para>A major form of contamination in any content set is redundant content. As we noted in <db:xref linkend="chapter.duplication"/>, we have to be careful in how we define redundancy, because it is not simply a matter of only addressing a subject once. It is a matter of addressing an audience need only once, and that may require several topics on the same subject addressed to different readers. But it is all too easy for duplicate content to sneak into a content set. Some of it comes in because the same functionality is repeated in many products or in content delivered to different media. Some comes in through writers simply not knowing that suitable content already exists.</db:para>
<db:para><db:indexterm><db:primary>content reuse algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content reuse algorithm</db:secondary></db:indexterm>Content reuse is a major motivator for structured writing for exactly this reason. But the <db:indexterm><db:primary>content reuse algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content reuse algorithm</db:secondary></db:indexterm>content reuse algorithm only addresses the problem of how to reuse content. It provides a method to reuse content you are aware of. It does not prevent you from duplicating content because you did not look for or did not find existing reusable content. You need to audit your content regularly to make sure that content is findable by writers who may want to reuse it, and to make sure that duplication is not creeping in.</db:para>
<db:para>There are natural language processing algorithms that will attempt to identify redundant content in a content set, but such algorithms focus on similar texts. This is not enough. The same or similar sequences of words may occur in different places without being redundant. They may mean different things, or perform different roles, in context. On the other hand, redundant pieces of information may be expressed in very different words. It is redundant information, not redundant phrases, that we care about.</db:para>
<db:para>Even when redundancies are found, they may be very difficult to consolidate if they don’t have similar boundaries within their respective documents (the <db:indexterm><db:primary>composition</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>composition</db:secondary></db:indexterm>composability problem – see <db:xref linkend="chapter.composition"/>). Strongly typed subject domain content, meaning content that conforms to a model that breaks down and enforces the various pieces of information required to correctly cover a topic, makes it possible to detect duplication in a much more formal and precise way. Duplication of subject matter is much easier to detect when content is captured in the subject domain.</db:para>
<db:para>A person who consults a repository to see if there is a piece of content they can use relies on the ability to query the repository in a sensible way for the type of content they are looking for. They also rely on their ability to recognize the content when they see it, and on it actually being strongly conformant so that they can use it with confidence. Subject domain topic typing helps with all of these things. Subject domain labeling of document and media domain content can help as well, but only if it is conforms to the appropriate constraints, a problem discussed in <db:xref linkend="chapter.conformance"/>. The easier it is to correctly identify reusable content and use it, the less corruption of the repository will occur.</db:para>
</db:section>
<db:section>
<db:title>Maintaining integration</db:title>
<db:para>A content set is never a collection of wholly independent pieces. The items in the set have relationships to each other that matter to the reader.  Whether you express those relationships through <db:indexterm><db:primary>links</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>links</db:secondary></db:indexterm>links or <db:indexterm><db:primary>cross references</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>cross references</db:secondary></db:indexterm>cross references, or whether you rely entirely on tables of contents and indexes, it is still important to understand and manage the relationships between items.</db:para>
<db:para>Relationships between items may matter for management reasons as well. If you have documentation for multiple releases of a product, the relationship between the documentation for feature X in version 3 and that for feature X in version 2 matters to you. It may matter because the feature has not changed and you can reuse the item. It may matter because an error was found in version 2 and you want to fix it in version 3 as well. And if you put this content online, the relationship may matter for the reader as well, if they search for feature X and get the result for version 2 when they are using version 3.</db:para>
<db:para>You can describe the relationship between items externally. Items are related whenever they have the same value in any one of their <db:indexterm><db:primary>metadata</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>metadata</db:secondary></db:indexterm>metadata fields. Which field it is tells you what the relationship is. Finding the relevant metadata field to look at allows you to manage the relationship. But the same problem exists here as it always does with all external metadata (see <db:xref linkend="chapter.content-management"/>) – the content may not conform to the metadata, and without structured writing in the content itself, it is hard to audit the conformance of the content to its metadata. In-band information is always more reliable than out-of-band information.</db:para>
<db:para>But the bigger problem is that external metadata does not map the important relationship that can exist between a part of one item and the whole of another item. Are function names mentioned in the programming topics all listed in the API reference? Are the utensils mentioned in a recipe all covered in the appendix of kitchen tools? These are important content relationship questions, but their importance cannot be mapped with external metadata. You need subject domain markup inside the piece that identifies function calls and the names of kitchen tools.</db:para>
<db:para>Structured writing, particularly in the subject domain, helps you discover and manage these relationships by making clear the subjects on which these relationships are based.</db:para>
</db:section>
<db:section>
<db:title>Making content auditable</db:title>
<db:para>I have talked all through this chapter about how using strong content types makes content easier to audit. What is a strong content type? Fundamentally, a strong content type is one that makes explicit what the content is supposed to say an how it is supposed to say it. Or, to put it another way, a strong content type is one that captures, enforces, or factors out the major constraints of the content, including its major rhetorical constraints. A strong content type constrains the interpretation of content as well as its composition, and the more reliably content can be interpreted, the more reliably it can be audited. Strong content types are almost always in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain.</db:para>
<db:para>It is possible for content to conform to all of its rhetorical constraints without the use of structured writing techniques. But strong content types provide explicit guidance to the author and facilitate the use of <db:indexterm><db:primary>conformance</db:primary></db:indexterm><db:indexterm><db:primary>process</db:primary><db:secondary>conformance</db:secondary></db:indexterm>conformance algorithms. They are created to meet your conformance goals. Similarly with auditing, you specify the content structures you need in order to meet your auditing goals.</db:para>
</db:section>
<db:section>
<db:title>Facilitating human review</db:title>
<db:para>Auditing is sometimes not as straightforward as conformance, even with structured writing techniques in place. Auditing often requires human review, not only to make sure that all subjects have been covered, but to discover new issues or subjects that need to be addressed. Human review of a large content set is difficult due to the sheer amount of content. An <db:indexterm><db:primary>audit algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>audit algorithm</db:secondary></db:indexterm>audit algorithm can simplify this work by creating different views of the content set that humans can review more easily (an application of the content generation algorithm for internal purposes).</db:para>
<db:para>Suppose, for instance, that an organization is using subject-domain annotations to drive linking as described in <db:xref linkend="chapter.linking"/>. Every topic in the collection is supposed to be indexed to state the type and names of the subjects it covers. Every mention of a significant subject is supposed be annotated with its type. The <db:indexterm><db:primary>linking algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>linking algorithm</db:secondary></db:indexterm>linking algorithm uses these annotations and index entries to link the content without any need for writers to create or manage links in the source text. But that does not guarantee that all the right links get made. There could be errors in indexing or annotation that are impossible to detect when <db:indexterm><db:primary>conformance</db:primary></db:indexterm><db:indexterm><db:primary>process</db:primary><db:secondary>conformance</db:secondary></db:indexterm>conformance testing individual topics. But you can do an awful lot to catch these kinds of errors when you audit the content set as a whole.</db:para>
<db:para>These are some of the audit functions we can perform based on the annotations and index entires in a content set:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>We can create a sorted list of all the phrases that have been annotated and see if they are being annotated consistently. This will tell us a lot about the subject types we are using, how well they are understood, and what instances of each type we should be covering.</db:para>
</db:listitem>
<db:listitem>
<db:para>We can create a list of all the phrases that have been indexed and check it against our content plan (perhaps against a <db:indexterm><db:primary>taxonomy</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>taxonomy</db:secondary></db:indexterm>taxonomy, if we have one). This will tell us a lot about whether our coverage is complete, whether our writers are getting off track, or whether our content plan or our taxonomy is off base with reality.</db:para>
</db:listitem>
<db:listitem>
<db:para>We can create a sorted list of all the index terms and check it against the list of annotated phrases to find phrases are that being indexed but not annotated or annotated but not indexed. This can tell us is there are subjects we are not covering, if writers are discussing subjects they should not be, or if some topics are not being indexed or annotated properly.</db:para>
</db:listitem>
<db:listitem>
<db:para>During the content development phase, the list of things that are annotated but not indexed will inevitable grow, as subjects are being referred to before the content that describes them is written. The trend line of the growth of new subjects being annotated vs subjects being indexed will allow you to track how close a content set is to completion, even in cases were defining the boundaries in advance is difficult.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Content is one of the hardest assets to audit and inventory. Structured writing, particularly subject domain structured writing, can greatly aid in establishing an effective audit function for your content. An effective content audit process, in turn, can help avoid the gradual decline of order and reliability that affects so many managed content sets and leads to the slow death by strangulation of so many content management systems.</db:para>
<db:indexterm class="endofrange" startref="idp33073652"/><db:indexterm class="endofrange" startref="idp33073652x"/></db:section>
<!--  FIXME: Needs an example audit report. Generate one for the book to illustrate the idea. -->
</db:chapter>
