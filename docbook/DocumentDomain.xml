<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.document-domain"><db:title>Writing in the Document Domain</db:title><db:indexterm class="startofrange" xml:id="idm442841212"><db:primary>media domain</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm442841212x"><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm><db:indexterm class="startofrange" xml:id="idm442834300"><db:primary>document domain</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm442834300x"><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm><db:indexterm class="startofrange" xml:id="idm442832892"><db:primary>subject domain</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm442832892x"><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>



<db:para>The <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain is concerned with the presentation of information as a document. The words “formatting” and “presentation” are commonly used as synonyms, but here I am going to make a distinction between, for example, the decision to present a piece of information as a list (presentation), and the decision to format list items in 12 point Palatino with 1 em indent and a square bullet (formatting). In this sense, presentation and formatting are distinct things that can be partitioned from each other. If we think of them as synonyms, it is probably because most of the tools we use today don’t partition them from each other, but rather combine them into a single operation in a WYSIWYG display.</db:para>
<db:para>When you write in the document domain you make decisions about when and where to use domain structures such as title, list, and tables, without specifying how any of these will be formatted. You are making document domain decisions but deferring media domain decisions to someone else. (In all likelihood, you are transferring the making of those decisions to a designer, and the execution of those decisions to an algorithm written or specified by the designer.)</db:para>
<db:para>Word processors and desktop publishing applications partition the writing task in a way that tends to straddle the divide between the media domain and the document domain. While they are built on a basic set of document domain objects – pages, paragraphs, tables, etc. -- they use a WYSIWYG display, which unifies, rather than partitions, the writing and formatting of a document, to keep the author working and thinking mostly in terms of styles and formatting – the concerns of the media domain. This makes it difficult to apply meaningful document domain constraints to the author’s work, or to record which constraints the author has followed. This makes it impossible to redistribute formatting complexity away from the author. For that we need to move more fully into the document domain.</db:para>
<db:para>The simplest reason for moving to the document domain is actually to enforce media domain constraints that are hard to enforce in the media domain itself. In fact, the reason for moving to the next domain is often to enforce – or factor out – constraints in the previous domain. This is one of the consistent patterns we find in structured writing.</db:para>
<db:para>Consider a list. You may want to impose a constraint that the spacing above the first item of a list must be different from the spacing between other items of the list. This is a media domain constraint – it is about formatting, not the structure of the document – but it is hard to enforce in the media domain. Most media domain writing applications create lists by applying styles to ordinary paragraphs. The usual way to apply the extra space above the first item is to create two different styles, which we can call first-item-of-list style, and following-item-of-list style. The first-item-of-list style is defined with more spacing above.</db:para>
<db:para>This creates a constraint that the author is required to follow. They are required to apply first-item-of-list style to the first item of a list and following-item-of-list style to the following items. Nothing in the word processor enforces this constraint. The author simply has to remember it. This creates two problems:</db:para>
<db:orderedlist>
<db:listitem>
<db:para>It makes writing a little bit harder (and all the little bits add up). It is a decision that the writer has to make and execute over and over again even though the actual design decision has already been made. New authors may not know to make this decision and may just use the list button. These errors then have to be caught and fixed.</db:para>
</db:listitem>
<db:listitem>
<db:para>The author can get it wrong without anyone noticing. They may forget to apply first-item-of-list style or they may add a new first item to the list and not realize that the second item in the list now has first-item-of-list style.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>As we noted before, structured writing works by factoring out invariants. Most constraints are invariants – that is, they are rules that apply to all instances of the same content structure (such as all lists must have extra space before the first item). The easiest way to enforce a constraint is not to enforce it on the author, but to partition it out altogether.</db:para>
<db:para>To do this, we create a list structure – not a styled paragraph, but an structure that is specifically a list. The word processor version of a list is structured like this, as a flat list of styled paragraphs:</db:para>
<db:programlisting>
p{first-item-of-list}: Carrots
p{following-item-of-list}: Celery
p{following-item-of-list}: Onions
</db:programlisting>
<db:para>An explicit list structure looks like this:</db:para>
<db:programlisting language="SAM">
list:
    list-item: Carrots
    list-item: Celery
    list-item: Onions
</db:programlisting>
<db:para>A list structure partitions the idea of a list from the physical formatting of a list by creating a container that did not exist before – the <db:code>list</db:code> structure. In order to transfer the decisions about list formatting away from the author, we need to transfer the information that this is a list to the algorithm that will now do the formatting. Having the writer create a list structure accomplishes this information transfer. Since a list is a feature of a document, this is a document domain structure. The <db:code>list</db:code> container has no media-domain analog.</db:para>
<db:para>Once we have a <db:code>list</db:code> structure, we can create rules – in a separate file – about how lists are formatted. We are familiar with this from <db:indexterm><db:primary>HTML</db:primary></db:indexterm>HTML and CSS. Here’s that same structure in <db:indexterm><db:primary>HTML</db:primary></db:indexterm>HTML (actually, this is a slightly more specific structure, but we’ll get to that):</db:para>
<db:programlisting language="HTML">
&lt;ol&gt;
    &lt;li&gt;Carrots&lt;/li&gt;
    &lt;li&gt;Celery&lt;/li&gt;
    &lt;li&gt;Onions&lt;/li&gt;
&lt;/ol&gt;
</db:programlisting>
<db:para>Now that we have a distinct list object, we can factor out our invariant list formatting rule into a separate file. For HTML, this is usually done with a CSS stylesheet:</db:para>
<db:programlisting language="CSS">
li:first-child 
{
    padding-top: 5pt;
}
</db:programlisting>
<db:para>Now the spacing-above-lists decision has been partitioned off and assigned to an algorithm. This better distributes the complexity of content creation by asking the author to express a simple idea in terms that are known to them – this is a list – instead of a complex set of formatting instructions.</db:para>
<db:para>While introducing the concept of a list structure has added a little bit to the total complexity of our content system, and has required our authors to learn a little bit of new complexity, we are more than compensated for this by the fact that a much larger piece of complexity has been partitioned off and assigned to an algorithm (which will be much more consistent about it than any author ever was), and the total amount of complexity vying for the author’s limited store of attention has been reduced.</db:para>
<db:para>But wait! That’s fine if all lists are formatted exactly the same way, but we know that is not true. At very least, some lists are bulleted and some are numbered. And then there are nested lists, which are formatted differently from their parents, and specialized lists, like lists of ingredients, definitions, or function parameters. If we are going to create list structures in the <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain rather than applying list styles in the <db:indexterm><db:primary>media domain</db:primary></db:indexterm>media domain, how do we make sure each of these types of lists gets formatted appropriately?</db:para>
<db:section>
<db:title>Extensibility</db:title>
<db:para>At this point it is worth looking at a very important feature of all structured writing systems: extensibility. In <db:indexterm><db:primary>media-domain</db:primary></db:indexterm>media-domain word processing and desktop publishing programs, authors may need many different styles to format their documents, and these applications do not attempt to anticipate or provide all the styles every author might need. Some, like Word, come with a basic set of styles that may meet some basic needs, but all these programs let authors define new styles as well. The set of document domain structures in these programs is small and fixed, but the set of media domain styles is extensible – you can create as many as you need.</db:para>
<db:para>A word processor or desktop publishing application that supports the definition of styles is essentially creating an extensible media domain environment. Styles are media domain structures that partition out a set of style information that you can attach to a block of text to specify how it will be displayed. Every time you create a new style you are extending your set of media domain structures.</db:para>
<db:para>This need for extensibility is another common pattern in structured writing. If you are working in the media domain, you may need to extend your set of styles. If you are working in the document domain, you may need to extend your set of <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain structures.</db:para>
<db:para>How many types do we need? One obvious formatting difference between lists is that some are numbered and some are bulleted. How does a formatting algorithm tell whether to use bullets or numbers to format a given list? One way would be to add a style attribute to specify bullets or numbers, but then the author would be working in the media domain again, breaking the partitioning we had hoped to achieve. To keep the author in the document domain, we need to create document domain structures that expresses different list types at the doc domain level.</db:para>
<db:para>The common way to handle bullets vs. numbers is to create two different list structures, the ordered list and the unordered list. Different markup languages call them by different names – <db:code>ol</db:code> and <db:code>ul</db:code> in HTML, <db:code>orderedlist</db:code> and <db:code>itemized-list</db:code> in DocBook, for example – but they are conceptually the same thing. (Thus the HTML example above is a little more specific than just being a list structure. It is an ordered list structure.)</db:para>
<db:para>The choice of the terms “unordered” and “ordered” is important, because it focuses on the <db:indexterm><db:primary>document-domain</db:primary></db:indexterm>document-domain properties of a list – whether its order matters – rather than on its <db:indexterm><db:primary>media domain</db:primary></db:indexterm>media domain properties – bullets or numbers. Whether an ordered list should be formatted with numbers or letters or Roman numerals, belongs entirely to the <db:indexterm><db:primary>media domain</db:primary></db:indexterm>media domain. It has been partitioned out of the <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain structures.</db:para>
</db:section>
<db:section>
<db:title>Context and Structure</db:title>
<db:para>Does the need for separate ordered and unordered list objects imply that we will need a separate document domain list structure for every possible way a list could be formatted in the media domain? No. In fact, that would really just be working in the media domain by proxy. When we work in the document domain we are specifically thinking in terms of document structures, not formatting, and so each document domain object we create needs to make sense in document domain terms, not media domain terms. Otherwise, the partitioning of the problem falls apart.</db:para>
<db:para>For example, consider nested lists. Items in a nested list are formatted differently from the list that contains them. At minimum they are indented more and usually they have different number and bullet styles as well. In the <db:indexterm><db:primary>media domain</db:primary></db:indexterm>media domain, we would need a different style for each level. However, we don’t need a separate nested list structure in the <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain. Instead, we express the fact that a list is nested by actually nesting it inside its parent list. For instance, we can nest one ordered list inside another ordered list:</db:para>
<db:programlisting language="HTML">
&lt;ol&gt;
    &lt;li&gt;
        &lt;p&gt;Dogs&lt;/p&gt;
        &lt;ol&gt;
            &lt;li&gt;Spot&lt;/li&gt;
            &lt;li&gt;Rover&lt;/li&gt;
            &lt;li&gt;Fang&lt;/li&gt;
            &lt;li&gt;Fluffy&lt;/li&gt;
        &lt;/ol&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;p&gt;Cats&lt;/p&gt;
        &lt;ol&gt;
            &lt;li&gt;Mittens&lt;/li&gt;
            &lt;li&gt;Tobermory&lt;/li&gt;
        &lt;/ol&gt;
    &lt;/li&gt;
&lt;/ol&gt;
</db:programlisting>
<db:para>In the <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain the inner and outer list are both identical <db:code>ol</db:code>/<db:code>li</db:code> structures. In the <db:indexterm><db:primary>media domain</db:primary></db:indexterm>media domain, one will be formatted with Arabic numerals and the other with letters.</db:para>
<db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/nested-list.svg" contentwidth="2in" align="left"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/nested-list.png"/></db:imageobject><db:textobject><db:para>Showing how a nested list is formatted in a browser.</db:para></db:textobject></db:mediaobject>
<db:para>Both the inner and outer lists are ordered list items in the document domain, but in the media domain they are formatted differently based on context.</db:para>
<db:para>In this case, the algorithm that formats the page distinguishes the inner and outer lists by looking at their parentage. For instance in CSS:</db:para>
<db:programlisting language="css">
ol&gt;li&gt;ol&gt;li
{
    list-style-type: lower-alpha;
}
</db:programlisting>
<db:para>This ability to distinguish structures by context is vital to structured writing. It enables us to reduce the number of structures we need to fully describe our content, particularly in the document and subject domains. It also allows us to name structures more logically and intuitively, since we can name them for what they are, not how they are to be formatted or for where they reside in the hierarchy of the document as a whole.</db:para>
<db:para>It also points out another important difference between the way media domain and document domain writing is usually implemented. The media domain almost always uses a flat structure with paragraphs, tables, etc. following one after the other in sequence. For instance, a nested list in Word is constructed as a flat sequence of paragraphs with different styles. Inner and outer lists are expressed purely by the indent applied to the paragraphs. (Word tries to maintain auto-numbering across such listed nest structured, but does not always get it right.)</db:para>
<db:para>In the document domain, document structures are usually implemented hierarchically. List items are <db:emphasis>inside</db:emphasis> lists. Nested lists are <db:emphasis>inside</db:emphasis> list items. Sections are <db:emphasis>inside</db:emphasis> chapters. Subsections are sections <db:emphasis>inside</db:emphasis> other sections. Where the media domain typically only has before and after relationships (except in tables), the document domain typically adds inside/outside relationships to the mix. This use of nested, rather than flat, structures helps to create context, which helps to reduce the number of different structures you need. Just as we saw with the basic list structure, there nested structures help partition logical document structures so that we can distribute the complexity of their formatting to algorithms.</db:para>
<db:para>Some <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain languages are more hierarchical than others. <db:indexterm><db:primary>HTML</db:primary></db:indexterm>HTML is relatively flat in structure. For example, it has six different heading styles <db:code>H1</db:code> through <db:code>H6</db:code>. Docbook, a widely used <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain structured writing language, is much more hierarchical in structure and has only one element for the same purpose: <db:code>title</db:code>. But DocBook’s <db:code>title</db:code> element can occur inside 84 different elements, and therefore can potentially be formatted in 84 different ways based on context. In fact, it can potentially be formatted in more ways than that, since some of the elements that contain it can also be nested in other elements, creating a hierarchical structure that provides even more contexts.</db:para>
<db:para>There is a balance to be struck here, however. Hierarchical structures are harder to create and can be harder to understand. Often they require the writer to find just the right place in a hierarchy to insert a new piece of content, which is more difficult that simply starting a new paragraph in a word processor. The partitioning they provide also introduces complexity into the writer’s world, and we need to be vigilant to make sure that we are not introducing more complexity to the author than we are taking away.</db:para>
</db:section>
<db:section>
<db:title>Constraining document structure</db:title>
<db:para>There are other reasons for working in the <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain beside partitioning out formatting rules. One of the main ones is to constrain how documents are structured. For example, lets say that you want to make sure that all graphics inserted into your documents have a figure number, a title, and a caption. This is a document domain constraint rather than a <db:indexterm><db:primary>media domain</db:primary></db:indexterm>media domain constraint. The requirement for a graphic to have a figure number, title, and caption is one of document structure and organization and does not say anything about how the title or caption should be formatted.</db:para>
<db:para>In the <db:indexterm><db:primary>media domain</db:primary></db:indexterm>media domain, you can make styles available for figure-numbers, titles, and captions, but you can’t enforce a rule that says all graphics must have these elements (which is, by its very nature, a <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain rule). In the document domain, you can express these constraints. You can literally make sure that the only way to include a graphic is to make it a figure and give it a title and a caption by making it illegal to place an image element anywhere else in the document structure. A structure that implemented this constraint might look like this:</db:para>
<db:programlisting language="SAM">
figure:
    title: Cute kitty
    caption: This is a cute kitten.
    image: images/cute.jpg
</db:programlisting>
<db:para>If the only way to include an image is to use the image element, and the only place where the image element is allowed is inside the figure element, and if the title and the caption elements are required and must have content, then there is no way for a writer to add a graphic without a figure, title, and caption. A document that lacked these elements would be rejected by the <db:indexterm><db:primary>conformance algorithm</db:primary></db:indexterm>conformance algorithm (see <db:xref linkend="chapter.conformance"/>).</db:para>
<db:para>This is an example of a constraint being enforced rather than factored out. But it is still a form of partitioning because we have created a partition for figures which is the only place images are allowed. This partitions off the design question about image handling. While the writers still has to execute the decision, there is only one decision they can make. With the list formatting we could partition out the formatting constraint completely by separating the formatting information from the list structure. Here we enforce the image constraint by providing a specific structure that must be used to insert images.</db:para>
<db:para>There are many ways in which you might want to constrain the structure of a document. In a typical <db:indexterm><db:primary>media domain</db:primary></db:indexterm>media domain application, there is no restrictions on the order in which paragraph styles can be applied. If you want to put a level two heading between two steps in a procedure, nothing other than common sense will stand in the way of your doing so. In a document domain language, however, that kind of thing will usually not be allowed.</db:para>
<db:para>Instead, the <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain language will have a set of constraints on how procedures are structured. Procedure structures will have step structures nested within them. Step structures will only be allowed to appear inside procedure structures. Only certain text elements – such as paragraphs, lists, or code blocks – will be allowed to occur inside a step. There will be no way to place a second level heading inside a procedure.</db:para>
<db:para>Constraints like these are important to document domain languages. If you want to control how procedure are written, or how graphics are labeled, you need to create specific document domain structures for these things, and  constrain them to avoid them being misused. Without such constraints, it is easy for a language to slip back into the media domain, something that has happened to HTML.</db:para>
<db:para>Today, structured writing advocates often dismiss HTML as an unstructured language. They will point to other languages, such as DocBook or DITA, as being structured by contrast, despite the fact that all three languages are document domain languages at heart with many similar structures between them.</db:para>
<db:para>And while it was not always so, HTML has largely become a set of basic document domain structures that authors can hang styles on (using CSS). In other words, it has come to be used much like traditional media-domain word processing and desktop publishing applications, with writers taking back into their own hands formatting decisions that were supposed to be removed from them.</db:para>
<db:para>Why did this happen? When people write in HTML, they largely do so in WYSIWYG environments, using style-oriented tools that mimic traditional word processing very closely. In other words, HTML may be a document domain language, but people commonly create it using media domain tools. The result is often an HTML document that formats more or less correctly, but that is coded very inconsistently from the point of view of the document domain, and which is thus very hard to work with – either to edit by hand or manipulate with algorithms.</db:para>
</db:section>
<db:section>
<db:title>Extending the document domain</db:title>
<db:para>Another factor in HTML’s slide into the media domain is that it provides only a fairly basic set of document domain structures. As we have seen, enforcing or factoring out media domain constraints requires specific document domain structures. But the possible list of such structures is quite large. There are a few basic features that are common to all documents, such as paragraphs, lists, and titles. But these structures alone are not enough to hang meaningful and useful document domain constraints on, or to fully partition the content of a document from its formatting, which is why, as we noted above, extensibility is an important part of all structured writing domains.</db:para>
<db:para>For example, think about a bibliography. A bibliography is a document structure for listing works cited in or recommended by a document. It generally consists of a heading “Bibliography” followed by a set of paragraphs listing the cited works. In the media domain, it is not a particularly complicated structure to create. It is just a sequence of paragraphs with some bold and italic formatting for author names, book titles, etc.</db:para>
<db:para>In your media domain stylesheet, you may have some character styles for things like author-name or book-title. You may even have a specific paragraph style for bibliography entries, but it is unlikely to be more complicated than that.</db:para>
<db:para>But these few styles don’t really cover all the rules for creating bibliographies that your organization or publisher is likely to insist on. There are rules for the presentation of a bibliography entry which go into detail about how each work and its authors are listed and how the listings are presented. These are constraints on the writing of the bibliography that the author has to follow, but which are not modeled by the media domain styles they are working with. The authors have to learn and follow these constraints for themselves. If you want to relieve them of these decisions, you need a document domain structure for a bibliography. <db:indexterm><db:primary>DocBook</db:primary></db:indexterm>DocBook has one:</db:para>
<db:programlisting language="docbook">
&lt;biblioentry id="bib.xsltrec"&gt;
  &lt;abbrev id="bib.xsltrec.abbrev"&gt;REC-XSLT&lt;/abbrev&gt;   
  &lt;editor&gt;
     &lt;firstname&gt;James&lt;/firstname&gt;
     &lt;surname&gt;Clark&lt;/surname&gt;
  &lt;/editor&gt;
  &lt;title&gt;
    &lt;ulink url="http://www.w3.org/TR/xslt"&gt;XSL Transformations
    (XSLT) Version 1.0&lt;/ulink&gt;
  &lt;/title&gt;
  &lt;publishername&gt;W3C Recommendation&lt;/publishername&gt;
  &lt;pubdate&gt;16 November 1999&lt;/pubdate&gt;
&lt;/biblioentry&gt;
</db:programlisting>
<db:para>The example is in XML, which can be hard to read, so here is the same structure the markup notation that I have used in earlier examples:</db:para>
<db:programlisting language="SAM">
biblioentry:(#bib.xslttrec)
    abbrev:(#bib.xsltrec.abbrev) REC-XSLT
    editor:
        firstname: James 
        surname: Clark
    title: XSL Transformations (XSLT) Version 1.0
    publishername: W3C Recommendation
    pubdate: 16 November 1999
</db:programlisting>
<db:para>This structure does not just constrain how bibliography entires are presented and formatted, it actually factors out many of those constraints by breaking down the components of a bibliography entry into separate labeled fields. Given a <db:code>biblioentry</db:code> structure like this, you could create an algorithm to present and format a bibliography entry almost any way you wanted to. This means that this structure not only partitions the formatting of the bibliography from the presentation of the bibliography, it also partitions the presentation from the underlying bibliographical data from the presentation. This means you could write an algorithm to extract bibliography information from a document by looking for <db:code>biblioentry</db:code> structures and extracting the desired information from them. For instance, if you want to build a list of authors cited in the document, you could do so by searching the <db:code>biblioentry</db:code> records and extracting the name of the authors from the structures that record them in the bibliography structure.</db:para>
<db:para>This begins to hint at the sort of things we can do with our content when we move to the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm>subject domain.</db:para>
</db:section>
<db:indexterm class="endofrange" startref="idm442841212"/><db:indexterm class="endofrange" startref="idm442834300"/><db:indexterm class="endofrange" startref="idm442832892"/><db:indexterm class="endofrange" startref="idm442841212x"/><db:indexterm class="endofrange" startref="idm442834300x"/><db:indexterm class="endofrange" startref="idm442832892x"/></db:chapter>
