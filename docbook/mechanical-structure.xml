<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.mechanical-structure"><db:title>Content as data</db:title>



<db:para>Structured writing represents content as data in order to make it accessible to algorithms. Conventional computer data structures such as relational database tables do not work well for content because they are too regular to fit the shape of content. Creating structures that are regular enough for algorithms to deal with yet irregular enough to fit the rhetorical patterns of written language is a challenging problem.</db:para>
<db:para>Fundamentally, a document is just a stream of characters. However, that stream of characters contains rhetorical structures such as headings, bibliographical entries, bold text, chapters, ingredient lists, links, wine matches, tables, function signatures, and labeled lists. In addition, you may need to annotate <db:indexterm><db:primary>subject affinities</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject affinities</db:secondary></db:indexterm>subject affinities and attach management metadata. The question is, how do you express these various structures within the raw stream of characters?</db:para>
<db:para>The most common answer is to divide the text into a series of blocks, divide those blocks into smaller blocks, and continue dividing until all the structures you need are contained in blocks. This is not the only way to do it. Some file formats, such as WordPerfect, use independent stop and start markers to delineate structures, meaning that the boundaries of structures can overlap. But while this kind of structure can work in the media domain, it is difficult for structured writing algorithms to work with such structures. Therefore, most structured writing today uses the nested block approach.<db:footnote>
<db:para>It is technically possible to implement independent stop and start markers, even in languages that are mainly block based. You simply define empty blocks for the start and stop markers. Both DITA and DocBook do this to delineate arbitrary bits of content for reuse and to define arbitrary spans of content for indexing. I recommend against this practice in content that has a lifespan beyond its first publication.</db:para>
</db:footnote></db:para>

<db:para>There are cases where non-overlapping block structure is inadequate for some rhetorical structures. This is more of an issue for the academic study of texts than for structured writing, but it can occur in both fields. However, allowing overlapping fields adds complexity to many of the structured writing algorithms, and it is rarely a worthwhile approach to partitioning content.</db:para>
<db:para>For our purposes, therefore, I am going to deal with the mechanical structure of content strictly in terms of nested, non-overlapping blocks, such as shown in <db:xref linkend="fig.block-structure"/>.</db:para>
<db:figure xml:id="fig.block-structure"><db:title>Nested block structure of a recipe</db:title><db:mediaobject><db:imageobject><db:imagedata fileref="../graphics/blocks.svg" contentwidth="5.25in" align="left"/></db:imageobject></db:mediaobject></db:figure>
<db:section>
<db:title>Flat vs. hierarchical structures</db:title>

<db:para>Even using a strictly nested blocks approach requires some fundamental choices about mechanical structure. The first is flat vs. hierarchical structure.</db:para>
<db:para>As noted in <db:xref linkend="chapter.document-domain"/>, HTML has six levels of heading (<db:code>h1</db:code> through <db:code>h6</db:code>), whereas <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook has only <db:code>title</db:code>. DocBook lets you divide a document into sections and nest sections inside sections. You can then print the titles of sections inside sections in a smaller font than the titles of first-level sections. You can render headings in different sizes without having six different tags.</db:para>
<db:para>But the DocBook model assumes that the real structure of a document is a hierarchy of nested sections and that the size of titles announces the steps up and down that hierarchical tree. HTML makes no such assumption. It will let you put an <db:code>&lt;h4&gt;</db:code> immediately after an <db:code>&lt;h1&gt;</db:code> if you want to. It treats documents as essentially flat structures punctuated by headings of various sizes.</db:para>
<db:para>Which model of a document is correct? Which corresponds best to the rhetorical structure of the document? You can think of a document as being organized hierarchically, with major ideas expressed in sections, sub-ideas supporting the major ideas in subsections, etc. There are many documents that fit that model. But you can also think of documents as being more like a journey in which headings function like road signs. A city gets a big sign, a hamlet a small sign, and a town a medium sign. But the town is not inside the city, the hamlet is not inside the town, and there is no guarantee that on leaving the city you will come to a town before you come to a hamlet.</db:para>
<db:para>Studies by Peter Flynn indicate that most writers think of documents much more in terms of a punctuated linear model (a journey) than a hierarchical model.</db:para>
<db:blockquote>
<db:attribution>Flynn2009</db:attribution>
<db:para>The classical theory, derived from computer science and graph theory, is that the document is a hierarchical tree (actually inverted: a root-system) and that all necessary actions can be seen in terms of navigation around the tree, and of insertion into and withdrawal from the the nodes which form the branches and leaves.</db:para>
<db:para>The conventional writer, however — and we expressly exclude the markup expert, as well as the experienced technical writers who responded to the survey — is by repute probably only marginally aware of this tree; but we have been unable to measure this at present. In this view, the document is seen as a continuous linear narrative, broken into successive divisions along semantic lines, and interspersed with explanatory material in the form of figures, tables, lists, and their derivatives.</db:para>
</db:blockquote>
<db:para>As Flynn’s research illustrates, there is a good chance that writers don’t think of their arguments as a strict hierarchy of points. Rather, they think of them as a sequence of points with headings occasionally inserted to break up the text or signal a change in emphasis or subject matter.</db:para>
<db:para>To clearly define the rhetorical structure of a document, you have to divide it into blocks such as introduction, ingredients, and preparation. And, as previously noted, treating these parts of the rhetorical structure as blocks is essential to establishing a context where blocks can be identified and processed by algorithms.</db:para>
<db:para>Some semantic and rhetorical blocks are naturally more hierarchical than others. Even so, structured writing forces writers to think more hierarchically than they might otherwise, which means imposing a little bit of complexity on them to support all the partitioning and redirection of complexity needed for the content system overall. However, there is no need to do any more of this than the partitioning system demands.</db:para>
<db:para>If the structured writing <db:indexterm><db:primary>constraints</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>constraints</db:secondary></db:indexterm>constraints that you need to express demand hierarchy, while <db:indexterm><db:primary>functional lucidity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functional lucidity</db:secondary></db:indexterm>functional lucidity demands a more punctuated linear model, how do you design a markup language that reconciles these two opposing requirements?</db:para>
<db:para>This is of greatest concern in the design of <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain languages. The structure of <db:indexterm><db:primary>media-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media-domain</db:secondary></db:indexterm>media-domain languages follows the shape of the media they are modeling, which is largely flat. In the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, content has been abstracted out of strict document order, which means that hierarchy in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain tends to match the hierarchy of relationships in the subject matter itself.<db:footnote>
<db:para>This is not universal. For example, addresses, which are based on hierarchical locations, are typically modeled as flat ordered lists. The order reflects the hierarchy, but the structure does not nest city inside country and street inside city.</db:para>
</db:footnote> In the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, however, this is a real concern. The document domain consists of abstractions of document structures and the nature of their relationship to the structure of thought in the text is not obvious.</db:para>

<db:para>Outside of the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain, the options available are:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Use a flat <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain language. Examples are HTML and Markdown. The problem here is that a flat language imposes few constraints, and the lack of context-setting hierarchy makes it hard to model different types of document structures without creating hundreds of tags, which negates any <db:indexterm><db:primary>functional lucidity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functional lucidity</db:secondary></db:indexterm>functional lucidity that you gain by keeping the language flat.</db:para>
</db:listitem>
<db:listitem>
<db:para>Use a hierarchical <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain language that has a permissive structure, so you can put blocks inside blocks in lots of different ways. An example of this is <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook. The problem here is that the permutations make writing algorithms difficult, and you often need to impose additional writing constraints that go beyond those expressed or enforced by the markup itself. This again diminishes <db:indexterm><db:primary>functional lucidity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functional lucidity</db:secondary></db:indexterm>functional lucidity and compromises <db:indexterm><db:primary>conformance</db:primary></db:indexterm><db:indexterm><db:primary>process</db:primary><db:secondary>conformance</db:secondary></db:indexterm>conformance. (An interesting property of this approach is that the flexibility of the language means that writers can create documents that are very hierarchical or very flat. However, this is not really a virtue, because it is not clear how this choice contributes to improved content quality.)</db:para>
</db:listitem>
<db:listitem>
<db:para>Create a smaller, stricter document-domain language that fits the types of documents you want to write. The main difficulty with this approach is that you have to design your own language, which many organizations try to avoid. (In some cases you can reduce this effort by using a restricted subset of an existing language such as <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook, something we will look at in <db:xref linkend="chapter.extensible"/>.)</db:para>
</db:listitem>
<db:listitem>
<db:para>Move content creation to the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain. This also involves creating your own languages, but it can provide support for rhetoric and process while improving functional lucidity.</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>

<db:section>
<db:title>Annotating blocks</db:title>

<db:para>When treating content as data, you annotate every block to identify – to people and algorithms – what constraints it meets. The most basic annotation is the name of the block, which describes its type. The name of a table block is <db:code>table</db:code>, which tells us that the block is a table. Blocks may also have other annotations that either refine the type or provide additional information.</db:para>
<db:para>These additional annotations don’t have to be in the same domain as the block name. <db:xref linkend="fig.mechanical-wine"/> repeats an example of this from <db:xref linkend="chapter.subject-domain"/>.</db:para>
<db:figure xml:id="fig.mechanical-wine"><db:title>Conditional text markup (XML)</db:title><db:programlisting language="xml">
&lt;section publication="Wine Weenie"&gt;
    &lt;title&gt;Wine match&lt;/title&gt;
    &lt;p&gt;Pinot Noir&lt;/p&gt;
&lt;/section&gt;
&lt;section publication="The Teetotaler's Trumpet"&gt;
    &lt;title&gt;Suggested beverage&lt;/title&gt;
    &lt;p&gt;Lemonade&lt;/p&gt;
&lt;/section&gt;
</db:programlisting></db:figure>
<db:para>In <db:xref linkend="fig.mechanical-wine"/>, the <db:code>section</db:code> element defines a block in the document domain, and the <db:code>publication</db:code> attribute adds an annotation in the management domain.</db:para>
</db:section>
<db:section>
<db:title>Agreeing on names</db:title>

<db:para>For structured writing to work, everyone involved must understand and agree on what the names and annotations mean. Annotations tell people and processes what constraints each block obeys. If the names and annotations don’t mean what we have all agreed to, communication between the partitions of the content system breaks down and both process and rhetoric suffer.</db:para>
<db:para>Confusion and disagreement about the meaning of names and annotations are not uncommon. Large document-domain languages such as <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook and <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA have large vocabularies, and many of the names they offer are quite abstract. Questions about the right way to tag certain passages are common in the communities around these languages, and opinions can vary considerably in some cases.</db:para>
<db:para>These disagreements don’t affect just low-level structures. In <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA, for example, it is common to debate whether a topic that contains operational information, but is not procedural, is a concept or a task. And some writers use only generic topics because they don’t think DITA’s task, concept, and reference topics fit their content.</db:para>
<db:para>Therefore, you must define terms precisely when developing a structured writing language. But it is equally important that the language be <db:indexterm><db:primary>functionally lucid</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functionally lucid</db:secondary></db:indexterm>functionally lucid. <db:indexterm><db:primary>Functional lucidity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>Functional lucidity</db:secondary></db:indexterm>Functional lucidity requires you to create structures that do not detract from writing. You can’t meet this requirement if writers must puzzle out or debate the right way to mark something up. Not only must you define what the names mean, but you must also choose structures that are easy to name correctly. As I describe in <db:xref linkend="chapter.conformance"/>, the best way to achieve conformance is to design structures that are easy to conform to.</db:para>
</db:section>
<db:section>
<db:title>Different rules for intermediate languages</db:title>

<db:para>Of course, functional lucidity only matters for the formats that writers actually write in. As we have seen, the <db:indexterm><db:primary>publishing algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publishing algorithm</db:secondary></db:indexterm>publishing algorithm typically consists of multiple steps, and each one of those steps can create a format that is closer to the media domain than the one before it. It is perfectly possible to design a document-domain structure just to serve as a step in the publishing chain. Separate authoring formats are created for writers to actually write in (perhaps <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain formats or simplified highly constrained ad-hoc document-domain formats). Content is transformed from these formats to the document-domain format by the <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>presentation algorithm</db:secondary></db:indexterm>presentation algorithm and then the document-domain format is translated into various different media-domain languages by the formatting software. An arrangement like this eliminates the need to compromise between different demands in designing a single language, generally making each language in the chain simpler and more constrained, which in turn makes each one easier to <db:indexterm><db:primary>validate</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>validate</db:secondary></db:indexterm>validate and process.</db:para>
</db:section>
<db:section>
<db:title>Secondary structures of interpretation</db:title>

<db:para>Under normal circumstance, the structures that constrain content also constrain the interpretation of that content. In other words, the markup that tells the writer what to write also tells the algorithm (or other downstream user) what the content means. But there are cases where annotations are added to document-domain structures to tell downstream processes what the content means. These structures don’t constrain writers, which means they don’t guide them either. Writers must know exactly how to create this kind of annotation without any guidance or prompting.</db:para>
<db:para>Consider these examples of HTML microformats from Wikipedia.<db:footnote><db:para>https://en.wikipedia.org/wiki/Microformat</db:para></db:footnote> <db:xref linkend="fig.mechanical-address"/> shows an address formatted as a list.</db:para>
<db:figure xml:id="fig.mechanical-address"><db:title>HTML microformat markup for an address</db:title><db:programlisting language="HTML">
&lt;ul&gt;
   &lt;li&gt;Joe Doe&lt;/li&gt;
   &lt;li&gt;The Example Company&lt;/li&gt;
   &lt;li&gt;604-555-1234&lt;/li&gt;
   &lt;li&gt;
     &lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt;
   &lt;/li&gt;
&lt;/ul&gt;
</db:programlisting></db:figure>
<db:para>In <db:xref linkend="fig.mechanical-address"/>, the phrase “The Example Company” is contained in <db:code>li</db:code> tags. This is part of a list structure delineated by <db:code>ul</db:code> tags, so the markup is largely structural in the document domain. The <db:code>li</db:code> does not tell you what the content itself is about. It does not tell you anything useful beyond what document structure it belongs to.</db:para>
<db:para>The second example, <db:xref linkend="fig.mechanical-vcard"/>, adds vCard microformat markup:</db:para>
<db:figure xml:id="fig.mechanical-vcard"><db:title>vCard microformat markup for an address</db:title><db:programlisting language="HTML">
&lt;ul class="vcard"&gt;
  &lt;li class="fn"&gt;Joe Doe&lt;/li&gt;
  &lt;li class="org"&gt;The Example Company&lt;/li&gt;
  &lt;li class="tel"&gt;604-555-1234&lt;/li&gt;
  &lt;li&gt;
    &lt;a class="url" href="http://example.com/"&gt;
       http://example.com/
    &lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</db:programlisting></db:figure>
<db:para><db:xref linkend="fig.mechanical-vcard"/> adds subject-domain metadata in the form of the class attributes. For example, it says that the phrase “The Example Company” refers to an organization (<db:code>org</db:code>). This annotation does not modify or refine the constraint expressed by the <db:code>li</db:code> tag. It is saying something else entirely.</db:para>
<db:para>But this is not just about suggesting a different way of interpreting “The Example Company” (as an organization name, as well as as a list item).  The vCard markup expresses a complex <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain structure. Not only is the list item <db:code>The Example Company</db:code> annotated as <db:code>org</db:code>, the list that contains it is annotated as <db:code>vcard</db:code>. The interpretation of <db:code>org</db:code> actually depends on that annotation being part of a <db:code>vcard</db:code> structure.</db:para>
<db:para>In other words, the secondary structure created by the annotations in the <db:xref linkend="fig.mechanical-vcard"/> is equivalent to the pure subject-domain markup shown in <db:xref linkend="fig.mechanical-subject"/>.</db:para>
<db:figure xml:id="fig.mechanical-subject"><db:title>Subject-domain markup for an address</db:title><db:programlisting language="SAM">
vcard:
   fn: Joe Doe
   org: The Example Company
   tel: 604-555-1234
   url: http://example.com/
</db:programlisting></db:figure>
<db:para>The microformats overlay a second structure on the list structure. In the world of HTML, this makes sense. HTML needs to be a standardized <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain language so that browsers can display it for human reading. Humans don’t need the vCard annotations to recognize that the content is an address, but algorithms do. So the microformat adds a second, hidden, <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain structure to the document for readers that are algorithms rather than people.</db:para>
<db:para>Structured writing constrains both the creation and the interpretation of content. Normally, you expect that the creation of content would be just as constrained as the interpretation. After all, it is hard to reliably interpret structure if the creation of that structure is not constrained. However, in this case the interpretation of the data is more constrained than the creation.</db:para>
<db:para>Asking writers to add unconstrained <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain metadata to <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain structures would be inefficient and error prone. But this is only a problem if we ask writers to author in this format. If writers author in a format that constrains creation to the same extent that we need to constrain output, it does not actually matter that the resulting output constrains interpretation more than it constrains creation. Our concern as content creators is simply to make sure that any content we produce that promises to abide by a constraint actually does so, whether the format we deliver it in actually imposes that constraint or merely annotates it.</db:para>
<db:para>So, you can confidently produce this information using subject-domain markup and then deliver it as HTML with vCard annotation markup using a presentation algorithm like <db:xref linkend="fig.mechanical-subject-2"/> (as with all example algorithms in this book, this example is pseudocode):</db:para>
<db:figure xml:id="fig.mechanical-subject-2"><db:title>Pseudocode to convert subject-domain address markup to vCard format</db:title><db:programlisting language="pseudo">
match vcard
    create ul
        attribute class = "vcard"
        continue

match fn
    create li
        attribute class = "fn"
        continue

match org
    create li
        attribute class = "org"
        continue

match tel
    create li
        attribute class = "tel"
        continue

match url
    create li
        create a
            attribute class = "url"
            attribute href = contents
            continue
</db:programlisting></db:figure>
</db:section>
<db:section>
<db:title>Child blocks vs. additional annotations</db:title>

<db:para>As noted above, sometimes the name of a block is not sufficient to fully describe the constraints it meets. In these cases, you can add additional annotations to a block. But you can also achieve much the same thing by adding child blocks. A child block belongs to the main block, so it is part of it and can constrain the interpretation of the main block just as much as an annotation does. One of the issues in designing data structures for content, therefore, is deciding when to use additional annotations and when to use child blocks.</db:para>
<db:para>Different markup languages have different levels of support for additional annotation on blocks, so this issue is affected by the markup language you choose. SAM, for instance, supports only a limited, fixed set of additional annotations on blocks. Therefore, if you want to add constraints on interpretation, you have to use child blocks.</db:para>
<db:para>In XML, however, there is broad (though not unlimited) support for additional annotations on blocks in the form of attributes. In the XML world there is considerable choice, and considerable debate, about when and where to use elements vs. attributes in your content models.</db:para>
<db:para>Consider, for example, this XML element that contains two attributes but no content:</db:para>
<db:programlisting language="xml">
&lt;author-name first="Mark" last="Baker"&gt;
</db:programlisting>
<db:para>The element is called <db:code>author-name</db:code>, and it has two attributes, <db:code>first</db:code> and <db:code>last</db:code>, which contain my first and last name respectively.</db:para>
<db:para>Why is this marked up like this and not like this:</db:para>
<db:programlisting language="xml">
&lt;author-name&gt;
    &lt;first&gt;Mark&lt;/first&gt;
    &lt;last&gt;Baker&lt;/first&gt;
&lt;/author-name&gt;
</db:programlisting>
<db:para>Both of these constructs express the same information, and both clearly constrain how you mark up an author’s name and how algorithms should interpret that markup.</db:para>
<db:para>Is one of these options correct and the other incorrect? When should you use attributes and when should you use elements?</db:para>
<db:para>Consider our vcard example. You could write it this way, using just elements:</db:para>
<db:programlisting language="XML">
&lt;vcard&gt;
   &lt;fn&gt;Joe Doe&lt;/fn&gt;
   &lt;org&gt;The Example Company&lt;/org&gt;
   &lt;tel&gt;604-555-1234&lt;/tel&gt;
   &lt;url&gt;http://example.com/&lt;/url&gt;
&lt;/vcard&gt;
</db:programlisting>
<db:para>Or you could write it this way, using attributes:</db:para>
<db:programlisting language="XML">
&lt;vcard
   fn="Joe Doe"
   org="The Example Company"
   tel="604-555-1234"
   url="http://example.com/"
/&gt;
</db:programlisting>
<db:para>The first says that <db:code>fn</db:code>, <db:code>org</db:code>, <db:code>tel</db:code>, and <db:code>url</db:code> are independent structures that belong as members to a <db:code>vcard</db:code> structure. The second says that the <db:code>vcard</db:code> structure has a number of data fields – annotations – that complete its meaning.</db:para>
<db:para>Does this distinction matter terribly? Both allow you to get at the information you want. Both constrain the creation and the interpretation of data. There are limits to the version that uses attributes. In XML markup, you can’t have more than one attribute with the same name, whereas you could have more than one child block with the same name (multiple <db:code>tel</db:code> elements for someone with more than one telephone number for instance). Also, XML specifies that attributes are unordered, so you can’t restrain either the order in which writers create them or the order in which the parser reports them to a processing application.</db:para>
<db:para>Given this, you may be wondering why people bother with attributes, since you can do the same things with elements and have both more flexibility and more capacity to impose constraints. Yet people continue to use attributes extensively when designing markup languages in XML.  When people create XML document types for representing data, rather than for writing documents, they almost always use the attribute format, perhaps because it is slightly less verbose and slightly easier to read or, perhaps, because as programmers they are accustomed to representing data as key/value pairs linked with <db:code>=</db:code> signs.</db:para>
<db:para>But for documents it is more complex. To understand why XML even has attributes and why other languages, such as SAM or reStructuredText, also have similar mechanisms for adding annotations to blocks, you need to go back to the original concept of markup as something written onto a manuscript after the fact. In this view, markup is an addition to the text, not part of it. The content of an element is part of the underlying text. Anything you want to add, therefore, cannot be element content, since that would be adding to the text. Everything else has to be added to element definitions as attributes.</db:para>
<db:para>This view is reinforced in the way academics use markup to prepare texts for study. Again, here, the text is preexisting and canonical. The markup is external to the text, and therefore, everything that is external to the original text must be contained in the markup itself (as attributes) and nothing that is part of the original text can be removed or replaced by markup. (This is a form of partitioning in its own right, to serve a particular purpose.) Thus in this fragment (<db:xref linkend="fig.mechanical-Shakespeare"/>) of Shakespeare’s <db:emphasis>All's Well That Ends Well</db:emphasis>, marked up by John Bosak, you can see that the original text is kept perfectly intact.</db:para>
<db:figure xml:id="fig.mechanical-Shakespeare"><db:title>Fragment of Shakespeare’s <db:emphasis>All's Well That Ends Well</db:emphasis> marked up in XML</db:title><db:programlisting language="xml">
&lt;ACT&gt;
  &lt;TITLE&gt;ACT I&lt;/TITLE&gt;
  &lt;SCENE&gt;
    &lt;TITLE&gt;SCENE I. Rousillon. The COUNT's palace.&lt;/TITLE&gt;
    &lt;STAGEDIR&gt;
      Enter BERTRAM, the COUNTESS of Rousillon, HELENA, and LAFEU, 
      all in black
    &lt;/STAGEDIR&gt;
    &lt;SPEECH&gt;
      &lt;SPEAKER&gt;COUNTESS&lt;/SPEAKER&gt;
      &lt;LINE&gt;In delivering my son from me, I bury a second husband.&lt;/LINE&gt;
    &lt;/SPEECH&gt;
    &lt;SPEECH&gt;
      &lt;SPEAKER&gt;BERTRAM&lt;/SPEAKER&gt;
        &lt;LINE&gt;And I in going, madam, weep o'er my father's death&lt;/LINE&gt;
        &lt;LINE&gt;anew: but I must attend his majesty's command, to&lt;/LINE&gt;
        &lt;LINE&gt;whom I am now in ward, evermore in subjection.&lt;/LINE&gt;
    &lt;/SPEECH&gt;
    …
</db:programlisting></db:figure>
<db:para>Had this markup employed the normal refactoring of text into markup described in the discussions about the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document and <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domains, then the number and title of scenes would have been factored out so that instead of:</db:para>
<db:programlisting language="xml">
&lt;SCENE&gt;
    &lt;TITLE&gt;SCENE I. Rousillon. The COUNT's palace.&lt;/TITLE&gt;
</db:programlisting>
<db:para>you might have factored out the scene number and the word “SCENE” like this:</db:para>
<db:programlisting language="xml">
&lt;SCENE&gt;
    &lt;TITLE&gt;Rousillon. The COUNT's palace.&lt;/TITLE&gt;
</db:programlisting>
<db:para>Going further, you might have noted that the introduction of a scene is invariably the name of its location and done this:</db:para>
<db:programlisting language="xml">
&lt;SCENE&gt;
    &lt;LOCATION&gt;Rousillon. The COUNT's palace.&lt;/LOCATION&gt;
</db:programlisting>
<db:para>or even this:</db:para>
<db:programlisting language="xml">
&lt;SCENE location="Rousillon. The COUNT's palace."&gt;
</db:programlisting>

<?dbfo-need height="2in"?>

<db:para>And similarly, you could replace:</db:para>
<db:programlisting language="xml">
&lt;SPEECH&gt;
    &lt;SPEAKER&gt;BERTRAM&lt;/SPEAKER&gt;
</db:programlisting>
<db:para>with the following:</db:para>
<db:programlisting language="xml">
&lt;SPEECH SPEAKER="BERTRAM"&gt;
</db:programlisting>
<db:para>Making a few changes like this in the markup would leave you with only the words actually spoken by the actors as the text of the play and everything else expressed as elements or attributes.</db:para>
<db:para>This actually makes quite a lot of sense, because the stage directions and identification of speakers in a play are metadata that annotates the actor’s words, which are the only things the audience is supposed to hear.</db:para>
<db:para>So is the right way to markup a play to preserve the original printed text – which includes all of the playwright’s metadata – or is it better to separate the playwright’s metadata from the speeches that are the ‘real’ play?</db:para>
<db:para>While these questions may be important for the scholarly study of text, they are not nearly as important for structured writing. Our concern is to partition the task of content creation, which means you can simply choose the format that does that in the most functionally lucid way while ensuring that all the information required by the next partition is accurately captured. The fact that such questions exist, however, helps explain why a markup language like XML is structured the way it is and why so many texts are marked up the way they are – and why so many markup languages are designed the way they are.</db:para>
<db:para>The way we, as practitioners of structured writing, settle these matters is by asking ourselves which approach best supports the structured writing algorithms that we want to implement, always remembering that the reliability of every other algorithm depends on how well writers conform to constraints, which in turn depends on how well the authoring markup language supports conformance and functional lucidity.</db:para>

<?dbfo-need height="3in"?>

<db:para>In none of this is there any reason to be in the least concerned about preserving the canonical nature of a preexisting text. There is no preexisting text. Therefore, there is every reason to prefer sub-structures rather than annotations to express things such as our vCard example. In fact, SAM, which is designed specifically for structured authoring, supports only this format:</db:para>
<db:programlisting language="SAM">
vcard:
   fn: Joe Doe
   org: The Example Company
   tel: 604-555-1234
   url: http://example.com/
</db:programlisting>
<db:para>SAM supports a limited set of annotations on blocks, all of which have predefined meanings. You could, in fact, eliminate annotations on blocks altogether and use child blocks for everything, but I have supported a limited set of common <db:indexterm><db:primary>management-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management-domain</db:secondary></db:indexterm>management-domain block annotations in SAM, mostly to improve functional lucidity.<db:footnote>
<db:para>It is worth noting that XSLT, the language most commonly used to process XML, implicitly assumes that element content in an XML document is the text of the output document and that attributes are not, thus the text of elements passes through to output automatically unless you catch it and suppress it, whereas the text of attributes is ignored unless you catch and output them.</db:para>
</db:footnote></db:para>

<db:para>In summary, when defining the mechanical structure of your structured writing, don’t get hung up on what is text and what is markup. In each domain, text and markup together form a body of constrained content that can be successfully created by a writer and successfully processed by one or more algorithms. Only when you resolve the content all the way to the media domain do you finally have to sort our exactly which characters appear in which order and which decorations you need to represent that content to a particular audience. When we choose to create content in the other domains, it is precisely because we want to exercise more control over these things and to use algorithms to help us create and manage them. Whether some idea or constraint is expressed by text of markup in those domains should be based solely on what works best in those domains.</db:para>
</db:section>
</db:chapter>
