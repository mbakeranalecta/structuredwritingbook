<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.generate"><db:title>Generated Content</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp1469214580"><db:primary>generated content</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1469214580x"><db:primary>concept</db:primary><db:secondary>generated content</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idp1469215604"><db:primary>generating content</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1469215604x"><db:primary>task</db:primary><db:secondary>generating content</db:secondary></db:indexterm>




<db:para>I have mentioned that one of the advantages of the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain is that it allows you to generate different types of rhetoric from a base of subject-domain data. Here, I look at the content generation algorithm in greater depth.</db:para>
<db:para>There is nothing new about generating content. <db:indexterm><db:primary>word processor</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>word processor</db:secondary></db:indexterm>Word processors and <db:indexterm><db:primary>desktop publishing system</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>desktop publishing system</db:secondary></db:indexterm>desktop publishing programs can generate indexes and tables of contents, for instance, and the <db:indexterm><db:primary>content reuse algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content reuse algorithm</db:secondary></db:indexterm>content reuse algorithms in <db:xref linkend="chapter.reuse"/> generate content by combining smaller pieces of content or data to form larger units of content.</db:para>
<db:para>The fundamentals of content generation are pretty simple. You take separate pieces of content and data and combine them to form new content. Thus, when I spoke earlier about storing the ingredients of a recipe as a data structure and using an algorithm to present them as either a table or a list, that was an example of content generation.</db:para>
<db:para><db:xref linkend="fig.generate-pseudocode"/> shows an algorithm to turn that data into a list (again, in pseudocode).</db:para>
<db:figure xml:id="fig.generate-pseudocode"><db:title>Algorithm to turn a recipe data structure into a list</db:title><db:programlisting language="pseudo">
match ingredients
    create ul
        continue
    
match ingredients/record
    create li
        output name
        output [tab]
        output quantity
        if unit is not 'each'
            output [space]
            output unit
</db:programlisting></db:figure>
<db:para><db:xref linkend="fig.generate-w-prep"/> shows an algorithm for interpolating the serving and preptime fields into the introduction of a recipe.</db:para>
<db:figure xml:id="fig.generate-w-prep"><db:title>Algorithm to interpolate serving and preptime into a recipe</db:title><db:programlisting language="pseudo">
match description
    continue
    output 'Preparation time is '
    output /recipe/preptime
    output '. Serves '
    output /recipe/serves
    output '.'

match preptime
    ignore

match serves
    ignore
</db:programlisting></db:figure>
<db:para>But this kind of content generation does not have to confine itself to working within a single document. It can pull content from several files or assemble different collections of content to serve a common rhetorical purpose, such as compiling a low-calorie cook book based on nutrition information in a collection of recipes. And it can generate many of the elements required to build a top-down or bottom-up information architecture.</db:para>
<db:section><db:title>Categorization</db:title>


<db:para>One of the key elements of top-down information architecture is <db:indexterm><db:primary>categorization</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>categorization</db:secondary></db:indexterm>categorization. An <db:indexterm><db:primary>information architect</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>information architect</db:secondary></db:indexterm>information architect develops categories of content and develops an organizational schema (such as a table of contents) based on those categories. This may include levels of subcategories forming a hierarchical categorization scheme.</db:para>
<db:para>Not all categorization is hierarchical, though. In some cases content can be classified on several independent axes, allowing for the development of what is called <db:emphasis><db:indexterm><db:primary>faceted navigation</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>faceted navigation</db:secondary></db:indexterm>faceted navigation</db:emphasis>. The easiest place to see faceted navigation in action is on a used-car site, where you can narrow down your selection using any set of criteria that matter to you, such as selecting blue convertibles or all-wheel drive vehicles with manual transmissions.</db:para>
<db:para>Categorization of content requires metadata to identify which category it belongs to. (Even if you just sort papers into piles, as soon as you put a label on each pile, you are adding metadata, and if you don’t add a label, you will soon forget which pile is which.) Categorization may involve the addition of new metadata or it may rely on metadata that is already attached to the content. This effectively means that your categories are expressed as query statements, and those queries do not have to operate on a single piece of metadata. A query can create a category out of the conjunction of several pieces of metadata. For example, you could create a category of heart-healthy recipes by writing a query that looks at the salt, fat, and calorie metadata of a collection of recipes.</db:para>
<db:para>For content in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, the <db:indexterm><db:primary>metadata</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>metadata</db:secondary></db:indexterm>metadata required to assign a piece of content to a category may be inherent in its subject-domain markup. It is the nature of the subject domain to describe the subject matter. Therefore, any markup that describes the subject matter may already contain the fields you need for categorization. This is one of the attractions of the subject domain: the markup can serve many purposes, which simplifies both markup design and content authoring and often means that you don’t need to create additional structures to support a new algorithm.</db:para>
<db:para>Relying on the <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain <db:indexterm><db:primary>metadata</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>metadata</db:secondary></db:indexterm>metadata already in the content, rather than creating a separate metadata record, can be a tremendous advantage, because it makes submission of content to a <db:indexterm><db:primary>repository</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>repository</db:secondary></db:indexterm>repository so much easier for writers. But, in some cases, it can also avoid the need for a costly <db:indexterm><db:primary>content management system</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>content management system</db:secondary></db:indexterm>content management system, since it allows the <db:indexterm><db:primary>publishing algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publishing algorithm</db:secondary></db:indexterm>publishing algorithm to categorize content at build time without needing a separate metadata store or a separate system to manage categorization. I look more at the role of the content management system in <db:xref linkend="chapter.content-management"/>.</db:para>
</db:section>
<db:section><db:title>Tables of Contents (TOCs)</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp1468998772"><db:primary>table of contents</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1468998772x"><db:primary>concept</db:primary><db:secondary>table of contents</db:secondary></db:indexterm>



<db:para>If you are creating a top-down information architecture, your structured writing system needs to generate <db:indexterm><db:primary>table of contents</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>table of contents</db:secondary></db:indexterm>tables of contents just as a <db:indexterm><db:primary>word processor</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>word processor</db:secondary></db:indexterm>word processor or <db:indexterm><db:primary>desktop publishing system</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>desktop publishing system</db:secondary></db:indexterm>desktop publishing application does.</db:para>
<db:para>Tables of contents can serve different purposes, depending on the nature of the content and the form of the output. Some describe a linear reading order, some provide a <db:indexterm><db:primary>classification</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>classification</db:secondary></db:indexterm>classification scheme for random access to the content, and some simply provide a list of chapters that does not necessarily imply an intended reading order.</db:para>
<db:para>A table of contents may seem like a <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain structure, but it is really more of a <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media-domain structure, for two reasons. First, it contains specific links to specific resources at specific addresses, or specific page numbers in a paper or a virtual paper format such as <db:indexterm><db:primary>PDF</db:primary></db:indexterm><db:indexterm><db:primary>media</db:primary><db:secondary>PDF</db:secondary></db:indexterm>PDF. Second, it is virtually always factored out in <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain <db:indexterm><db:primary>markup language</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>markup language</db:secondary></db:indexterm>markup languages. Tables of contents are not written, they are generated.</db:para>
<db:para>From a structured writing point of view, what matters is how they are generated. In <annotation type="markup-language"><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook</annotation>, for instance, it is typical to write each chapter of a book in a separate <db:code>chapter</db:code> file and then pull them together into a book using a <db:code>book</db:code> file. The order of the table of contents is then determined by the order in which the chapters are listed in the <db:code>book</db:code> file. The table of contents is generated by extracting chapter and section headings from the <db:code>chapter</db:code> files in the order they appear in the <db:code>book</db:code> file.</db:para>
<db:para>In <annotation type="markup-language"><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA</annotation>, the normal process is to assemble a book using a <db:code>map</db:code> file. A map file may assemble a book out of <annotation type="markup-language"><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA</annotation> topics or other maps, and this may include assembling the chapters from topics as well. In the end, though, the <db:indexterm><db:primary>table of contents</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>table of contents</db:secondary></db:indexterm>table of contents is generated in the same way, by traversing the document assembled by the <db:code>map</db:code>.</db:para>
<db:para>In both cases, the order of the TOC is specified by hand by the person who creates the <db:code>book</db:code> or <db:code>map</db:code> file. But there are other ways to determine the order of content in a TOC. For instance, a reference work such as an API reference may be organized by listing each library in order by name and each function in alphabetical order by name within its library, creating a table of content with two levels. You don’t need to write a map or book file to create this table of contents. There is an algorithm for creating this table of contents. In fact, it is the algorithm stated earlier in this paragraph: “listing each library in order by name and each function in alphabetical order by name within its library.” <db:xref linkend="fig.generate-create-toc"/> shows this algorithm in pseudo code.</db:para>
<db:figure xml:id="fig.generate-create-toc"><db:title>Generate a TOC for an API reference</db:title><db:programlisting language="pseudo">
create toc
    for each library sorted alphabetically
        create toc-entry library name
        for each function in library sorted alphabetically
            create toc-entry function name
</db:programlisting></db:figure>
<db:para><db:indexterm><db:primary>table of contents</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>table of contents</db:secondary></db:indexterm>Tables of contents serve different purposes. Some describe a curriculum, a designed reading order. Others are simply a means of navigation, a way to select one topic out of a collection of many. If your content is written in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, the chances are that it already contains the structures on which such classifications could be based, and again, the <db:indexterm><db:primary>table of contents</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>table of contents</db:secondary></db:indexterm>TOC can be generated based on the <db:indexterm><db:primary>metadata</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>metadata</db:secondary></db:indexterm>metadata already in the content.</db:para>
<db:para>One advantage of this approach is that if an algorithm assembles the <db:indexterm><db:primary>table of contents</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>table of contents</db:secondary></db:indexterm>TOC based on <db:indexterm><db:primary>metadata</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>metadata</db:secondary></db:indexterm>metadata, new content is automatically included in the TOC the next time you generate output. This simplifies the task of adding new content by avoiding the need to update multiple files or systems. This makes life easier for writers because they do not need to know how the TOC is constructed. They only have to create individual pieces of <db:indexterm><db:primary>conformance</db:primary></db:indexterm><db:indexterm><db:primary>process</db:primary><db:secondary>conformance</db:secondary></db:indexterm>conforming content and submit them to the right location. This also <db:indexterm><db:primary>avoiding duplication</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>avoiding duplication</db:secondary></db:indexterm>avoids duplication, since the metadata the TOC generation algorithm uses is stored only in one place.</db:para>
<db:indexterm class="endofrange" startref="idp1468998772"/><db:indexterm class="endofrange" startref="idp1468998772x"/></db:section>
<db:section><db:title>Lists</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp1469043444"><db:primary>lists</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1469043444x"><db:primary>concept</db:primary><db:secondary>lists</db:secondary></db:indexterm>



<db:para>A major feature of a <db:indexterm><db:primary>bottom-up information architecture</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>bottom-up information architecture</db:secondary></db:indexterm>bottom-up information architecture is the <db:indexterm><db:primary>list</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>list</db:secondary></db:indexterm>list. Like TOCs, lists are a catalog of resources. But while a TOC is a list of resources defined by their container (contents = things in a container), a list may have any principle of organization or inclusion.</db:para>
<db:para>For instance, in a collection of movie reviews, you might want to include a filmography for each actor. Such a list is not only a useful piece of information, it is also an important aid for navigating a site. Maintaining such a list by hand would be laborious and error prone, especially with new movies being added to the collection all the time.</db:para>
<db:para>If you have your movie reviews in a structured format that lists the actors in the movie in a format accessible to algorithms, like this:</db:para>
<db:programlisting language="sam">
movie: Rio Bravo
    starring:: actor
        John Wayne
        Dean Martin    
        Ricky Nelson    
        Angie Dickinson
        Walter Brennan
</db:programlisting>
<db:para>you can generate the filmographies for all your actors, like this:</db:para>
<db:programlisting language="pseudo">
create-filmographies
    for each unique actor in movie/starring/actor 
        create filmography named actor with link to actor
        for each movie where starring/actor = actor
            create entry named movie with link to movie
</db:programlisting>
<db:para>Tables of contents are a <db:indexterm><db:primary>top-down information architecture</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>top-down information architecture</db:secondary></db:indexterm>top-down information architecture device. You expect to find them at the top of the information set. List are a <db:indexterm><db:primary>bottom-up information architecture</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>bottom-up information architecture</db:secondary></db:indexterm>bottom-up information architecture device. You expect to find them as independent pages or as elements within a page. Thus, if your collection includes the biographies of actors, and you want each biography to include the filmography, you can omit the filmography from the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain version of the biography and have the <db:indexterm><db:primary>publishing algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publishing algorithm</db:secondary></db:indexterm>publishing algorithm generate it with the output, as shown in <db:xref linkend="fig.generate-filmography"/>.</db:para>
<db:figure xml:id="fig.generate-filmography"><db:title>Algorithm to generate a filmography</db:title><db:programlisting language="pseudo">
match actor-bio
    create html
        create h1 "Biography: " + actor-name
        continue
        create h2 "Filmography"
        for each movie-review where starring/actor = actor-name
            create li 
                create a with attribute href 
                 = address of movie-review
                    output movie-name
</db:programlisting></db:figure>
<db:para>Note the close relationship between rhetoric and navigation in <db:xref linkend="fig.generate-filmography"/>. The generated filmography is both content and <db:indexterm><db:primary>navigation</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>navigation</db:secondary></db:indexterm>navigation, both part of the individual topic and part of the overall navigation scheme – an example of how <db:indexterm><db:primary>information architecture algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>information architecture algorithm</db:secondary></db:indexterm>information architecture unites rhetoric and navigation.</db:para>
<db:indexterm class="endofrange" startref="idp1469043444"/><db:indexterm class="endofrange" startref="idp1469043444x"/></db:section>
<db:section><db:title>Collections and selections</db:title>


<db:para>One of the applications of <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain markup that I mentioned in the recipe example is that it can be used to select content for a collection. Thus, if you capture calories and preparation time in your recipe markup, you can use that information to assemble a cookbook with a title like “Diet-Friendly Dishes You Can Make in 30 Minutes or Less.” If you store seasonal information, you can create “Diet-Friendly Christmas Treats” or “Summer Suppers in 20 Minutes.”</db:para>
<db:para>One of the most important aspects of creating collections based on subject-domain markup is that you did not have to think of those collections while the recipes were being written. Nothing ties the recipes to these publications. The recipes simply record certain significant facts about the dishes that may matter to readers. A <db:indexterm><db:primary>content strategist</db:primary></db:indexterm><db:indexterm><db:primary>role</db:primary><db:secondary>content strategist</db:secondary></db:indexterm>content strategist can then dream up all kinds of collections, and, because the recipes record significant truths about the dishes in a form that is accessible to algorithms, chances are that you will be able to assemble those collections quickly and get them to press while the market demand is hot.</db:para>
<db:para>The subject domain is the gift that keeps on giving. You don’t have to anticipate all of the possible uses for your subject-domain data, and collecting that data is relatively inexpensive since you are simply asking writers to enter information they already know in fields with concrete, specific names that are easy to understand.</db:para>
</db:section>
<db:section><db:title>Content queries</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp1469097332"><db:primary>queries</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1469097332x"><db:primary>concept</db:primary><db:secondary>queries</db:secondary></db:indexterm>



<db:para>If you know what subjects the phrases in your content refer to, you can use that information to form queries to pull in additional information from other sources. For instance, let’s say that you are writing about novels, and you annotate the titles of novels that are mentioned in your text:</db:para>
<db:programlisting language="xml">
{War and Peace}(book "ISBN:1400079985") is a very long book.
</db:programlisting>
<db:para>Here, the title is marked up as a book title, and, to make things more precise, an ISBN number is provided. An ISBN number is the key to a large amount of data about a published book. If you have the ISBN number, you can look up all sorts of other information. For instance, you can use the ISBN to look up publication details using a web service like ISBNdb (<db:link xlink:href="http://isbndb.com">http://isbndb.com</db:link>).</db:para>
<db:para>Most web services return information in XML. A hypothetical ISBN web service might return an XML document that looked like <db:xref linkend="fig.generate-isbn"/>.<db:footnote>
<db:para>This is not what ISBNdb returns, just a simplified example.</db:para>
</db:footnote></db:para>

<db:figure xml:id="fig.generate-isbn"><db:title>Information returned by an ISBN web service</db:title><db:programlisting language="xml">
&lt;book&gt;
    &lt;isbn&gt;1400079985&lt;/isbn&gt;
    &lt;title&gt;War and Peace&lt;/title&gt;
    &lt;author&gt;Leo Tolstoy&lt;/author&gt;
    &lt;publisher&gt;Vintage&lt;/publisher&gt;
    &lt;publication-year&gt;2008&lt;/publication-year&gt;
    &lt;page-count&gt;1296&lt;/page-count&gt;
    …
&lt;/book&gt;
</db:programlisting></db:figure>
<db:para>You could then pull pieces from that XML document and add them to your own content, thus allowing you to produce output like this:</db:para>
<db:blockquote>
<db:para><db:emphasis>War and Peace</db:emphasis> (Leo Tolstoy, Vintage, 2008, 1296 pages) is a very long book.</db:para>
</db:blockquote>

<?dbfo-need height="3in"?>

<db:para>The algorithm to do this looks something like <db:xref linkend="fig.generate-isbn-pseudocode"/>.</db:para>
<db:figure xml:id="fig.generate-isbn-pseudocode"><db:title>Algorithm to look up book information using the ISBN</db:title><db:programlisting language="pseudo">
match p/book
    $isbn = @specifically 

    $book-info = get 'http://example.com/isbn/lookup?' + $isbn

    create i
        continue

    output " ("
    output $book-info/book/author
    output ", "
    output $book-info/book/publisher"/&gt;
    output ", " 
    output $book-info/book/publication-year"/&gt;
    output ", "
    output $book-info/book/page-count"/&gt;
    output " pages"
    output )
</db:programlisting></db:figure>
<db:para>This basic technique opens all kinds of doors. The power of structured writing as a tool to merge information from different sources is enormous. Here are just a few of the tricks you could pull using information retrieved using the ISBN number:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Pull in a picture of the book cover.</db:para>
</db:listitem>
<db:listitem>
<db:para>Create a link to an article about <db:emphasis>War and Peace</db:emphasis> on your website.</db:para>
</db:listitem>
<db:listitem>
<db:para>Create a link to an online bookstore where readers can buy the book. If you belong to an affiliate program for the online bookstore, you can earn a commission each time a reader follows your link and buys the book.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>You can also realize major process efficiencies by capturing this kind of metadata in your content. If you can use metadata keys to pull information from external sources, writers don’t have to look up that information when they write. And writers don’t have to decide which book details will appear in the final output. That decision is made separately by editing the algorithm, and you can change that decision for all your existing content simply by changing the algorithm.</db:para>
<db:para>Having writers enter the ISBN number in the content makes writing the algorithm straightforward, and sometimes it is appropriate because you are referring to a particular edition of a book and the ISBN number is the most reliable identifier of a specific edition. But in many case it is actually too specific, and it complicates life if writers have to look up the ISBN when all they want to refer to is the novel itself, regardless of the edition. This distinction can be important. There are many other editions of <db:emphasis>War and Peace</db:emphasis>, in many languages. <db:emphasis>War and Peace</db:emphasis> is a very long book in all those editions and all those languages. The paragraph does not refer specifically to the Vintage Edition of 2008. It refers to <db:emphasis>War and Peace</db:emphasis> as a novel generally.</db:para>
<db:programlisting language="sam">
{War and Peace}(novel) is a very long book.
</db:programlisting>
<db:para>Here, I have replaced the <db:code>book</db:code> annotation with the more specific <db:code>novel</db:code> annotation. If you are concerned that there might be other novels named <db:emphasis>War and Peace</db:emphasis> by other writers, you could make the annotation more specific:</db:para>
<db:programlisting language="sam">
{War and Peace}(novel (Leo Tolstoy)) is a very long book.
</db:programlisting>
<db:para>In SAM, a phrase in parentheses inside an annotation is a <db:indexterm><db:primary>namespace</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>namespace</db:secondary></db:indexterm>namespace identifier. A namespace is a context in which a set of names is guaranteed to be unique. No author publishes more than one novel with the same name, so the name of the author is generally an adequate namespace identifier for the name of a novel. This markup is obviously easier for writers to create than an ISBN. It asks them only for the things they already know, so they won’t have to stop to look anything up. That is an important part of <db:indexterm><db:primary>functional lucidity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functional lucidity</db:secondary></db:indexterm>functional lucidity.</db:para>
<db:para>However, without an ISBN number, can you still get the book data you want? You can, but you have to use a different query to extract it:</db:para>
<db:programlisting language="pseudo">
match p/novel

    $title = #content
    $author = @namespace 

    $book-info = get 'http://example.com/isbn/lookup?category=novel&amp;title='
                     + $title + '&amp;author=' + $author
</db:programlisting>
<db:para>The only thing different about the results you will get from this query is that it may return records for more than one book (actually, for <db:emphasis>War and Peace</db:emphasis>, you will certainly get multiple records, since there are many editions in print). So the code that adds the book info to the content must pick one of the alternatives based on some relevant piece of publication data, such as the most recent publication date.</db:para>
<db:para>I could have chosen an example that did not have this kind of ambiguity (title vs. ISBN as identifier of a novel), but you will often come across issues like this in the real world. This is one of those issues that forces you to make a decision about how to correctly partition complexity in your system. You have a choice between an approach that uses a simple, easy-to-write algorithm but requires effort and research from writers versus an approach that requires more thought and effort to write the algorithm but provides greater <db:indexterm><db:primary>functional lucidity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functional lucidity</db:secondary></db:indexterm>functional lucidity for writers.</db:para>
<db:para>Stated like this it seems obvious which choice you should make, but in practice these decisions are often made by the people developing the algorithms, and they often choose to make their lives easier at the expense of the writers. This may seem like a detail, but when correct partitioning and distribution is at stake, decisions should not be left to one partition to make. These decisions require input from all sides and the attention of the project owners.</db:para>
<db:indexterm class="endofrange" startref="idp1469097332"/><db:indexterm class="endofrange" startref="idp1469097332x"/></db:section>
<db:section><db:title>Personalized content</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp1468569028"><db:primary>content, personalized</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1468569028x"><db:primary>concept</db:primary><db:secondary>content, personalized</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idp1468569156"><db:primary>personalized content</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1468569156x"><db:primary>concept</db:primary><db:secondary>personalized content</db:secondary></db:indexterm>



<db:para>A key feature of modern web architecture is personalized content, which means content that is generated in response to either what the site already knows about you – from your account information or a transaction token such as a <db:indexterm><db:primary>cookie</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>cookie</db:secondary></db:indexterm>cookie – or the selections or entries that you make on the page.</db:para>
<db:para>For example, when you log into Amazon, the first page you see is crafted for you based on everything Amazon knows about your browsing and purchasing history. As you make selections, such as adding an item to your shopping cart or wish list, that information is used to generate the next page you see.</db:para>
<db:para>If you browse a used car site like Autotrader.com, you can select features that you are interested in (red convertibles with manual transmission under $20,000, for instance), and the next page will be generated based on that input.</db:para>
<db:para>The ability of a site to personalize pages depends on whether it can identify content that is <db:indexterm><db:primary>relevance</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>relevance</db:secondary></db:indexterm>relevant – based on everything it knows about the reader – and assemble that content to form a page. For this to work, the content must be easy to identify unambiguously and must fit together easily.</db:para>
<db:para>As we have seen, these properties are maximized when you store content in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, both because the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain makes the relevant <db:indexterm><db:primary>metadata</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>metadata</db:secondary></db:indexterm>metadata available and because working in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain helps writers produce more consistent content that works better with personalization algorithms.</db:para>
<db:para>The consistency of your content is most important in personalized content applications. Because output is assembled in real time by an algorithm based on a combination of unique things you know about the reader and your content, there is no opportunity for a writer or editor to inspect the output of a personalized content publication before the reader sees it. This requires total confidence that:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>the content <db:indexterm><db:primary>conformance</db:primary></db:indexterm><db:indexterm><db:primary>process</db:primary><db:secondary>conformance</db:secondary></db:indexterm>conforms to its <db:indexterm><db:primary>constraints</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>constraints</db:secondary></db:indexterm>constraints</db:para>
</db:listitem>
<db:listitem>
<db:para>the <db:indexterm><db:primary>markup</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>markup</db:secondary></db:indexterm>markup expresses those constraints completely and correctly</db:para>
</db:listitem>
<db:listitem>
<db:para>the algorithm correctly processes and delivers the content</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>All three of these requirements depend on the soundness and simplicity of the <db:indexterm><db:primary>markup</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>markup</db:secondary></db:indexterm>markup design. They require precise content structures with few alternatives, clear guidance for writers, and good <db:indexterm><db:primary>auditing algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>auditing algorithm</db:secondary></db:indexterm>audit capability. Without these properties, your content and its markup will be inconsistent, and it will be hard to write and test reliable algorithms because of the wide variety of markup combinations they may encounter.</db:para>
<db:para>Most personalized content applications model their content in relational database tables for these very reasons. However, with the correct markup design, almost certainly in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain, there is no reason why you cannot use markup-based tools alone or in concert with database tools and solutions to achieve the same kind of result.</db:para>
<db:indexterm class="endofrange" startref="idp1468569028"/><db:indexterm class="endofrange" startref="idp1468569156"/><db:indexterm class="endofrange" startref="idp1468569028x"/><db:indexterm class="endofrange" startref="idp1468569156x"/></db:section>
<db:section><db:title>Audit reports</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp1468450884"><db:primary>audits</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1468450884x"><db:primary>concept</db:primary><db:secondary>audits</db:secondary></db:indexterm>



<db:para>Finally, you can use content generation algorithms to generate things other than content to be published. You can use it to generate reports about your content itself, which you can use to audit and manage your collection. I look at this in more detail in <db:xref linkend="chapter.audit"/>, but it is worth looking at the basics here because it is just another application of the capacity for content generation that you gain when you move content into the subject domain.</db:para>
<db:para>For instance, suppose your content strategist establishes an editorial calendar that says that you are going to put out a Christmas-themed diet cookbook every October as people are starting to prepare for Christmas. Do you have enough Christmas seasonal recipes under 300 calories? An algorithm can quickly go through your subject-domain recipes and create a list of all the recipes that meet that criteria.</db:para>
<db:para>Or suppose that you want to make sure that your book-related site has reviews and shopping links for every book that has been mentioned on the site this year. An algorithm can go through your content collection looking for the <db:code>book</db:code> or <db:code>novel</db:code> annotations in your articles, compile a list, sort it, eliminate duplicates, compare it to the list of reviews you currently have, and create a list of every book that is mentioned but not reviewed.</db:para>
<db:indexterm class="endofrange" startref="idp1468450884"/><db:indexterm class="endofrange" startref="idp1468450884x"/></db:section>
<db:section><db:title>Reuse vs Generation</db:title>


<db:para>As you have probably noticed, the methods used to generate content have a lot in common with those used to reuse content. That is because content reuse is just a form of content generation. Content reuse means generating more than one form or output content from the same collection of output content. Technically, the mechanisms and algorithms are the same; the differences have more to do with how you think about the problem.</db:para>
<db:para>The biggest difference is that when you think in content generation terms, you are automatically thinking in <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain terms. Content generation starts by treating content as data and then generates content from that data. When people think in <db:indexterm><db:primary>content reuse algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content reuse algorithm</db:secondary></db:indexterm>content reuse terms, however, their thoughts often go straight to the <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain, to conditional content and pulling in content by reference. Thinking in content reuse terms also tends to give first use primacy over secondary uses. The first instance is created to serve a specific purpose. You then  serendipitously discover another potential use for the content. Thinking in content generation terms does not give primacy to any one use. The content is created as data with many potential uses. There is no first use or secondary uses. Every use is a production from the source data, and it really does not matter how many such uses there are.</db:para>
<db:para>As I noted in <db:xref linkend="chapter.reuse"/>, there are certain kinds of reuse that are only feasible using <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management-domain constructs, but a great deal can be accomplished using the subject-domain approach. Creating conditional markup in your recipe to provide a different beverage match for <db:emphasis>Wine Weenie</db:emphasis> and <db:emphasis>The Teetotaler's Trumpet</db:emphasis> is a case of <db:indexterm><db:primary>reuse</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm>reuse thinking. Creating structure for alcoholic and non-alcoholic beverage matches to achieve the same goal (and potentially many more) is a case of content generation thinking. In many cases, you will create a far more valuable content resource that is is easier to write for and is easier to maintain by thinking of your content set as a data source from which many kinds of content can be generated rather than a collection of reusable content components.</db:para>
<db:indexterm class="endofrange" startref="idp1469214580"/><db:indexterm class="endofrange" startref="idp1469215604"/><db:indexterm class="endofrange" startref="idp1469214580x"/><db:indexterm class="endofrange" startref="idp1469215604x"/></db:section>
</db:chapter>
