<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.extensible"><db:title>Extensible and Constrainable Languages</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp1902948020"><db:primary>extension</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1902948020x"><db:primary>concept</db:primary><db:secondary>extension</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idp1902946740"><db:primary>constraint</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1902946740x"><db:primary>concept</db:primary><db:secondary>constraint</db:secondary></db:indexterm>




<db:para>The languages we have looked at to this point are publicly specified and have existing tool chains. Some are more constrained than others, and some support different structured writing algorithms and different ways of partitioning and redirecting complexity. Choosing one of them makes sense if the constraints they express and the algorithms they support partition content complexity in a way that is right for your organization. If not, you need to create your own structures to improve how complexity is partitioned and distributed in your organization.</db:para>
<db:para>You have three options for doing this:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Create your own language entirely from scratch, creating both the syntax and the semantics. (This is what <db:indexterm><db:primary>Gruber, John</db:primary></db:indexterm><db:indexterm><db:primary>person</db:primary><db:secondary>Gruber, John</db:secondary></db:indexterm>John Gruber did when he created <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown.)</db:para>
</db:listitem>
<db:listitem>
<db:para>Use an existing abstract markup syntax, such as XML or SAM, and create your own semantics by defining named structures using that syntax (as described in <db:xref linkend="chapter.markup"/>).</db:para>
</db:listitem>
<db:listitem>
<db:para>Take an existing markup language with extensible and/or constrainable semantics, such as DITA or DocBook, and extend and/or constrain it to meet your needs.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>Each of these approaches has merits and drawbacks. For instance, creating a new language may enable you to achieve exceptional <db:indexterm><db:primary>functional lucidity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functional lucidity</db:secondary></db:indexterm>functional lucidity for a particular type of information, extending/constraining an existing language may save tool development costs, or defining your own semantics based on an existing syntax may enable you to find the right balance between functional lucidity and development costs.</db:para>
<db:para>This chapter looks at extensible and constrainable markup languages.</db:para>
<db:section>
<db:title>XML</db:title>

<db:para>The X in <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm><db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML stands for eXtensible, but, as noted in <db:xref linkend="chapter.markup"/>, XML is an abstract language that does not define any document structures itself. Therefore, with XML, you start from zero. Syntactically, everything is defined for you. Semantically you start from scratch.</db:para>
<db:para>You can define the structure of a new XML markup language using one of several available <db:indexterm><db:primary>schema languages</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>schema languages</db:secondary></db:indexterm>schema languages. I look at schema languages in <db:xref linkend="chapter.constraints"/>, but the mechanics of defining a markup language in XML are out of scope for this book.</db:para>
</db:section>
<db:section>
<db:title>DITA</db:title>


<db:para><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA is unique among markup languages because it was designed for extension from the beginning. In fact, it is something of a misnomer to call DITA a markup language. The DITA standard calls it an information typing architecture. What is an information typing architecture? DITA is the only standard that calls itself by this name, so we have to derive the definition from the properties of this one example.</db:para>
<db:para>The conventional way to define a document type is to use a schema language. Schema languages describe constraints on markup structures. (I look at markup structures in <db:xref linkend="chapter.constraints"/>). So what does an information typing architecture provide over and above what a schema language provides?</db:para>
<db:para>An architecture is a set of principles for addressing a certain kind of problem. For instance, there are several different architectures for building bridges, including the beam bridge, the truss bridge, the arch bridge, and the suspension bridge. An architecture, by itself, is just a set of ideas. The virtue of an architecture is that it puts several elements together in a way that can be tested and that can support the development of tools and/or prefabricated components than can be used to build specific bridges. If you decide to build an arch bridge, therefore, there are lots of architectural tools, practices, and data that you can draw on to make the design and construction of your bridge faster and more reliable.</db:para>
<db:para>Architectures are a way of partitioning the design problem for a structure. They divide the design space into pieces and provide design and construction guidance within each piece. It is not a case of a single architecture addressing all cases. The suspension bridge is a great solution for crossing some gaps, but a beam or truss bridge is a much simpler and more economical architecture for most common gaps. An architecture does not tell you what type of bridge to build; it helps you build a particular type of bridge once you have determined which type is appropriate.</db:para>
<db:para>At the heart of each architecture you will usually find one fairly simple idea or principle. The arch bridge architecture depends on the strength of the arch shape to support the load. The truss bridge depends of the rigidity of the triangle shape to provide strength, the suspension bridge architecture uses cables to transfer weight to towers. At the heart of the DITA architecture is a similarly simple idea, which we might call the block and map architecture. That is, DITA treats information products are being constructed of blocks of information (which it calls “topics”) according to a hierarchical map. The Assemble from Pieces reuse algorithm that I discussed in <db:xref linkend="chapter.reuse"/> is an example of a block and map architecture. (But note that DITA is not the only block and map architecture, and maps are not the only way to assemble blocks.)</db:para>
<db:para>An architecture does not solve the entire design problem for a bridge or for a content system. It provides a starting point, both for design and for tools and implementation, but there is still design, build, and integration work to do to create a bridge or a system to address a specific need. As I noted in describing out-of-the-box DITA, even out of the box systems require some customization to make them fit your needs. When you choose an out-of-the-box system, therefore, you choose one that comes closest to meeting your needs, so that you can live with the fewest limitations and do the least customization. If you choose an architecture as the basis for building a custom system, you will have more work to do, and will be able to eliminate many more limitations, but the principle remains the same: you start with the architecture that comes closest to meeting your needs. Just as every out-of-the-box tool has passionate advocates who will tell you it is right for every problem, so too you will have passionate advocates of architectures like DITA who will tell you that it is right for all content system. But the very nature of an architecture is that make it easier to address a particular kind of problem by implementing a particular kind of solution. A universal architecture would have no content. Architectures get their usefulness by being specific and limited, not by being general or all-encompassing.</db:para>
<db:para>While DITA is the only thing in the content space that explicitly calls itself an architecture, there are, in fact, other content architectures. FrameMaker, for instance, is based on an architecture that builds a document out of a set of nested frames. Wikis are based on what we can call the wiki architecture, which is an architecture of pages connected to each other by references contained in the pages themselves, in the form of wikiwords and categories. (In other words it is a block architecture where assembly is not based on maps.) Blog platforms implement a block-based architecture based on temporal sequence supplemented by categorization and tagging. But while all these are architecture, they have not be described and formalized outside of the tools the implement them. The only other architecture I know of that is being formalized in this way is the one I am developing myself, <db:indexterm><db:primary>SPFE</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>SPFE</db:secondary></db:indexterm>SPFE, which I will describe briefly in this chapter.</db:para>
<db:para><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA has grown into a large and complex architecture over the years, and it is out of scope for this book to describe its architecture in full.<db:footnote>
<db:para>Obviously I am not a fan of the DITA architecture or I would not be developing my own architecture in SPFE. For a much fuller and more sympathetic treatment of the DITA architecture, see <db:citetitle>DITA for Practitioners Volume 1: Architecture and Technology</db:citetitle> by Elliot Kimber, <db:link xlink:href="http://xmlpress.net/publications/dita/practitioners-1/">http://xmlpress.net/publications/dita/practitioners-1/</db:link></db:para>
</db:footnote> Instead, I attempt to map key features of the DITA architecture to the structured writing concepts explored in this book.</db:para>

<db:section>
<db:title>Basics of the DITA architecture</db:title>

<db:para>The fundamental block and map architecture of DITA consists of these pieces:</db:para>
<db:orderedlist>
<db:listitem>
<db:para>A collection of schema for some basic block types (“topics” in DITA parlance).</db:para>
</db:listitem>
<db:listitem>
<db:para>A specification for a map mechanism for assembling blocks into information products.</db:para>
</db:listitem>
<db:listitem>
<db:para>A specification for a specialization mechanism for creating specialized types of blocks from the base types, and a parallel mechanism for specializing the processing code for the base blocks to process the specialized blocks.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>There is a great deal more in the current DITA specification, but those elements are the core of the architecture.</db:para>
<db:para>Information typing in DITA, therefore, consists of creating specialized versions of the base information types using the specialization mechanism. You don’t need any such mechanism to do information typing. An <db:indexterm><db:primary>XML schema</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML schema</db:secondary></db:indexterm>XML schema is an information typing <db:emphasis>language</db:emphasis> that you can use directly to define any information type you like. DITA provides base topic types that contain thought-out and tested information type designs, meaning that when you specialize from them, you don’t have to do that design work from scratch, you only have to design your specialization. On the other hand, DITA assumes that all information types are specialized instances of its base topic type. However, some applications of XML, such as recording transfers between banks or storing the configuration options of an editor, are not instances of DITA topics. DITA lets you design a limited range of information types more easily, but limits the range of information types you can create.</db:para>
<db:para>This is the proper role of any architecture. It gives you a head start in its own domain, but it is only appropriate for use in that domain, and only if the choices baked into the architecture are the choices that make sense for your application. These limitations are reflected in the way DITA define information typing itself:</db:para>

<?dbfo-need height="1.5in"?>

<db:para>The DITA specification defines information typing as follows:</db:para>
<db:blockquote>
<db:attribution>Darwin Information Typing Architecture (DITA) Version 1.3 Part 3: All-Inclusive Edition</db:attribution>
<db:para>Information typing is the practice of identifying types of topics, such as concept, reference, and task, to clearly distinguish between different types of information.<db:footnote>
<db:para><db:link xlink:href="http://docs.oasis-open.org/dita/dita/v1.3/csd01/part3-all-inclusive/dita-v1.3-csd01-part3-all-inclusive.html#information-typing">http://docs.oasis-open.org/dita/dita/v1.3/csd01/part3-all-inclusive/dita-v1.3-csd01-part3-all-inclusive.html#information-typing</db:link></db:para>
</db:footnote></db:para>
</db:blockquote>

<db:para>Unfortunately this definition is largely circular – information typing defines information types. But it does help establish a scale. Information typing is about defining topic types.</db:para>

<?dbfo-need height="1.5in"?>

<db:para>The specification goes on to define the purpose of information typing as follows:</db:para>
<db:blockquote>
<db:para>Information typing is a practice designed to keep documentation focused and modular, thus making it clearer to readers, easier to search and navigate, and more suitable for reuse.</db:para>
</db:blockquote>
<db:para>DITA information typing is not as general as structured writing. It focuses on information at a particular scale and on a subset of the structured writing algorithms. That does not make it impossible to work at other scales or implement other algorithms, it just means that the architecture provides better support for certain areas.</db:para>
<db:para>Out-of-the-box DITA is commonly associated with the idea that there are just three information types: task, concept, and reference. The DITA specification makes it clear that this is not the intention of DITA as an information typing architecture.</db:para>
<db:blockquote>
<db:para>DITA currently defines a small set of well-established information types that reflects common practices in certain business domains, for example, technical communication and instruction and assessment. However, the set of possible information types is unbounded. Through the mechanism of specialization, new information types can be defined as specializations of the base topic type (&lt;topic&gt;) or as refinements of existing topics types, for example, &lt;concept&gt;, &lt;task&gt;, &lt;reference&gt;, or &lt;learningContent&gt;.</db:para>
</db:blockquote>
<db:para>As I have noted, many structured writing algorithms partition complexity best when given more specific markup, particularly markup in the subject domain. The ability to create other information types is, therefore, relevant to getting the most out of structured writing.</db:para>
<db:para>Clearly, though, you do not need an information typing architecture to define an information type. You can, as <db:indexterm><db:primary>Gruber, John</db:primary></db:indexterm><db:indexterm><db:primary>person</db:primary><db:secondary>Gruber, John</db:secondary></db:indexterm>John Gruber did with <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown, sketch out a set of structures, create a syntax to represent them, and write a program to process them. With an <db:indexterm><db:primary>abstract language</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>abstract language</db:secondary></db:indexterm>abstract language like <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm><db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML or <db:indexterm><db:primary>SAM</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SAM</db:secondary></db:indexterm>SAM, you can create a new information type by defining a set of named elements and attributes using a schema language. How does using a higher level information typing architecture like DITA change this process? How does it partition the design problem differently?</db:para>
<db:para>First and foremost, it means that you don’t start from scratch. All topic types in DITA are derived from a base topic type called <db:code>topic</db:code> through specialization.</db:para>
</db:section>
<db:section>
<db:title>Specialization</db:title>

<db:para>What is <db:indexterm><db:primary>specialization</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>specialization</db:secondary></db:indexterm>specialization? XML syntax defines abstract structures that do not occur in documents: elements, attributes, etc. To create a markup language in XML, you define named elements and attributes for the structures you are creating. This is a type of specialization.</db:para>
<db:para>For example, in <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook, <db:code>para</db:code> is a type of element. <db:code>para</db:code> has what is called an “is-a” relationship to elements: <db:code>para</db:code> is an element, but it is a special type of element. An XML parser will process a <db:code>para</db:code> generically as an element, reporting its name to another algorithm whose job is to interpret and act on that structure. This algorithm must then supply a rule that processes just this specialized <db:code>para</db:code> element (and not the also specialized but different <db:code>title</db:code> element). All of the algorithms in this book act on structures reported to them by a parser.</db:para>
<db:para>DITA specialization follows the same principle, but moves it up a level. The base <db:code>topic</db:code> topic type is the abstract structure. You can create a more specific type, such as <db:code>knitting-pattern</db:code> or <db:code>ingredients-list</db:code>, as a specialization of <db:code>topic</db:code> (or of other topic types that are themselves specializations of <db:code>topic</db:code>).  Each of these specialized types has an is-a relationship with the type it was specialized from. So <db:code>knitting-pattern</db:code> is a <db:code>topic</db:code>.</db:para>
<db:para>DITA specialization differs from simply creating new named elements in XML in that the base DITA topic type is not an abstraction like an XML element. You cannot create an XML element without inventing a name for it. The base DITA topic type, on the other hand, is a fully implemented topic type that you can use directly. You can, and people do, write directly in the base topic type without inventing anything new. I noted in <db:xref linkend="chapter.rhetorical_structure"/> that it is sometimes easy to treat what is intended as a meta model as a generic model. This is the case here. All topic types in DITA are derived by specialization from the generic <db:code>topic</db:code> type. They all have an is-a relationship to this generic type.</db:para>
<db:para>One consequence of this is that a processor can successfully process a specialized element as though it were the base element. The result may not reflect all aspects of the specialized element, but the processing will not fail. This is an attractive quality because it is often easier to modify an existing piece of code than it is to write new code from scratch, particularly if most of the rules in the base code can remain unchanged.</db:para>
<db:para>To specialize a topic type, you specialize the root element and any child elements or attributes that you need. Each specialized element or attribute should have an is-a relationship to the element it specializes. Thus a procedure element might be a specialization of an ordered-list element and its step elements might be specializations of a list-item element. In this case, processing a procedure as an ordered list would produce meaningful output: a conventionally labeled numbered list. However, you would probably want to specialize the output of steps in a procedure, perhaps by prefixing each step with “Step 1:” rather than just “1.” Modifying the ordered-list code to handle procedures would probably take less code than writing a procedure processing algorithm from scratch.</db:para>
<db:para>The second way in which DITA specialization differs from giving names to abstract elements is that specialization is recursive. For example, suppose you have created a topic type called <db:code>animal-description</db:code>, which is a specialization of <db:code>topic</db:code>. You want to impose additional constraints on the description of certain types of animal, so you create <db:code>fish-description</db:code> and <db:code>mammal-description</db:code>, which are specializations of <db:code>animal-description</db:code> (and which would be processed like an <db:code>animal-description</db:code> if no other processing is specified for them).</db:para>
<db:para>Then you might decide to impose still more constraints to describe different kinds of mammals, so you create the type <db:code>horse-description</db:code>, which is a specialization of <db:code>mammal-description</db:code>. This type would be processed as a <db:code>mammal-description</db:code> if no specific processing is provided for <db:code>horse-description</db:code>; as <db:code>animal-description</db:code> if no specific <db:code>mammal-description</db:code> processing is provided; and as <db:code>topic</db:code> if no specific <db:code>animal-description</db:code> processing is provided.</db:para>
<db:para>The third way in which information typing in DITA differs from creating a language from scratch is that DITA information types share a common approach to processing and to information architecture. In particular, they inherit a common set of <db:indexterm><db:primary>management-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management-domain</db:secondary></db:indexterm>management-domain structures and their associated management semantics.</db:para>
<db:para>A DITA topic, then, comes with a lot of built-in functionality and structure that you don’t have to reinvent when you create a specialized topic type. But the corollary is that not all content types are specialized instances of a DITA generic topic. This means that while the set of information types that you can create using specialization is unbounded in number, it is not unbounded in type. There are types you can’t create by specialization, at least if you want to maintain the is-a relation to the base type (without which specialization isn’t specialization at all).</db:para>
<db:para>When we factored the ingredients of a recipe out of a <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain list into a <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain record structure it was, in part, to make them independent of the decision to format them as a <db:indexterm><db:primary>table</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>table</db:secondary></db:indexterm>table or as a <db:indexterm><db:primary>list</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>list</db:secondary></db:indexterm>list.</db:para>
<db:figure xml:id="fig.ingredients-list"><db:title>Subject-domain ingredients list</db:title><db:programlisting language="sam">
ingredients:: ingredient, quantity, unit
    eggs, 3, each
    salt, 1, tsp
    butter, .5, cup 
</db:programlisting></db:figure>
<db:para>The ingredient record set in <db:xref linkend="fig.ingredients-list"/> no longer has an is-a relationship to a <db:indexterm><db:primary>table</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>table</db:secondary></db:indexterm>table or a <db:indexterm><db:primary>list</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>list</db:secondary></db:indexterm>list. The point was to break that relationship so you could present this content any way you wanted to. Because any structure specialized from a DITA topic must maintain an is-a relationship to a DITA topic, which is a generic document-domain structure, you can use specialization to create subject-domain structures that intersect with the document domain, such as the <db:code>introduction</db:code>, <db:code>ingredients</db:code>, and <db:code>preparation</db:code> sections in a <db:code>recipe</db:code> document. However, you can’t take the next step of factoring out the presentation, as I’ve done in <db:xref linkend="fig.ingredients-list"/>, since factoring out presentation breaks the is-a relationship with the document domain.</db:para>
<db:para>In other words, the specialization mechanism lets you create any element name you like as a specialization of any other element name you like. As such, it can create any structure you like. But the entire justification of the specialization mechanism rests on the maintenance of the is-a relationship between the specialized element and the base element. Once this is broken, code inheritance and fallback processing no longer work, and specialization simply becomes an unnecessarily complex and error prone way of writing a new and unrelated schema.</db:para>
<db:para>Labels are a big part of document-domain content. When we created a subject-domain structure for recording nutritional information for a recipe, we factored out all of the labels by putting the content in named fields. In other words, as shown in <db:xref linkend="fig.nutrition"/>, the labels went from being data (in the content) to <db:indexterm><db:primary>metadata</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>metadata</db:secondary></db:indexterm>metadata (part of the structure).</db:para>
<db:figure xml:id="fig.nutrition"><db:title>Subject-domain structure for nutritional information</db:title><db:programlisting language="sam">
nutrition:
    serving: 1 large (50 g)
    calories: 78
    total-fat: 5 g
    saturated-fat: 0.7 g
    polyunsaturated-fat: 0.7 g    
    monounsaturated-fat: 2 g    
    cholesterol: 186.5 mg    
    sodium: 62 mg    
    potassium: 63 mg    
    total-carbohydrate: 0.6 g    
    dietary-fiber: 0 g    
    sugar: 0.6 g    
    protein: 6 g    
</db:programlisting></db:figure>
<db:para>Although the structure in <db:xref linkend="fig.nutrition"/> looks superficially like a list, it is really a data record. If this structure were created as a specialization of a list and then published using a generic list publishing algorithm, the result would look like <db:xref linkend="fig.nutrition-list"/>.</db:para>
<db:figure xml:id="fig.nutrition-list"><db:title>Generic rendering of the subject-domain structure in <db:xref linkend="fig.nutrition"/></db:title><db:blockquote>
<db:itemizedlist>
<db:listitem>
<db:para>1 large (50 g)</db:para>
</db:listitem>
<db:listitem>
<db:para>78</db:para>
</db:listitem>
<db:listitem>
<db:para>5 g</db:para>
</db:listitem>
<db:listitem>
<db:para>0.7 g</db:para>
</db:listitem>
<db:listitem>
<db:para>0.7 g</db:para>
</db:listitem>
<db:listitem>
<db:para>2 g</db:para>
</db:listitem>
<db:listitem>
<db:para>186.5 mg</db:para>
</db:listitem>
<db:listitem>
<db:para>62 mg</db:para>
</db:listitem>
<db:listitem>
<db:para>63 mg</db:para>
</db:listitem>
<db:listitem>
<db:para>0.6 g</db:para>
</db:listitem>
<db:listitem>
<db:para>0 g</db:para>
</db:listitem>
<db:listitem>
<db:para>0.6 g</db:para>
</db:listitem>
<db:listitem>
<db:para>6 g</db:para>
</db:listitem>
</db:itemizedlist>
</db:blockquote></db:figure>
<db:para>In short, there is no is-a relationship between a pure <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain structure and a generic <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain structure. The subject-domain structures are simply data fields with no presumption about presentation attached to them.</db:para>
<db:para>Does this mean that you cannot create a <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain structure using DITA’s <db:indexterm><db:primary>specialization</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>specialization</db:secondary></db:indexterm>specialization mechanism? No, you can usually create the structure you want, and in a way that meets the syntax requirements of a DITA specialization. However, it won’t be an actual <db:indexterm><db:primary>specialization</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>specialization</db:secondary></db:indexterm>specialization of its base type. Because it is a <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain structure it breaks the is-a relationship with the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain. As I noted at the end of <db:xref linkend="chapter.linking"/>, <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain algorithms work completely differently from those of the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, so inheriting some of the processing of a base <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain structure is moot once you move to the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain. Your new <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain structure will be an essentially unrelated structure for which you will have to create completely new processing algorithms, just as you would if you had defined your structure from scratch.</db:para>
<db:para>Generally, the fewer pieces of an architecture you use, the less value there is to basing your work on that architecture, both because you have more work to do and because you take less advantage of the infrastructure, tools, and expertise surrounding that architecture. If you get too far away from the intention of architecture, you will create a system that is less understandable to people versed in the architecture. All this betrays a poor fit between the system partitioning you need and the partitioning the architecture provides. All architectures come with overhead, and even if you don’t use their features, you have to live with the overhead, which adds cost and complexity to your system. Thus, while you can use DITA and depart from the default DITA way of doing things, the value of using DITA diminishes the further you depart from the DITA way. The same is true of any information typing architecture.</db:para>
</db:section>
<db:section>
<db:title>Limits on rhetorical constraint</db:title>

<db:para>Throughout this book I have stressed the value of constraining rhetoric. One of the limits imposed by DITA’s topic and map architecture is that it limits the size of unit to which you can apply rhetorical constraints.</db:para>
<db:para>For instance, if you regard a recipe as being made up of one concept, one reference, and one task topic, then DITA will let you constrain the rhetoric of a specialized ingredient list reference topic, or a preparation task topic, but not of the recipe as a whole. DITA will let you write a map to combine a concept topic containing an introduction, a reference topic containing a list of ingredients, and a task topic containing preparation instructions. But it does not let you specify that a recipe topic consists of one concept topic, one reference topic, and one task topic in a particular order. In other words, DITA does not provide any direct way to define larger types or the overall rhetorical structure of documents.<db:footnote>
<db:para>Actually, it might be technically possible to create a map that was constrained in this way through specialization. That is, you could create a recipe map that is allowed to contain exactly one recipe-intro topic, one ingredients-list topic, and one preparation topic in that order. But there is no higher level way of specifying this kind of constrained map and the functional lucidity of such an approach is clearly low. But the real point here is not the technical limitation but the limits of the block and map architecture itself to support effective rhetorical constraint.</db:para>
</db:footnote></db:para>

<db:para>You can define a recipe topic type in DITA, but to do so you need to adopt a different view about how atomic a DITA topic is. Some DITA practitioners might say that a recipe is not a map made up of three information types, but a single task topic. In this view, a task topic is much more than what <db:indexterm><db:primary>Information Mapping</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>Information Mapping</db:secondary></db:indexterm>Information Mapping would call a procedure. It allows for the introduction of a task, a list of requirements, and the procedure steps all within the definition of a single topic. However, this approach abandons DITA’s principle of segregating information types into separate files.<db:footnote>
<db:para>I have asked a number of DITA practitioners how a recipe should be modeled in DITA and have received each answer from multiple people.</db:para>
</db:footnote></db:para>

<db:para>One of the reasons for this uncertainty about how to define an atomic topic in DITA is DITA’s focus on <db:indexterm><db:primary>content reuse algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content reuse algorithm</db:secondary></db:indexterm>content reuse. DITA topics are not only units of information typing, they are units of reuse. Making a recipe a single topic leaves you with fewer, larger units of content, which makes individual topics harder to reuse. The atomic unit of content that is small enough to maximize potential reuse is much smaller than the atomic unit of  content that contains a complete <db:indexterm><db:primary>rhetorical pattern</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>rhetorical pattern</db:secondary></db:indexterm>rhetorical pattern. The atomic unit of reuse is smaller than the atomic unit of use.</db:para>
<db:para>Because DITA has no direct mechanism for describing models larger than a topic, a DITA practitioner must choose between modeling for maximum reuse and modeling to constrain a topic type to rhetorical structure. In practice, DITA users make different decisions about how atomic their topic types should be based on their business needs.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>DocBook</db:title>


<db:para><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook is not really extensible in the same sense as the other languages mentioned here, but it still deserves a mention. DocBook does not provide an extension mechanism like <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA’s specialization. What it does provide is a deliberately modular construction that makes it easy to create new schemas that include elements from DocBook. DocBook takes full advantage of the extensibility features built into XML schema languages.</db:para>
<db:para>Does the fact that DocBook does not invent its own extension mechanism means that it is not as extensible as DITA? No. By relying on XML’s own extensibility features, which are both more comprehensive and lower level than DITA’s specialization mechanism, DocBook is as extensible as it is possible for any XML vocabulary to be. Thus, it is more extensible than DITA, since it is not limited to creating new elements that have an is-a relationship to existing elements.</db:para>
<db:para>Where DocBook extensions differ from DITA specialization is that there is no fall-back processing.  Extensions of DocBook are not DocBook. They are new languages that incorporate DocBook structures. The extensions cannot be processed by standard DocBook tool chains, though the incorporated DocBook structures obviously can. DITA’s specialization mechanism guarantees that a specialized topic will pass through the DITA publication process, though whether it will be presented in a useful or comprehensible way depends on how well the is-a relationship between specialization and base was maintained. If you would rather ensure that topics always pass through the publication process, even if the results are gibberish, DITA supports that. If you want to ensure that errors are raised if any structure is not recognized by the publishing tool chain (thus avoiding accidental gibberish), DocBook’s extension mechanism gives you that.</db:para>
<db:para>Another aspect of DocBook customization deserves to be mentioned here even though it is not strictly speaking extension. DocBook has a large tag set, so if you want a small constrained <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain markup language, you can often create one by sub-setting DocBook. DocBook provides just about any document structure out there, so if you are building a document-domain language, chances DocBook has the pieces you need. You can even add additional constraints.</db:para>
<db:para>The great advantage of creating a new language as a subset of DocBook is that the result is also a valid DocBook document and can therefore be published by the DocBook tool chain. You don’t have to write any new publishing algorithms if you take this approach (other than to customize formatting to your needs, which is required with any system). Creating a subset of DocBook allows you to impose more constraints and improve <db:indexterm><db:primary>functional lucidity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functional lucidity</db:secondary></db:indexterm>functional lucidity significantly compared to standard DocBook without having to write any processing code at all.</db:para>
<db:para>Technically speaking, any <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm><db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML-based markup language is extensible in the same way. However, DocBook’s structure, and the implementation of its schemas, was designed to support both extension and sub-setting, something which is not true for many markup languages.</db:para>
</db:section>
<db:section>
<db:title>ReStructuredText</db:title>


<db:para>ReStructuredText defines a base set of structures – such as paragraphs, titles, and lists – with a concrete syntax. It defines other blocks using directives. <db:xref linkend="fig.restructuredtext-1"/> shows a directive that includes an image and a set of attributes for rendering that image.</db:para>
<db:figure xml:id="fig.restructuredtext-1"><db:title>reStructuredText directive</db:title><db:programlisting language="reStructuredText">
.. image:: images/biohazard.png
   :height: 100
   :width: 200
   :scale: 50
   :alt: alternate text
</db:programlisting></db:figure>
<db:para>You extend reStructuredText by adding new directives. However, there is no <db:indexterm><db:primary>schema</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>schema</db:secondary></db:indexterm>schema language for reStructuredText. To create a new directive, you must create code to process it.</db:para>
<db:para>There is an important distinction between languages that are extensible by schema and those that are extensible only by writing code to process the extension.</db:para>
<db:para>If a language is extended by writing processing code, the only way to know if the input is valid is by processing it. If it raises a processing error, it is invalid. If you have only one processor for a language, you can treat that processor as normative. That is, the definition of a correct file is any file that can be successfully processed by the normative processor. The language is defined by the processor. But if you have multiple processors, how do you determine who is at fault when one of those processors fails to process a given input file? Is the processor incorrect or the source file?</db:para>
<db:para>A schema creates a language definition that is independent of any processor. That is, it partitions and redirects the complexity of validation. The schema is normative, not any of the processors. If the source file is valid per the schema, the processor is at fault if it does not process that file correctly. If the source file is not valid per the schema, the blame lies with the source file.</db:para>
<db:para>In the case of reStructuredText, the capacity of the processor to be extended using directives is built into the processor architecture. There is a specific and well-documented way to extend the language. But although reStructuredText allows you to extend the language by adding new directives, it does not have a constraint mechanism. There is no mechanism (other than hacking the code) to restrict the use of existing or new directives and structures.</db:para>
</db:section>
<db:section>
<db:title>TeX</db:title>


<db:para>TeX (pronounced “Tek”) is a typesetting system invented by Donald Knuth in 1978. As a typesetting language it is a concrete <db:indexterm><db:primary>media-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media-domain</db:secondary></db:indexterm>media-domain language. But Knuth also included a macro language in TeX, which allows users to define new commands in terms of existing commands. (I say commands because that is the term used in TeX. Markup in the media domain tends to be much more imperative than markup in the subject domain, which is entirely descriptive, so “commands” is an appropriate name for TeX’s tags.) This macro language has been used to extend TeX, most notably in the form of <db:indexterm><db:primary>LaTeX</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>LaTeX</db:secondary></db:indexterm>LaTeX, a <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain language that I described in <db:xref linkend="chapter.lightweight"/>.</db:para>
<db:para>As noted with <db:indexterm><db:primary>reStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>reStructuredText</db:secondary></db:indexterm>reStructuredText, the ability to extend is not the same thing as the ability to constrain. Introducing new commands does not create a constraint mechanism.</db:para>
</db:section>
<db:section>
<db:title>SAM</db:title>


<db:para>Although lightweight languages provide great <db:indexterm><db:primary>functional lucidity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functional lucidity</db:secondary></db:indexterm>functional lucidity, they suffer from limited extensibility (which generally requires writing code) and a lack of constraint mechanisms. I believe that a fully extensible, fully constrainable lightweight markup language would be a valuable addition to the structured writing toolkit. This is why I developed <db:indexterm><db:primary>SAM</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SAM</db:secondary></db:indexterm>SAM, the markup language used for most of the examples in this book and for writing the book itself.</db:para>
<db:para>As described in <db:xref linkend="chapter.markup"/>, SAM is a hybrid markup language that combines implicit syntax similar to <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown with an explicit syntax for defining abstract structures called blocks, record sets, and annotations. It also has concrete markup for common features such as insertions, citations, and variable definitions.</db:para>
<db:para>SAM, like <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm><db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML, is for defining specific markup languages. However, unlike XML, all languages defined in SAM share a small common base set of text structures for which SAM provides concrete syntax. This allows SAM to combine lightweight syntax for the most common text structures with the ability to define constrained markup languages for specific purposes, particularly <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain languages. In other words, SAM represents a different partitioning of the markup design process from both the common lightweight languages and XML.</db:para>
<db:para>SAM is designed to be extensible and constrainable through a <db:indexterm><db:primary>schema</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>schema</db:secondary></db:indexterm>schema language (this is not complete at time of writing, but hopefully will be available by the time you read this). My intent is that the schema language should be able to define and constrain new block structures, constrain the use of existing concrete structures, and constrain the values of fields using patterns.</db:para>
<db:para>SAM is not designed to be as general as XML in its applications. As a result, its syntax is simple and more <db:indexterm><db:primary>functionally lucid</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functionally lucid</db:secondary></db:indexterm>functionally lucid, and its schema language should also be simpler and make it much easier for writers to develop their own SAM-based markup languages.</db:para>
<db:para>I use SAM for the majority of the examples in this book because SAM is designed to make structure clear. All of the examples could have been expressed in XML, but that would have made them harder to follow. Naturally, to write in SAM you need to know more about the rules of the language, but you should be able to read a typical SAM document and understand its structure with little or no instruction (see <db:xref linkend="fig.SAM-structures"/>).</db:para>
<db:figure xml:id="fig.SAM-structures"><db:title>Basic SAM structures</db:title><db:programlisting language="SAM">
examples: Basic SAM structures

    example: Paragraphs
        The is a sample paragraph. It is inside
        the {block}(structure) called `example`.
        It contains two {annotations}(structure),
        including this one. It ends with a blank
        line.

        This is another paragraph.

    example: Lists

        Then there is a list:

        1. First item.
        2. Second item.
        3. Third item.

    example: Block quote

        Next is a block quote with a {citation}(structure).

        """[Mother Goose]
            Humpty Dumpty sat on a wall.
</db:programlisting></db:figure>
<db:para>This objective is similar, but not identical, to the aim of mainstream concrete and hybrid languages such as <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown and <db:indexterm><db:primary>reStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>reStructuredText</db:secondary></db:indexterm>reStructuredText, which is to have the source file be readable as a document. Those languages are document-domain languages, and they strive to make the document structure clear and readable from the markup. SAM has the same goal, except that SAM was designed primarily for creating <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain languages. As such, SAM is designed to make the subject-domain structure of a document clear to the reader.</db:para>
<db:para>A SAM document may not look as much like a finished document as a <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown or <db:indexterm><db:primary>reStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>reStructuredText</db:secondary></db:indexterm>reStructuredText document. For example, it does not use underlines to visually denote different levels of header. Instead, it focuses on creating a hierarchy of named blocks and fields. In doing so, it uses the kind of markup people commonly use to create named blocks of text and to express a hierarchical relationship between them. As you can see in <db:xref linkend="fig.SAM-structures"/>, blocks are introduced with a name followed by a colon, and hierarchy is expressed through indentation.</db:para>
<db:para>SAM is an open source project. A description of the language and a set of associated tools are available from <db:link xlink:href="https://github.com/mbakeranalecta/sam">https://github.com/mbakeranalecta/sam</db:link>.</db:para>
</db:section>
<db:section>
<db:title>SPFE</db:title>


<db:para><db:indexterm><db:primary>SPFE</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>SPFE</db:secondary></db:indexterm>SPFE is another project of mine. It is designed to be a framework for implementing structured writing algorithms, and its structure follows the model I laid out in <db:xref linkend="chapter.publishing"/>. It is tempting to compare it to <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA as an information typing architecture, but as I commented before, architectures are not necessarily parallel to each other, and they often differ in their emphasis. SPFE takes a different approach to partitioning and distributing content complexity, with a major emphasis on directing content management and information architecture complexity away from writers. Individual writers working in a SPFE system should have to know little or nothing about how SPFE works, as long as they follow the constraints of the markup language they are using.</db:para>
<db:para>SPFE is principally designed for <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain markup. As such, it does not start with a generic document-domain topic type like DITA. SPFE does not require any particular schema, though it does require that <db:indexterm><db:primary>schema</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>schema</db:secondary></db:indexterm>schemas meet certain constraints.</db:para>
<db:para>But SPFE does not leave it entirely to you to develop schemas from scratch. Instead, it supports building schemas from pre-built components. The pre-built components include a collection of semantic blocks and the default processing code for each stage of the publishing algorithm. SPFE also allows you to define your own reusable structured components with processing code. This is, essentially, extensibility through composition, rather than extensibility through specialization (as in <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA) or extensibility through processor extension (as in <db:indexterm><db:primary>reStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>reStructuredText</db:secondary></db:indexterm>reStructuredText). Constraints are supported through normal schema mechanisms and by selecting the minimal required structural components for the individual case.</db:para>
<db:para>By strictly segregating the presentation and formatting layers, SPFE reduces the effort required to process custom markup formats. Custom format are processed to a common document-domain markup language which is then processed to all required media-domain output formats. The SPFE Open Tool Kit includes a basic <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain language for this purpose, but you can also use <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm><db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook or <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA in this role, allowing you to take advantage of their existing publishing capabilities. This also allows you to install SPFE as an authoring layer on top of an existing DITA or DocBook tool chain.</db:para>
<db:para>To create a subject-domain markup language in SPFE, therefore, all you have to define for yourself are the key subject-domain fields and blocks that are essential to your business. All the other elements you need, such as paragraphs, lists, tables, and common annotations, you can include from the pre-built components, along with their default processing code.</db:para>
<db:para>Among its default processing steps, the SPFE process includes support for linking based on <db:indexterm><db:primary>subject annotation</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>subject annotation</db:secondary></db:indexterm>subject annotation as describe in <db:xref linkend="chapter.linking"/>. The <db:indexterm><db:primary>conformance</db:primary></db:indexterm><db:indexterm><db:primary>process</db:primary><db:secondary>conformance</db:secondary></db:indexterm>conformance and <db:indexterm><db:primary>audit</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>audit</db:secondary></db:indexterm>audit algorithms described in <db:xref linkend="part.management"/> are well-supported as well.</db:para>
<db:para>While it has support for <db:indexterm><db:primary>reuse</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm>reuse, SPFE is not as focused on content reuse or content management as <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA. It deliberately limits some of the forms of reuse that tend to produce unmanageable complexity. While it can produce books and <db:indexterm><db:primary>top-down information architecture</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>top-down information architecture</db:secondary></db:indexterm>top-down information architectures, its main focus is <db:indexterm><db:primary>hypertext</db:primary></db:indexterm><db:indexterm><db:primary>media</db:primary><db:secondary>hypertext</db:secondary></db:indexterm>hypertext and <db:indexterm><db:primary>bottom-up information architecture</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>bottom-up information architecture</db:secondary></db:indexterm>bottom-up information architectures. SPFE does not define or require maps as an assembly mechanisms, though you could implement maps in SPFE if you wanted them. SPFE’s processing model is modeled on a software build architecture and it is designed to work well with a <db:indexterm><db:primary>version control system</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>version control system</db:secondary></db:indexterm>version control system system as a repository rather than a <db:indexterm><db:primary>content management system</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>content management system</db:secondary></db:indexterm>content management system. One of its key design objectives is that writers should have to know little or nothing about how SPFE works.</db:para>
<db:para>Both <db:indexterm><db:primary>SAM</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SAM</db:secondary></db:indexterm>SAM and <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm><db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML are supported as markup syntax for SPFE, and you can freely mix and match SAM and XML content.</db:para>
<db:para>SPFE is an open source project available from <db:link xlink:href="https://github.com/mbakeranalecta/spfe-open-toolkit">https://github.com/mbakeranalecta/spfe-open-toolkit</db:link>.</db:para>
<db:indexterm class="endofrange" startref="idp1902948020"/><db:indexterm class="endofrange" startref="idp1902946740"/><db:indexterm class="endofrange" startref="idp1902948020x"/><db:indexterm class="endofrange" startref="idp1902946740x"/></db:section>
</db:chapter>
