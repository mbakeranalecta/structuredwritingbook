<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.active"><db:title>Active content</db:title><db:indexterm class="startofrange" xml:id="idm1071488700"><db:primary>concept</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm1071488700x"><db:primary>active content</db:primary><db:secondary>concept</db:secondary></db:indexterm>



<db:para>When you publish to electronic media, you can create active content, that is, content that has behavior as well as formatting. Some examples:</db:para>
<db:variablelist>
<db:varlistentry>
<db:term>Personalized content</db:term>
<db:listitem><db:para>You can select and arrange content for individual readers based on the things you know about them. For instance, if you are logged into Amazon it customizes elements of every page based on your previous purchases, your wishlist, and things you previously browsed.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Dynamic arrangement</db:term>
<db:listitem><db:para>Part of the <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm>presentation algorithm is arranging content on the page or screen, but with online media you can allow the reader to arrange the content. For instance, you can publish tables that readers can sort for themselves.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Adaptive content</db:term>
<db:listitem><db:para>Similarly, you can create content that adapts itself dynamically to the view port in which it is displayed. For instance, displaying in multiple columns on a wide view port, and in a single column on a narrow one.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Progressive disclosure</db:term>
<db:listitem><db:para>You can present content in a way that only shows part of the content on the screen initially but reveals more when the user clicks on a link or takes another action. For instance, you might show the high-level of a procedure and provide a link that opens detailed steps for those who need them. This is a way to cater to audiences with different levels of preparedness.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Feeds and dynamic sources</db:term>
<db:listitem><db:para>You can include content that comes from an external source which updates independently of your content such as a feed or a web service.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Interactive media</db:term>
<db:listitem><db:para>You can include apps, widgets, and other media that the user can interact with.</db:para></db:listitem>
</db:varlistentry>
</db:variablelist>
<db:para>Active content is simply the postponement of one or more of the structured writing algorithms to the time of reading. Personalized content is executing the <db:indexterm><db:primary>synthesis algorithm</db:primary></db:indexterm>synthesis algorithm on the server when you request a page, using personal details as query terms to select content for the individual. Changing the layout of the page when you resize you browser or rotate your phone is executing the <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm>presentation algorithm in the browser. Allowing the reader to change the font size is allowing the reader to configure and execute the <db:indexterm><db:primary>formatting algorithm</db:primary></db:indexterm>formatting algorithm in the browser. Pulling a live stock quote into a page that mentions a company is having the web server or the web browser executes the <db:indexterm><db:primary>synthesis algorithm</db:primary></db:indexterm>synthesis algorithm when the page is served/displayed.</db:para>
<db:para>In principle, therefore, you support active content in exactly the same way you support those algorithms in any form of structured writing: by creating your content in the appropriate domain and with the appropriate structures to reliably support the algorithms you want to run. Reliability is key here, of course. If you are creating static books or web pages you may be able to get away with reviewing the results before they are published and even hand tweaking the output to fix any issues, but you can’t do that with active content. You need to be able to trust the algorithm 100%, which means you need to trust the content it is working on 100%. This makes the <db:indexterm><db:primary>conformance algorithm</db:primary></db:indexterm>conformance algorithm crucial to an active content project, and, as we have seen, different domains support the <db:indexterm><db:primary>conformance algorithm</db:primary></db:indexterm>conformance algorithm with varying degrees of reliability.</db:para>
<db:para>Another factor to consider, though, is that while active content is essentially just postponing the point at which you execute various structured writing algorithms until the content is in the user’s hands, you don’t necessarily want to postpone running those algorithms on the whole page. You usually only postpone them for the parts of the page that you want to make active. For instance, if you want real-time stock quotes embedded in your business stories whenever a company is mentioned, there is no reason to postpone the <db:indexterm><db:primary>synthesis</db:primary></db:indexterm>synthesis, <db:indexterm><db:primary>presentation</db:primary></db:indexterm>presentation, and <db:indexterm><db:primary>formatting</db:primary></db:indexterm>formatting of the entire page; you only need to postpone the synthesis of the stock quote itself. And if you want that quote to continue to update in real time while the page is displayed, you certainly don’t want to be redrawing the whole page every time the price changes.</db:para>
<db:para>The display of stock quotes depends on <db:indexterm><db:primary>subject domain</db:primary></db:indexterm>subject domain metadata that unambiguously identifies the company mentioned in the content. For example:</db:para>
<db:programlisting language="sam">
{Microsoft}(company "NASDAQ:MSFT") is a large software company.
</db:programlisting>
<db:para>In a normal static publishing flow, this <db:indexterm><db:primary>subject domain</db:primary></db:indexterm>subject domain information would be resolved into a static piece of content by the <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm>presentation algorithm:</db:para>
<db:blockquote>
<db:para><db:emphasis role="bold">Microsoft</db:emphasis> US$60.29 +0.34 (+0.57%) is a large software company.</db:para>
</db:blockquote>
<db:para>But for active content the main <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm>presentation algorithm needs to pass through the <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm>subject-domain information to the browser so that that bit of synthesis can be executed in real time when the content is displayed.</db:para>
<db:para>This means that only those parts of the content that you want displayed as active content need to be captured in the structured writing domain, and in the specific structures, required to reliably run the applicable algorithms. The rest of the content can be in a different domain. In practice, this usually means that you have <db:indexterm><db:primary>subject domain</db:primary></db:indexterm>subject domain structures to support the active content embedded in <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain structures. Of course, having all your content in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm>subject domain is also an option, in which case you would perform the <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm>presentation algorithm on the content you want to deliver statically, while passing on the <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm>subject-domain representation of the content you want to be active to the system that will perform the active content algorithms.</db:para>
<db:para>However, this is not necessarily, or even likely, to be a straightforward pass through. The downstream system that is going to execute the active content algorithm, such as a JavaScript app running in the web browser, may expect or require the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm>subject domain information it uses in a particular format. For instance, you might have to embed the ticker symbol in a call to a function that returns stock quotes:</db:para>
<db:programlisting language="xml">
&lt;p&gt;Microsoft (&lt;span onload="getStockQuote(NASDAQ:MSFT)"/&gt;) 
is a large software company.&lt;/p&gt;
</db:programlisting>
<db:para>So your server side <db:indexterm><db:primary>presentation algorithm</db:primary></db:indexterm>presentation algorithm needs to transform your <db:indexterm><db:primary>subject domain</db:primary></db:indexterm>subject domain annotation into this format.</db:para>
<db:programlisting language="pseudocode">
match company
    continue
    $fncall = 'getStockQuote(' + @specifically + ')'
    output ' ('
    create span
        create attribute onload = $fncall
    output ') '
</db:programlisting>
<db:para>The <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain represents the desired presentation of a piece of content. Therefore the only kinds of active content algorithms that you can execute on ordinary <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain structures are those that leave the <db:indexterm><db:primary>presentation</db:primary></db:indexterm>presentation alone and only affect the <db:indexterm><db:primary>formatting</db:primary></db:indexterm>formatting. For example, you can allow readers to select the font size of a web page, which is a purely formatting concern.</db:para>
<db:para>If you want to do active content that dynamically changes the presentation of the content, or that changes the text of the content (as in our stock price example) then you need either <db:indexterm><db:primary>subject domain</db:primary></db:indexterm>subject domain structures or <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain structures that are explicitly designed to support active content algorithms.</db:para>
<db:para>For example, a generic table structure does not support the action of allowing the reader to sort on any column. Sorting by column only makes sense if the content is inherently sortable.</db:para>
<db:informaltable><db:tbody>
<db:tr>
<db:td><db:emphasis role="bold">item</db:emphasis></db:td>
<db:td><db:emphasis role="bold">legs</db:emphasis></db:td>
<db:td><db:emphasis role="bold">price</db:emphasis></db:td>
</db:tr>
<db:tr>
<db:td>table</db:td>
<db:td>4</db:td>
<db:td>$400</db:td>
</db:tr>
<db:tr>
<db:td>stool</db:td>
<db:td>3</db:td>
<db:td>$20</db:td>
</db:tr>
<db:tr>
<db:td>shooting stick</db:td>
<db:td>1</db:td>
<db:td>$75</db:td>
</db:tr>
<db:tr>
<db:td>chair</db:td>
<db:td>4</db:td>
<db:td>$60</db:td>
</db:tr>
</db:tbody></db:informaltable>
<db:para>For example, in the table above the columns are sortable. The reader could choose to sort the table on the item name, the number of legs, or the price, all of which might be useful arrangements, based on their needs.</db:para>
<db:para>But consider what might happen if you sorted this table on the second column:</db:para>
<db:informaltable><db:tbody>
<db:tr>
<db:td>1.</db:td>
<db:td>Don protective clothing.</db:td>
</db:tr>
<db:tr>
<db:td>2.</db:td>
<db:td>Clear the area.</db:td>
</db:tr>
<db:tr>
<db:td>3.</db:td>
<db:td>Block all entrances.</db:td>
</db:tr>
<db:tr>
<db:td>4.</db:td>
<db:td>Activate the destruct sequence.</db:td>
</db:tr>
</db:tbody></db:informaltable>
<db:para>Thus you can’t just decide to make all the tables on a page sortable by column. Unless the <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain structure explicitly states which columns of a table are sortable and which are not, you can’t implement this kind of active content.</db:para>
<db:para>To implement column sorting at the <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain level, therefore, you need some sort of sortable table structure which assures that the sorting behavior is only applied to columns where it makes sense in tables where it makes sense.</db:para>
<db:para>While the <db:indexterm><db:primary>document domain</db:primary></db:indexterm>document domain typically requires different markup for different algorithms, the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm>subject domain typically does not. In the subject domain you capture the semantics of the subject matter, which are the same no matter what algorithms you are applying to the content.</db:para>
<db:para>In the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm>subject domain, the product list would be a structured data set with known semantics (probably maintained as a separate database).</db:para>
<db:programlisting language="sam">
products:: item, legs, price
    table, 4, $400      
    stool, 3, $20             
    shooting stick, 1, $75
    chair , 4, $60
</db:programlisting>
<db:para>Knowing what the semantics are, you would know whether that data set is sortable and therefore whether it can be presented as a sortable table.</db:para>
<db:para>Creating your content in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm>subject domain gives you the greatest flexibility to generate active content in ways that are appropriate to the subject matter and the device. And because the subject domain does not require any different structures to support active content, your writers don’t have to understand or even think about how the active content might work, effectively partitioning the complexity of active content from your writers. As we have seen before, an additional benefit of partitioning content from its presentation is that it allows you to experiment with different forms of presentation. This allows you to test if active content is working or not or change the form of active content you use, all without involving writers of changing your content.</db:para>
<db:para>This does not mean that active content is always going to be a free gift of the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm>subject domain. Apart from the fact that you still have to design and implement the content behavior, you are going to have to make sure that you are capturing the subject domain semantics that are needed to drive the active content behaviors you want. Those semantics may not be different in kind from any other subject domain semantics, but you may need to break things down in greater detail than you might have to for other algorithms. You will also need to make sure that you get a high degree of <db:indexterm><db:primary>conformance</db:primary></db:indexterm>conformance to these structures from your writers, as it is difficult to validate the correct operation of every active content algorithm on every content set at run time. The success of your active content strategy is going to depend heavily on the <db:indexterm><db:primary>quality</db:primary></db:indexterm>quality and consistency of your input data.</db:para>
<db:indexterm class="endofrange" startref="idm1071488700"/><db:indexterm class="endofrange" startref="idm1071488700x"/></db:chapter>
