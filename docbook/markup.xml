<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.markup"><db:title>Markup</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idm789208588"><db:primary>markup</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm789208588x"><db:primary>concept</db:primary><db:secondary>markup</db:secondary></db:indexterm>




<db:para>If structures in structured writing consist of nested blocks, the way those blocks are expressed in text is (most of the time) through markup. Markup is, essentially, the insertion of metadata into a text to constrain the creation and interpretation of that text. We have been looking at structured writing examples expressed in markup all through this book. Now let’s look at markup itself.</db:para>
<db:para>Markup has long been part of partitioning and distribution of content creation. For centuries, scribes worked directly in the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain, using pen and ink to inscribe words and pictures on papyrus or velum. With the printing press, however, came a fundamental partitioning of the publishing process. Writers no longer worked directly in the media domain. While writers still placed ink directly on paper, at first by pen and then by typewriter, they no longer prepared the final visual form of the content. That task was partitioned off and directed to the typesetter.</db:para>
<db:para>To tell the typesetter how to create the final visual form, document designers added instructions (metadata) to the writer’s manuscript. The designers did this using typesetter’s marks, and the process was called “marking up” the document (see <db:xref linkend="typesetter"/>). We still use “marking up” to describe how structured writing is done today and the term “markup language” to describe the languages used for most structured writing.</db:para>
<db:figure xml:id="typesetter"><db:title>Printer’s markup</db:title><db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/printermarkup-print.png" contentwidth="5.0in" align="center"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/printermarkup-ebook.png"/></db:imageobject><db:textobject><db:para>Printer markup example.</db:para></db:textobject></db:mediaobject></db:figure>

<?dbfo-need height="1in"?>

<db:para>The writer preparing a manuscript for typesetting worked in the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, using basic document structures, such as paragraphs, lists, and titles, without any indication of how they should look in print. The designer then wrote a set of instructions for applying formatting to those structures – a <db:indexterm><db:primary>formatting algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>formatting algorithm</db:secondary></db:indexterm>formatting algorithm. Then the typesetter executed that algorithm by setting the type, which the printer used to print final output.</db:para>
<db:para>This is almost exactly what you do today when you create an HTML page and specify a CSS style sheet to supply the formatting instructions. A browser then executes those instructions to render the content  on screen or paper.</db:para>
<db:para>Actually, a better analogy to old-style typesetter’s marks is an HTML page with inline styles:</db:para>
<db:programlisting language="HTML">
&lt;p style="font-family: serif; font-weight: bold; 
 font-size: 12pt"&gt;
</db:programlisting>
<db:para>You can see that this markup is very similar to the typesetters marks in <db:xref linkend="typesetter"/>.</db:para>
<db:para>All writing programs have to store the content you write in files. There are two possible file types they can use: binary and text.</db:para>
<db:para>A binary file can only be read or written by a computer program, usually the program that created it. Open up a binary file in a text editor, and you won’t be able to make heads or tails of it. Even if parts of it look like plain text, editing those sections and saving the file is likely to result in a corrupt file that the original application can no longer open.</db:para>
<db:para>A text file, by contrast, is one that you can open in a text editor and read and write without breaking it. But to express structure in a text file, you need to interpolate information about structure into the text. The way you interpolate structure is with markup – special sequences of text characters that are recognized as defining structure rather than expressing text.</db:para>
<db:para><db:xref linkend="fig.formatted-code"/> contains a snippet of HTML with markup characters shown in bold and plain text shown in regular type.</db:para>
<db:figure xml:id="fig.formatted-code"><db:title>HTML snippet with markup highlighted</db:title><db:programlisting>
<db:emphasis role="bold">&lt;h1&gt;</db:emphasis>Moby Dick<db:emphasis role="bold">&lt;/h1&gt;</db:emphasis>
<db:emphasis role="bold">&lt;p&gt;</db:emphasis>Herman Melville’s <db:emphasis role="bold">&lt;i&gt;</db:emphasis>Moby Dick<db:emphasis role="bold">&lt;/i&gt;</db:emphasis> is a long 
book about a big whale.<db:emphasis role="bold">&lt;/p&gt;</db:emphasis>      
</db:programlisting></db:figure>
<db:para>A markup parser recognizes the markup characters and builds a structure that has the text and nested structures as content. A processing application then accesses that data and applies rules to the structures defined by the markup, as described in <db:xref linkend="chapter.processing"/>.</db:para>
<db:section>
<db:title>Markup vs. regular text</db:title>

<db:para>Some markup languages define markup in universal terms. That is, the characters that define markup are recognized as markup no matter where they occur in the file. One example is an HTML tag. Tags are set off by opening and closing angle brackets:</db:para>
<db:programlisting>
<db:emphasis role="bold">&lt;h1&gt;</db:emphasis>      
</db:programlisting>
<db:para>HTML uses open angle brackets (<db:code>&lt;</db:code>) to indicate the start of markup and closing angle brackets (<db:code>&gt;</db:code>) to indicate the end of markup and a return to regular text. A slash (<db:code>/</db:code>) after the opening angle bracket indicates an end tag, which marks the end of a structure:<db:footnote>
<db:para>Actually, the recognition of  markup in languages like XML and HTML is a little more complicated than that. Sequences of characters are recognized rather than individual characters, and therefore, no individual character is universally recognized as markup. But the main point is simply that certain specific sequences in the text trigger a processing program (generally called a <db:emphasis>parser</db:emphasis>) to recognize when markup starts and ends.</db:para>
</db:footnote></db:para>
<db:programlisting>
<db:emphasis role="bold">&lt;h1&gt;</db:emphasis>Moby Dick<db:emphasis role="bold">&lt;/h1&gt;</db:emphasis>
</db:programlisting>

<db:para>Every element in HTML uses the same syntax. Any element with a name that is not recognized as part of HTML is still treated as an element, which the HTML parser will handle as a markup error (usually by ignoring it).</db:para>
<db:para>What if you want to enter a markup-start character into the text of your document without having it interpreted as markup? You can’t just type it in because the parser will think it is markup. To fix this, markup languages either define an escape character, which tells the parser to treat the following character as text, or they include markup for inserting individual characters in a way that won’t be confused with markup characters.</db:para>
<db:para>HTML takes the second approach. To include a <db:code>&lt;</db:code> character in HTML, you use what is called a <db:emphasis>character entity</db:emphasis>. A character entity is a code for a character. It begins with another markup-start character, an ampersand (<db:code>&amp;</db:code>), followed by a character code, and ends with a semicolon. The character entity for <db:code>&lt;</db:code> in HTML and XML is <db:code>&amp;lt;</db:code> (<db:code>lt</db:code> is short for “less than”).</db:para>
<db:programlisting language="html">
&lt;p&gt;In HTML, tags start with the &amp;lt; character.&lt;/p&gt;
</db:programlisting>
<db:para>This displays as:</db:para>
<db:blockquote>
<db:para>In HTML, tags start with the &lt; character.</db:para>
</db:blockquote>
<db:para>Since <db:code>&amp;</db:code> is also a markup start character, you need to replace it with a character entity if you want to include it literally. To include a literal <db:code>&amp;</db:code> you use the character entity <db:code>&amp;amp;</db:code>.</db:para>
<db:programlisting language="html">
&lt;p&gt;In HTML, character entities start 
with the &amp;amp; character.&lt;/p&gt;
</db:programlisting>
<db:para>This will display as:</db:para>
<db:blockquote>
<db:para>In HTML, character entities start with the &amp; character.</db:para>
</db:blockquote>
<db:para>Therefore, to include the literal string <db:code>&amp;amp;</db:code> you write <db:code>&amp;amp;amp;</db:code>.</db:para>
<db:programlisting language="html">
&lt;p&gt;The character entity for an ampersand is &amp;amp;amp;.&lt;/p&gt;
</db:programlisting>
<db:para>This will display as:</db:para>
<db:blockquote>
<db:para>The character entity for an ampersand is &amp;amp;.</db:para>
</db:blockquote>
<db:para>Other markup languages do not make a universal distinction between text and markup. For example, in <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown, you create a numbered list by putting numbers in front of list items:</db:para>
<db:programlisting language="markdown">
1. First
2. Second
3. Third
</db:programlisting>
<db:para>Here, the numbers are markup. That is, the Markdown processor recognizes them as indicating a list and translates them into an <db:indexterm><db:primary>HTML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>HTML</db:secondary></db:indexterm><db:indexterm><db:primary>HTML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>HTML</db:secondary></db:indexterm>HTML structure like this:</db:para>
<db:programlisting language="html">
&lt;ol&gt;
    &lt;li&gt;First&lt;/li&gt;
    &lt;li&gt;Second&lt;/li&gt;
    &lt;li&gt;Third&lt;/li&gt;
&lt;/ol&gt;
</db:programlisting>
<db:para>But numbers followed by a period are only markup in a certain context – the beginning of a line. Elsewhere, they are plain text. You don’t need to escape numbers followed by periods when they occur elsewhere in the text. One consequence of this is that you cannot have a markup error in processing Markdown. Anything that is not recognized as markup is simply treated as plain text. (You can certainly make mistakes in marking up up a document in Markdown, but the Markdown processor will not catch them because it will simply treat your incorrect markup as plain text. This is why Markdown editors often use split screen editing, so you can catch your errors visually.)</db:para>

<?dbfo-need height="1.5in"?>

<db:para>Thus, the following Markdown file:</db:para>
<db:programlisting language="markdown">
1. First comes 1.
2. Second comes 2.
3. Third comes 3.
</db:programlisting>
<db:para>translates to HTML as:</db:para>
<db:programlisting language="html">
&lt;ol&gt;
    &lt;li&gt;First comes 1.&lt;/li&gt;
    &lt;li&gt;Second comes 2.&lt;/li&gt;
    &lt;li&gt;Third comes 3.&lt;/li&gt;
&lt;/ol&gt;
</db:programlisting>
<db:para>In Markdown, then, markup is not defined in universal terms. It is a pattern recognized in context. Therefore, rather than thinking of markup as being distinct from text, it is better to think of markup as being a pattern within a piece of text that delineates its structure. In some cases the patterns are universal and have the same meaning everywhere, and sometimes they are contextual and have one meaning in some locations and another meaning elsewhere. Sometimes the markup characters are distinct from the text characters, and sometimes a pattern in the text serves as markup.</db:para>
</db:section>
<db:section>
<db:title>Markup languages</db:title>

<db:para>A set of markup conventions taken together constitutes a markup language.  <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown, <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook, and <db:indexterm><db:primary>reStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>reStructuredText</db:secondary></db:indexterm>reStructuredText are all markup languages. However, each of these languages recognizes markup in a different way. An ampersand (<db:code>&amp;</db:code>) is a markup start character in <db:indexterm><db:primary>HTML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>HTML</db:secondary></db:indexterm>HTML and <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML, but it is a plain text character in <db:indexterm><db:primary>reStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>reStructuredText</db:secondary></db:indexterm>reStructuredText.</db:para>
<db:para>We can usefully divide markup languages into three types: concrete, abstract, and hybrid.</db:para>
<db:section>
<db:title>Concrete markup languages</db:title>


<db:para>A concrete markup language has a fixed set of markup patterns that describe a fixed set of content structures. For example, <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown is a concrete markup language that uses a markup that is designed to mimic the way people write plain text email.</db:para>

<?dbfo-need height="1.25in"?>

<db:para>Here is the passage about <db:indexterm><db:primary>Moby Dick</db:primary></db:indexterm><db:indexterm><db:primary>citetitle</db:primary><db:secondary>Moby Dick</db:secondary></db:indexterm><db:citetitle>Moby Dick</db:citetitle> written in Markdown:</db:para>
<db:programlisting language="markdown">
Moby Dick
=========

Herman Melville's _Moby Dick_ is a long book about a big whale.
</db:programlisting>
<db:para>In <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown, a line of text underlined with equal signs (<db:code>=</db:code>) is a level-one heading. A paragraph is a block of text set off by blank lines. Emphasized text is surrounded with underscores or asterisks.</db:para>
<db:para>In Markdown, these patterns correspond directly to specific document structures. You cannot invent new structures without inventing a new version of Markdown.</db:para>
</db:section>
<db:section>
<db:title>Abstract markup languages</db:title>


<db:para>An abstract markup language does not describe specific concrete document structures directly. It describes abstract markup structures, which can be named to represent structures in any domain.</db:para>
<db:para>XML is an example of an abstract markup language.<db:footnote>
<db:para>The formal term for a language like XML is “meta language,” a language for describing other languages. In calling XML an <db:emphasis>abstract</db:emphasis> language, I am focusing on a different property, its use of structures that are not parts of a document but generic containers. A meta language needs such abstract containers, but I find that the term meta language is not helpful to most readers. Therefore, I have chosen to focus on this property of using abstract structures as opposed to the concrete structures of a language like Markdown.</db:para>
</db:footnote> The markup in an XML file does not directly indicate things such as headings or paragraphs. Instead, it indicates a set of abstract structures called elements, attributes, entities, processing instructions, marked sections, and comments.</db:para>

<db:para>None of these abstract structures describes document structures in any of the structured writing domains. Instead, markup languages based on XML (or its cousin, SGML) indicate subject-, document-, management-, or <db:indexterm><db:primary>media-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media-domain</db:secondary></db:indexterm>media-domain structures as named instances of elements and attributes.</db:para>

<?dbfo-need height="2in"?>

<db:para>Here is the <db:indexterm><db:primary>Moby Dick</db:primary></db:indexterm><db:indexterm><db:primary>citetitle</db:primary><db:secondary>Moby Dick</db:secondary></db:indexterm><db:citetitle>Moby Dick</db:citetitle> passage again, this time in <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML (more specifically, in <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook):</db:para>
<db:programlisting language="DocBook">
&lt;section&gt;
    &lt;title&gt;Moby Dick&lt;/title&gt;
    &lt;para&gt;Herman Melville's &lt;citetitle&gt;Moby Dick&lt;/citetitle&gt; 
    is a long book about a big whale.&lt;/para&gt;
&lt;/section&gt;
</db:programlisting>
<db:para>The structure described by the XML syntax here is an element (<db:code>section</db:code>), which contains two other elements (<db:code>title</db:code> and <db:code>para</db:code>), one of which contains text (<db:code>title</db:code>), and one of which (<db:code>para</db:code>) contains a mix of text and another element (<db:code>citetitle</db:code>). There is no separate syntax for titles or paragraphs as there is in Markdown. Everything is an element, and every element has a name. To define specific document-domain structures, you use named elements. This allows you to create any set of named elements you like to represent any structure you need.</db:para>
<db:para>Unlike a <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown parser, an XML parser does not see paragraphs or titles. It sees elements. It passes the elements it finds, along with their names, to a processing application that is responsible for knowing what the <db:code>section</db:code>, <db:code>title</db:code>, and <db:code>para</db:code> elements mean in a particular markup language, such as DocBook. The parser is common to all XML-based languages, but the processing application is specific to <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook.</db:para>
<db:para>Thus, while processing a concrete language like Markdown is generally a one-step operation, processing an abstract language like XML is a two step-operation. The first step parses the file to discover the structures defined by elements, and the second step processes those structures according to a set of rules applicable to a particular markup language.</db:para>
<db:section>
<db:title>Instances of abstract markup languages</db:title>

<db:para>This means that <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook is a instance of the abstract language <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML.<db:footnote>
<db:para>Or to put it another way, you write in DocBook semantics using XML syntax. Alternatively, since DocBook originated in the days of XML’s predecessor abstract language, SGML, you can write DocBook semantics in SGML syntax.</db:para>
</db:footnote> XML defines abstract structures, and DocBook defines concrete structures by giving names to XML elements. Many common markup languages are instances of XML.<db:footnote>
<db:para>Sometimes also referred to as “applications” of XML, though this usage was far more common in the days of SGML.</db:para>
</db:footnote> XML is virtually the only abstract language used for content these days, so it is the only abstract language I am going to talk about.</db:para>

<db:para>Since specific markup languages like <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook are instances of <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML, I need to revise my earlier statement: We can usefully divide markup languages into <db:emphasis role="bold">four</db:emphasis> types: concrete, abstract, instances of abstract, and hybrid. In fact (spoiler alert), let’s revise it again: We can usefully divide markup languages into <db:emphasis role="bold">five</db:emphasis> types: concrete, abstract, instances of abstract, hybrid, and instances of hybrid.</db:para>
<db:para>You can’t write directly in a abstract language like XML, only in an instance. You can write directly in some hybrid languages, as I’ll describe later in this chapter, but not in all of them.</db:para>


<?dbfo-need height="1.5in"?>

<db:para>Or to put it another way, as a designer of markup languages you can choose to:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>Design a concrete language from scratch (or modify and existing one)</db:para>
</db:listitem>
<db:listitem>
<db:para>Use an abstract language (probably XML) to design a concrete language</db:para>
</db:listitem>
<db:listitem>
<db:para>Use a hybrid language to design a concrete language</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>As a writer, you can use:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>A concrete language with ad-hoc syntax (like <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown)</db:para>
</db:listitem>
<db:listitem>
<db:para>The concrete parts of a hybrid markup language (like <db:indexterm><db:primary>ReStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>ReStructuredText</db:secondary></db:indexterm>ReStructuredText) without extensions</db:para>
</db:listitem>
<db:listitem>
<db:para>A concrete language (like <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook) based on an abstract language (probably XML)</db:para>
</db:listitem>
<db:listitem>
<db:para>A concrete language (like the recipe markup language used in this book) based on a hybrid language (<db:indexterm><db:primary>SAM</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SAM</db:secondary></db:indexterm>SAM in this case)</db:para>
</db:listitem>
</db:itemizedlist>
</db:section>
<db:section>
<db:title>Concrete languages in abstract clothing</db:title>

<db:para>The key defining characteristic of an abstract language is the use of abstract named structures such as XML elements. All XML elements share a common markup start sequence followed by the element name. This creates a named block of content.  But concrete languages can use named blocks too. For example, <db:indexterm><db:primary>JavaDoc</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>JavaDoc</db:secondary></db:indexterm>JavaDoc, a concrete language for describing Java APIs, uses named blocks using and at sign (<db:code>@</db:code>) as a markup start character.</db:para>
<db:para>In <db:xref linkend="fig.javadoc"/>, <db:code>@param</db:code> and <db:code>@return</db:code> are named blocks. But in JavaDoc, there is a fixed set of named blocks that are defined as part of the language. You can’t create a new language by defining your own block names. By contrast, <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML itself defines absolutely no element names. Only instances of XML, like <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook, define element names.</db:para>
<db:figure xml:id="fig.javadoc"><db:title>JavaDoc code fragment</db:title><db:programlisting language="Java">
/**
 * Validates a chess move.
 *
 * Use {@link #doMove(int theFromFile, int theFromRank, 
 * int theToFile, int theToRank)} to move a piece.
 *
 * @param theFromFile file from which a piece is being moved
 * @param theFromRank rank from which a piece is being moved
 * @param theToFile   file to which a piece is being moved
 * @param theToRank   rank to which a piece is being moved
 * @return            true if the move is valid, otherwise false
 */
boolean isValidMove(int theFromFile, int theFromRank, 
int theToFile, int theToRank) {
    // ...body
}
</db:programlisting></db:figure>
<db:para>A particularly notable example of a concrete language in abstract clothing is <db:indexterm><db:primary>HTML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>HTML</db:secondary></db:indexterm>HTML. HTML looks a lot like an instance of <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML, but it is not. An XML parser cannot parse most HTML. HTML is nominally an instance of SGML but never did quite conform to it. HTML generally requires a specific HTML parser, such as is found in all browsers. XHTML is a version of HTML that is an instance of XML. HTML5 actually supports two different syntaxes, one of which is an instance of XML and one of which is not, meaning that it has both a concrete syntax and a syntax which is a instance of an abstract language.<db:footnote>
<db:para>This is consequence of the long history of HTML and the wild-west approach to both syntax and semantics during the browser wars, leading to significant backward-compatibility problems for today’s browsers. This illustrates one of the perils of writing in the media and document domains. Languages in these domains evolve over time to meet new needs and resolve old problems, but this evolution creates backward compatibility problems for documents written in old versions of the format. Formats can evolve in the subject domain as well; however, because subject-domain markup records facts about the subject matter, and not formatting or presentation decisions, it is inherently more stable, and you can pull old subject-domain content into new document- and media-domain formats simply by updating the publishing algorithms.</db:para>
</db:footnote></db:para>

</db:section>
<db:section>
<db:title>The ability to extend</db:title>

<db:para>The downside of concrete languages is that their concrete syntax defines a fixed set of structures. If you want other structures, there is no way to create them short of inventing your own concrete language, or a variant of an existing one, and coding the parser and all the other tools required to interpret that language. Designing new concrete languages is non-trivial because you must ensure that any combination of characters that the writer types can be interpreted unambiguously. Some versions of <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown, including the original, contain ambiguities about how to interpret certain sequences of characters, which detracts from its reliability and <db:indexterm><db:primary>functional lucidity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>functional lucidity</db:secondary></db:indexterm>functional lucidity.</db:para>
<db:para>If you want to define your own structures to express the constraints that matter to your business, you need an easier method. Abstract languages such as XML make this much easier. You create a <db:indexterm><db:primary>schema</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>schema</db:secondary></db:indexterm>schema that describes the structures you want and write algorithms to process those structures. (I talk about schemas in <db:xref linkend="chapter.constraints"/>.)</db:para>
</db:section>
<db:section>
<db:title>The ability to constrain</db:title>

<db:para>Extensibility allows you to add structures to a language but does not place restrictions on where they can occur. Constraints let you limit where structures can be used.</db:para>
<db:para>Extensibility allows you to have elements called <db:code>ingredient</db:code> and <db:code>wine-match</db:code>. Constraints allow you to require that <db:code>ingredient</db:code> only occurs inside an <db:code>ingredients</db:code> structure and that the content of the <db:code>ingredients</db:code> structure must be a sequence of <db:code>ingredient</db:code> elements and nothing else. Constraints let you say that writers can put <db:code>wine-match</db:code> inside <db:code>recipe</db:code> after the <db:code>servings</db:code> field and before the <db:code>prep-time</db:code> field but not in the <db:code>introduction</db:code> or in a <db:code>step</db:code> in the <db:code>preparation</db:code>. Constraints allow you to require that every recipe have the full list of nutritional information.</db:para>
<db:para>Constraints allow you to partition the content system by creating reliable interfaces between different people and processes. All markup languages have constraints. With a concrete language, you get the constraints that are built into the language. Abstract languages allow you to define your own structures and your own constraints. However, as we shall see in <db:xref linkend="chapter.extensible"/>, not all languages that are extensible are also constrainable.</db:para>
</db:section>
<db:section>
<db:title>Showing and hiding structure</db:title>

<db:para>To reliably create structured content, writers need to see the structures they are creating. In the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain a WYSIWYG interface shows you the media-domain structures you are creating by visually rendering them on screen. But what about the other domains? The <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain creates abstract document structures that are deliberately separated from their formatting. The <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain creates subject-based structures that don’t have a one-to-one relationship with any organization or formatting of a document. The <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain creates structures that have nothing to do with the representation of content at all. How does the writer get to see these structures when writing in these domains?</db:para>
<db:para>This is a big problem with <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML, the only abstract language in widespread use today. XML tends to hide structure. As an abstract language, an XML document is a hierarchy of elements and attributes – not the concrete subject-, document-, management-, or <db:indexterm><db:primary>media-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media-domain</db:secondary></db:indexterm>media-domain structures the writer is supposed to be creating. Those concrete structures are present in the markup because their names are there, but they are not visually distinguished the way the basic document structures are in a concrete language like <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown. And XML syntax is verbose, meaning that there is a lot of clutter in the raw text of an XML document, which makes it hard to discern both the structure and the content. XML’s verbose syntax and strict hierarchy were designed to make it easy to parse and to help guard against transmission errors. It was not designed to be a format to write in. Thus, it does a poor job of partitioning parsing issues from authoring issues.</db:para>
<db:para>To remove that clutter, many writers use XML editors that provide a graphical view of the content similar to that of a word processor. But while graphical XML editors remove visual clutter, they also hide the structure. Even if the writer is supposed to be working in the document domain or the subject domain, the editor is displaying content in the media domain. This greatly reduces the functional lucidity of the <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain or <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain language and encourages backsliding into the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain.</db:para>
<db:para>And then there are the problems that arise when you try to edit the graphical view of an XML document. Underneath is a hierarchical XML structure, but all you can see is the flat media-domain view of the graphical editor. Editing or cutting and pasting structures you can’t see can be frustrating and time consuming. You can learn to do it, but even when you learn, the process is still more complicated than it should be. Most editors let you turn on a hybrid view where you see a graphical representation of the XML tags in the WYSIWYG view. Although you can manipulate the tags in this view, this is a complex interface that requires a lot of attention and study to use effectively.</db:para>
<db:para>Concrete markup languages like Markdown, on the other hand, show you the structure you are creating and are simple to edit.</db:para>
</db:section>
</db:section>
<db:section>
<db:title>Hybrid languages</db:title>


<db:para>As we have seen, there are significant advantages and significant disadvantages to both concrete and abstract languages. Hybrid languages try to find a middle way.</db:para>
<db:para>By hybrid, I mean a language that combines both abstract and concrete markup in one language. A hybrid language has a base set of concrete syntax describing basic text structures, but it also has abstract structures, such as XML’s elements and attributes, that can be the basis of extensibility and constraint.</db:para>
<db:para>An example of a hybrid markup language is <db:indexterm><db:primary>reStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>reStructuredText</db:secondary></db:indexterm>reStructuredText. Like <db:indexterm><db:primary>Markdown</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>Markdown</db:secondary></db:indexterm>Markdown, it has a basic concrete syntax for things like lists and paragraphs. But it also supports what it calls <db:emphasis>directives</db:emphasis>, which are essentially named block structures. For example, a code block in reStructuredText looks like this:</db:para>
<db:programlisting language="reST">
.. code-block:: html
    :linenos:
    
    for x in range(10):
        print(x+1, "Hello, World")
</db:programlisting>
<db:para><db:indexterm><db:primary>reStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>reStructuredText</db:secondary></db:indexterm>reStructuredText provides an extension mechanism that allows you to add new directives. But while reStructuredText directives are similar to XML elements, reStructuredText predefines a core set of directives for common document structures. The <db:code>code-block</db:code> directive above is not an extension of reStructuredText, it is part of the core language.</db:para>
<db:para>Because it defines a large set of document-domain directives, <db:indexterm><db:primary>reStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>reStructuredText</db:secondary></db:indexterm>reStructuredText is inherently a <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain language. You could, of course, add <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain directives to it. Most document-domain languages in use today include some subject-domain structures, reflecting the purpose they were originally designed to serve. Nonetheless, reStructuredText is inherently a document-domain language.</db:para>
<db:para>Another important note about reStructuredText is that it has no constraint mechanism. You can add new directives, but you can’t constrain their use or the use of the predefined directives.</db:para>
<db:para>I have developed a hybrid markup language which is designed to be both extensible and constrainable. I call it SAM (which stands either for Semantic Authoring Markdown or Semantic Authoring Markup, as you please). I use SAM for most of the examples in this book.</db:para>
<db:para><db:xref linkend="fig.moby-dick-sam-1"/> shows the <db:indexterm><db:primary>Moby Dick</db:primary></db:indexterm><db:indexterm><db:primary>citetitle</db:primary><db:secondary>Moby Dick</db:secondary></db:indexterm><db:citetitle>Moby Dick</db:citetitle> passage written in SAM:</db:para>
<db:figure xml:id="fig.moby-dick-sam-1"><db:title>Example of SAM markup</db:title><db:programlisting language="sam">
section: Moby Dick
                
    Herman Melville's {Moby Dick}(novel) is a long 
    book about a big whale.
</db:programlisting></db:figure>
<db:para>In SAM, as in Markdown and most other concrete markup languages, a paragraph is just a block of text set off by whitespace. Thus, there is no explicit  structure named <db:code>p</db:code> or <db:code>para</db:code>.</db:para>
<db:para>At the beginning of a line, a single word without spaces and followed by a colon creates an abstract structure called a <db:emphasis>block</db:emphasis>. The word before the colon is the name of the block. In the example above, <db:code>section:</db:code> creates a block structure named <db:code>section</db:code> in the same way that, in XML, an element named <db:code>&lt;section&gt;</db:code> creates a block structure named <db:code>section</db:code>. Blocks can contain blocks or text structures such as paragraphs and lists.</db:para>
<db:para>The hierarchy of a SAM document is indicated by indentation. Thus, the paragraph in <db:xref linkend="fig.moby-dick-sam-1"/> is contained in the <db:code>section</db:code> block. Using indentation to indicate containers helps make the structure of the document visually clear and removes the need for end tags, which reduces verbosity and makes the text easier to read.</db:para>
<db:para>Within a paragraph, curly braces markup a phrase, to which you can attach an annotation in parentheses. Here the phrase “Moby Dick” is annotated to indicate that it is a novel. SAM also supports decorations, like the underscores in the Markdown example, so in the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain “Moby Dick” could have been written <db:code>_Moby Dick_</db:code>.</db:para>
<db:para>SAM is not intended to be nearly as general in scope as a purely abstract markup language such as XML. It is meant for semantic authoring (which is to say, structured writing). As such it incorporates a number of shortcuts to make writing typical structured documents easier.</db:para>
<db:para>In a typical document, a block of text (larger than a paragraph) typically has a title. So in SAM, a string after a block tag is considered to be a title. That means that the markup in <db:xref linkend="fig.moby-dick-sam-1"/> is equivalent to the markup in <db:xref linkend="fig.moby-dick-sam-2"/>.</db:para>
<db:figure xml:id="fig.moby-dick-sam-2"><db:title>SAM markup with the <db:code>title</db:code> explicitly marked up</db:title><db:programlisting language="sam">
section: 
    title: Moby Dick
            
    Herman Melville's {Moby Dick}(novel) is a long 
    book about a big whale.
</db:programlisting></db:figure>
<db:para>However, unlike <db:indexterm><db:primary>RestructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>RestructuredText</db:secondary></db:indexterm>RestructuredText, <db:indexterm><db:primary>SAM</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SAM</db:secondary></db:indexterm>SAM does not have an extensive set of predefined named blocks. It only predefines the basic text structures that it provides concrete syntax for. You can write an entire book in reStructuredText without defining any new directives, The most you can write in SAM without defining any blocks is a single paragraph or list.</db:para>
<db:para>SAM is designed to have a constraint mechanism, which allows you to write a schema that defines what blocks and annotations are allowed in a SAM document. This includes constraining the use of the concrete syntax as well. SAM represents a different type of hybrid from <db:indexterm><db:primary>reStructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>reStructuredText</db:secondary></db:indexterm>reStructuredText, which is extensible but not constrainable. This reflects the fact that reStructuredText is intended as an extensible <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain language, whereas SAM is intended primarily as a neutral starting point for designing <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain languages (though you can design document-domain languages in it as well).</db:para>
<db:para>Also unlike <db:indexterm><db:primary>RestructuredText</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>RestructuredText</db:secondary></db:indexterm>RestructuredText, <db:indexterm><db:primary>SAM</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>SAM</db:secondary></db:indexterm>SAM is not intended to have its own publishing tool chain. The SAM parser outputs an <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML document which can be transformed into an appropriate <db:indexterm><db:primary>document-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document-domain</db:secondary></db:indexterm>document-domain language for publishing. This book was written in SAM, using a simple document-domain language I created for the purpose. That language, which includes some <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain annotations, was transformed into a semantically equivalent XML document by the SAM parser. That XML document was then transformed into <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook according to the publisher’s specifications (the publisher imposed constraints that are not expressed in DocBook itself). From that point on, the publisher’s existing DocBook tool chain took over.</db:para>
<db:para>Most concrete markup languages, at least those designed for documents, try to make their marked-up documents look and read as much as possible like a formatted document. SAM is designed to be easy and natural to read, like a concrete markup language, but it is also designed to make the structure of the content as clear and explicit as possible while requiring a minimum of markup. This is why it uses indentation to express structure. Indentation shows structure clearly with a minimum of markup noise to distract the reader.</db:para>
<db:para>Because it is meant specifically for authoring, a SAM parser outputs XML, which can then be processed by the standard XML tool chain. <db:xref linkend="fig.moby-dick-xml"/> shows how the SAM markup in <db:xref linkend="fig.moby-dick-sam-2"/> would be output by a SAM parser.</db:para>
<db:figure xml:id="fig.moby-dick-xml"><db:title>Example of SAM intermediate XML markup</db:title><db:programlisting language="XML">
&lt;section&gt;
    &lt;title&gt;Moby Dick&lt;/title&gt;        
    &lt;p&gt;Herman Melville's &lt;phrase&gt;
    &lt;annotation type="novel"/&gt;Moby Dick&lt;/annotation&gt;
    &lt;/phrase&gt; is a long book about a big whale.&lt;/p&gt;
&lt;/section&gt;
</db:programlisting></db:figure>
<db:section>
<db:title>Instances of hybrid markup languages</db:title>

<db:para>I said earlier that this book is written in SAM, but that is not quite accurate. As noted above, you can’t directly write anything in an abstract language. You write in instances of those languages. Thus, DocBook is an instance of the abstract language XML. You can write documents in DocBook. (We do say, of course, that we write documents in XML, but that statement is, if not wholly inaccurate, certainly non-specific. Saying that a document is written in DocBook tells you what constraints it meets. Saying it is written in XML merely tells you which syntax it uses, which is a whole lot less informative.) With hybrid languages, it depends on what type of hybrid they are, and whether the concrete part of the language is extensive enough to be used alone. In the case of SAM, it is not. Therefore you cannot write a meaningful document in pure SAM. You have to create your own language using SAM syntax.</db:para>
<db:para>So, to be more specific, this book is written in a markup language written in SAM that I created for the specific purpose of writing this book. That markup language was then transformed by a processing application into <db:indexterm><db:primary>DocBook</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DocBook</db:secondary></db:indexterm>DocBook, which is the markup language the publisher uses for producing books. From there is was processed through the publisher’s regular DocBook-based tool chain to produce print and e-book output.</db:para>
<db:para>Choosing the style of markup you will use is very much tied to the choices you make about the structures you want. In the following chapters, I look at a variety of markup languages using a variety of markup styles. As always, of course, your choices should be dictated by what works best for the overall partitioning and redirection of complexity that you are seeking to achieve in your content system.</db:para>
<db:indexterm class="endofrange" startref="idm789208588"/><db:indexterm class="endofrange" startref="idm789208588x"/></db:section>
</db:section>
</db:section>
</db:chapter>
