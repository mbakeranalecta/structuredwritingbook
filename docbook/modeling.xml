<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.modeling"><db:title>Modeling</db:title>




<db:para>As noted in <db:xref linkend="chapter.extract"/>, it is possible to <db:indexterm><db:primary>extract algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>extract algorithm</db:secondary></db:indexterm>extract content from existing data sources, which can then be used as input for generating content (as described in <db:xref linkend="chapter.generate"/>). Some of these sources were not intended to be used as content, but in many cases you can turn them into content by using algorithms to wrap the data into sentences or field values in a document. Such sources essentially present a model of some object in the real world, and when you use them as a source of content, you create content from that model.</db:para>
<db:para>Even when an external data source does not exist, you can apply the same techniques to creating content by creating your own model of a real-world object using structured writing techniques. You can then <db:indexterm><db:primary>extract algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>extract algorithm</db:secondary></db:indexterm>extract content from that model just as you would from an external data source. This can be an extremely powerful technique for managing complexity in cases where content frequently traverses the same ground, such as describing the steps a user takes when navigating a menu system, or where content must express complex relationships that are easier to model and control in a formalized system.</db:para>
<db:para>An entire book could be written about how to model various types of subjects and how to derive content from those models. Here, I  present one simplified model to demonstrate the principle at work and point to some of its key benefits.</db:para>
<db:para>Many technical documents contain numerous procedures for navigating an application interface. Writers can spend a lot of time writing and maintaining these procedures. However, these procedures are often dictated entirely by the interface and could be generated by an algorithm if the right data was available. The modeling algorithm is about creating a data set you can generate content from.</db:para>
<db:para>The navigational structure of a typical desktop application is essentially a tree consisting of a well-defined set of objects: menus, menu items, dialog boxes, field values, buttons, and assorted other controls. The entire navigation system of an application can thus be modeled as a tree, and, indeed, there are languages designed for modeling interfaces in just this way for programming purposes.<db:footnote><db:para>https://en.wikipedia.org/wiki/User_interface_modeling</db:para></db:footnote> However, rather than using one of those languages, I will use a simpler model that is just complex enough to demonstrate the technique. <db:xref linkend="fig.modeling-structure"/> shows a model for an interface that creates a new document.</db:para>
<db:figure xml:id="fig.modeling-structure"><db:title>Simple structure to model a user interface</db:title><db:programlisting language="sam">
application: MyApp
    menu-set:
         menu: File
             menu-item: New
                 dialog-box: New document
                     fields:: name, purpose
                         Name, the name of the new document
                         Type, the type of the new document
                     confirm: Create
                     cancel: Cancel
                     screen-shot:
                         windows: graphics/windows/new.png
                         mac: graphics/mac/new.png
                         linux: graphics/linux/new.png
</db:programlisting></db:figure>
<db:para>Most of what is contained in a procedure for using a GUI follows a formula. With a model of the UI like <db:xref linkend="fig.modeling-structure"/>, you can write an algorithm to follow that formula for all procedures.</db:para>
<db:para><db:xref linkend="fig.modeling-procedure"/> shows how you might write a procedure for using this menu using conventional techniques.</db:para>
<db:figure xml:id="fig.modeling-procedure"><db:title>Steps for writing a procedure for a GUI operation</db:title><db:programlisting language="sam">
procedure: Create a new document
    step: 
        From the {File}(menu) menu, select {New}(menu-item). 
        The {New document}(dialog) appears.
        
        &gt;&gt;&gt;(%image.new_dialog)
    step: 
        Enter the name of the new document into the {Name}(field) field.
    step: 
        Enter the type of the new document into the {Type}(field) field.
    step: 
        Press {Create}(button) or {Cancel}(button) to cancel.
</db:programlisting></db:figure>
<db:para>Using the model in <db:xref linkend="fig.modeling-structure"/>, however, you can reduce all of this to:</db:para>
<db:programlisting language="sam">
procedure: Create a new document
    use-dialog: New document 
</db:programlisting>
<db:para>Every piece of text used in <db:xref linkend="fig.modeling-procedure"/> can be derived from the model by an algorithm. The <db:code>use-dialog</db:code> field in the reduced version triggers an algorithm that uses the “New document” <db:code>dialog-box</db:code> in <db:xref linkend="fig.modeling-structure"/> as its source and generates the full text of the procedure, including the correct screen shot.</db:para>
<db:para>Clearly, you won’t always want to generate the full procedure with a single line. There will be cases where you need to say something specific about a particular case. For example, if this procedure is part of a tutorial, you might want to specify a particular file name. In that case, you could use the model to generate only part of the procedure (see <db:xref linkend="fig.modeling-test-doc"/>).</db:para>
<db:figure xml:id="fig.modeling-test-doc"><db:title>Partially customized procedure</db:title><db:programlisting language="sam">
procedure: Create a document for testing
    navigate-to: New document               
    step: 
        Enter "test.abc" into the {Name}(field) field.
    step: 
        Enter "normal" into the {Type}(field) field.
    confirm: New document
</db:programlisting></db:figure>
<db:para>In <db:xref linkend="fig.modeling-test-doc"/>, the fields <db:code>navigate-to</db:code> and <db:code>confirm</db:code> tell an algorithm to generate parts of the procedure from the model (the navigation to the dialog box and the button presses to confirm the action) while allowing the writer to insert custom instructions in the middle.</db:para>
<db:para>Procedures contain huge amounts of repeated text, none of which can be effectively factored out by standard variable substitution techniques. But by creating a model of the interface, you can factor out most of the text for most procedures, leaving it to an algorithm to perform the tedious task of typing out all those instructions over and over again.</db:para>
<db:para>There are a number of potential benefits to factoring out content into a model:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>You reduce the amount of content that needs to be written, and you remove the necessity for writers to trace carefully through every procedure to make sure every detail is correct. The details come from the model, so all you have to do is ensure that the details are correct in the model. And if you find a flaw in the model, fixing it in the model automatically fixes it in all the content derived from it.</db:para>
</db:listitem>
<db:listitem>
<db:para>When changes occur in the subject matter, you only have to change the model, not any of the documents that contain text derived from the model.</db:para>
</db:listitem>
<db:listitem>
<db:para>The model can be maintained by one person who is an expert on the structure of the subject matter, thus removing the need for multiple writers to become experts.</db:para>
</db:listitem>
<db:listitem>
<db:para>If there is a change to the subject matter that could affect the way the model is called from the content, this will be immediately obvious because the names used to identify parts of the model will no longer match, triggering a <db:indexterm><db:primary>referential integrity</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>referential integrity</db:secondary></db:indexterm>referential integrity error. This means it is almost impossible for a change in content to be missed when the subject matter changes.</db:para>
</db:listitem>
<db:listitem>
<db:para>It allows you to change the way that the subject matter is described independent of the existing content. If you want to shorten the navigation instruction in the procedure example to <db:code>File&gt;New</db:code>, you only need to change the algorithm, not hundreds of places in the content.</db:para>
</db:listitem>
<db:listitem>
<db:para>Because you can change the way a subject is expressed by simply changing the algorithm, you can test different forms of expression to see which work best.</db:para>
</db:listitem>
<db:listitem>
<db:para>The ability to easily change the output also allows you to personalize content for different groups. You can even allow individuals to choose how they want content to be expressed. Using <db:indexterm><db:primary>active content</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>active content</db:secondary></db:indexterm>active content techniques, you can even change how content is expressed at read time based on the information you have about your users, or the way you see them interact with the content (showing screen shots automatically if the users frequently click on a screen shot link, for instance).</db:para>
</db:listitem>
<db:listitem>
<db:para>The fully-written-out example of the procedure in <db:xref linkend="fig.modeling-procedure"/> uses <db:indexterm><db:primary>keys</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>keys</db:secondary></db:indexterm>keys to factor out the difference between screen shots for different platforms, a technique described in <db:xref linkend="chapter.reuse"/>. But while keys are a powerful tool, they are also an abstract concept and writers have to learn to use them correctly. Using the modeling algorithm, the choice of screenshots is moved from the content to the model. This factors out the complexity of using keys. It also allows you to make choices about how, where, and if screen shots are displayed. And you can test which works best or even allow users to select whether they prefer to see screen shots or not.</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>As with every other algorithm described in this book, it is important not to get carried away with enthusiasm of modeling in isolation. Although it is technically satisfying to build a model and derive a variety of content from it, the model and its algorithms are also sources of complexity.</db:para>
<db:para>As I have noted, there is nothing wrong in principle with introducing new complexity into the content system. All tools do this. The point is to ensure that all of the complexity in the content system is handled by a person or process with the skills, time, and resources to handle it properly. Modeling partitions and redistributes a lot of complexity, which means it can create substantial change to the overall content system. It is important to make sure that the effect on your overall content system is positive.</db:para>
</db:chapter>
