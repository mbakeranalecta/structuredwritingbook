<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.merge"><db:title>Merge</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idm1711144620"><db:primary>merge</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm1711144620x"><db:primary>algorithm</db:primary><db:secondary>merge</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idm1711140268"><db:primary>merge algorithm</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idm1711140268x"><db:primary>algorithm</db:primary><db:secondary>merge algorithm</db:secondary></db:indexterm>



<db:para>If the <db:indexterm><db:primary>extract algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>extract algorithm</db:secondary></db:indexterm>extract algorithm gives us access to new sources of <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain content, it does not always give us everything we need for a complete document. Sometimes we need to combine the content we have extracted with content we have written in order to present a complete set of information. This is the job for the <db:indexterm><db:primary>merge algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>merge algorithm</db:secondary></db:indexterm>merge algorithm.</db:para>
<db:para>The information that we can extract about an API function from the code that implements it is useful content, there is not enough detail to build a complete  API reference. A good reference entry also requires some explanation of the purpose of the function, a little more detail on its parameters, and possibly a code sample illustrating its use.</db:para>
<db:para>To address this, we can merge authored content covering these topics with the content we have extracted from the source.</db:para>
<db:para>In the case of API documentation tools, the authored content for merging is often written in the source code files. It is contained in code comments and is often written in small <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain markup languages that are specific to that tool. (Though as with all subject-domain structures, any other tool can read them if it wants to.)</db:para>
<db:para>Here is an example of authored content combined with source code in JavaDoc<db:footnote><db:para>https://en.wikipedia.org/wiki/Javadoc#Example</db:para></db:footnote>:</db:para>
<db:programlisting language="Java">

/**
 * Validates a chess move.
 *
 * Use {@link #doMove(int theFromFile, 
 *                    int theFromRank, 
 *                    int theToFile, 
 *                    int theToRank)} to move a piece.
 *
 * @param theFromFile file from which a piece is being moved
 * @param theFromRank rank from which a piece is being moved
 * @param theToFile   file to which a piece is being moved
 * @param theToRank   rank to which a piece is being moved
 * @return            true if the move is valid, otherwise false
 */
boolean isValidMove(int theFromFile, 
                    int theFromRank, 
                    int theToFile, 
                    int theToRank) {
    // ...body
}
</db:programlisting>
<db:para>In this example, everything between the opening <db:code>/*</db:code> and the closing <db:code>*/</db:code> is a comment (as far as <db:indexterm><db:primary>Java</db:primary></db:indexterm><db:indexterm><db:primary>programming-language</db:primary><db:secondary>Java</db:secondary></db:indexterm>Java itself is concerned), and the rest is a function definition in <db:indexterm><db:primary>Java</db:primary></db:indexterm><db:indexterm><db:primary>programming-language</db:primary><db:secondary>Java</db:secondary></db:indexterm>Java. However, <db:indexterm><db:primary>JavaDoc</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>JavaDoc</db:secondary></db:indexterm>JavaDoc sees the comment block as a block of structured text using a style of <db:indexterm><db:primary>markup</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>markup</db:secondary></db:indexterm>markup specific to <db:indexterm><db:primary>JavaDoc</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>JavaDoc</db:secondary></db:indexterm>JavaDoc.</db:para>
<db:para>The <db:indexterm><db:primary>JavaDoc</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>JavaDoc</db:secondary></db:indexterm>JavaDoc processor will extract information from the function definition itself (the <db:indexterm><db:primary>extract algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>extract algorithm</db:secondary></db:indexterm>extract algorithm) and then merge it with information from the authored structured content (the <db:indexterm><db:primary>merge algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>merge algorithm</db:secondary></db:indexterm>merge algorithm). In doing so, it has the chance to validate the authored content, for instance by making sure that the names of parameters in the authored content match those in the function definition itself. This ability to validate authored content against extracted data is an important aid to <db:indexterm><db:primary>conformance</db:primary></db:indexterm><db:indexterm><db:primary>process</db:primary><db:secondary>conformance</db:secondary></db:indexterm>conformance and <db:indexterm><db:primary>auditing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>auditing</db:secondary></db:indexterm>auditing.</db:para>
<db:para>However, the <db:indexterm><db:primary>merge algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>merge algorithm</db:secondary></db:indexterm>merge algorithm does not require that the authored content be part of the same file as the data you will be extracting other information from. You can just as easily place the authored content in a separate file. In many cases, this will be the only available approach, since the source format will not provide any place to include documentation. All you need to be able to merge the two is an unambiguous term or combination of terms that you can find in the source data. You then enter that term or terms as a field or fields in the authored content where it can be used to match the authored content to the relevant extracted data.</db:para>
<db:para>For example, on one project I worked on, we needed to create a reference for a large body of operating system components. The components were defined in a data file that allowed for a one line description of the component which was intended for display in a GUI configuration editor. We needed to supply much more extensive documentation for each component, so we created an <db:indexterm><db:primary>extract algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>extract algorithm</db:secondary></db:indexterm>extract algorithm to pull information from the data file that defined the components and dumped it to <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm><db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML. We then developed a <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm><db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML format for capturing all the additional pieces of information we needed to document about each component. We then merged the two sources using the name of the component as the key. This produced an integrated <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain document, which we then processed into a common document-domain format used for the whole documentation system and processed that document to produce the the formatted reference. Because the operating system components we were documenting supplied additional APIs to the operating system, we also merged in information from the API reference and created links from the component reference to the API reference, all with algorithms.</db:para>
<db:para>One of the downsides of API documentation tools like JavaDoc is that they tend to be tightly coupled systems that produce <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain output such as formatted <db:indexterm><db:primary>HTML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>HTML</db:secondary></db:indexterm><db:indexterm><db:primary>HTML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>HTML</db:secondary></db:indexterm>HTML directly, often providing little or no control over presentation or formatting. This is a problem because it means that your API reference content does not look like the rest of your content. And worse, it is not integrated with or linked to the rest of your content. This has obvious consequences, like mentions of API routines in you programmer’s guide not being linked to the documentation of that routine in the API reference. It would be much better to generate subject domain content from the API documentation tool and then process it with the rest of your content. For many API documentation tools this is actually possible because many of them offer an <db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>XML</db:secondary></db:indexterm><db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML output which may be either <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain or <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain. Even if it is document domain, it may be regular enough that you can extract the subject domain structures reasonably easily. You can then skip the API doc tool’s built in publishing chain and run its output through your regular <db:indexterm><db:primary>publishing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publishing</db:secondary></db:indexterm>publishing chain.</db:para>
<db:indexterm class="endofrange" startref="idm1711144620"/><db:indexterm class="endofrange" startref="idm1711140268"/><db:indexterm class="endofrange" startref="idm1711144620x"/><db:indexterm class="endofrange" startref="idm1711140268x"/></db:chapter>
