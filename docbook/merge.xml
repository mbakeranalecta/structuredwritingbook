<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.merge"><db:title>Merge</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp1478442996"><db:primary>merge</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1478442996x"><db:primary>algorithm</db:primary><db:secondary>merge</db:secondary></db:indexterm><db:indexterm class="startofrange" significance="preferred" xml:id="idp1478437236"><db:primary>merge algorithm</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp1478437236x"><db:primary>algorithm</db:primary><db:secondary>merge algorithm</db:secondary></db:indexterm>




<db:para>Although the <db:indexterm><db:primary>extract algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>extract algorithm</db:secondary></db:indexterm>extract algorithm gives you access to new sources of <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain content, it does not always give you everything you need for a complete document. In order to present a complete document, you sometimes need to combine extracted content with content you have written. This is a job for the <db:indexterm><db:primary>merge algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>merge algorithm</db:secondary></db:indexterm>merge algorithm.</db:para>
<db:para>You can extract useful information about an API function from the code that implements, but there is not enough detail to build a complete API reference. A good reference entry also requires an explanation of the purpose of the function, a little more detail about its parameters, and possibly a code sample illustrating its use. To address these needs, you can merge authored content covering these topics with content you have extracted from the source code.</db:para>
<db:para>API documentation tools often allow you to include authored content in the source code files. This content is contained in code comments and is often written in small <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain markup languages that are specific to the tool. Of course, as with all subject-domain structures, another tool can read them if it wants to.</db:para>
<db:figure xml:id="fig.javadoc"><db:title>API documentation included in source code using JavaDoc</db:title><db:programlisting language="Java">
/**
 * Validates a chess move.
 *
 * Use {@link #doMove(int theFromFile, 
 *                    int theFromRank, 
 *                    int theToFile, 
 *                    int theToRank)} to move a piece.
 *
 * @param theFromFile file from which a piece is being moved
 * @param theFromRank rank from which a piece is being moved
 * @param theToFile   file to which a piece is being moved
 * @param theToRank   rank to which a piece is being moved
 * @return            true if the move is valid, otherwise false
 */
boolean isValidMove(int theFromFile, 
                    int theFromRank, 
                    int theToFile, 
                    int theToRank) {
    // ...body
}
</db:programlisting></db:figure>
<db:para><db:xref linkend="fig.javadoc"/> is an example of authored content combined with source code in JavaDoc.<db:footnote><db:para>https://en.wikipedia.org/wiki/Javadoc#Example</db:para></db:footnote> In this example, everything between the opening <db:code>/*</db:code> and the closing <db:code>*/</db:code> is a comment (as far as <db:indexterm><db:primary>Java</db:primary></db:indexterm><db:indexterm><db:primary>programming-language</db:primary><db:secondary>Java</db:secondary></db:indexterm>Java is concerned), and the rest is a <db:indexterm><db:primary>Java</db:primary></db:indexterm><db:indexterm><db:primary>programming-language</db:primary><db:secondary>Java</db:secondary></db:indexterm>Java function definition. However, <annotation type="markup-language">JavaDoc</annotation> sees the comment block as structured text marked up using a style of <db:indexterm><db:primary>markup</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>markup</db:secondary></db:indexterm>markup specific to <annotation type="markup-language">JavaDoc</annotation>.</db:para>
<db:para>The <annotation type="markup-language">JavaDoc</annotation> processor extracts information from the function definition (the <db:indexterm><db:primary>extract algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>extract algorithm</db:secondary></db:indexterm>extract algorithm) and then merges it with information from the authored structured content (the <db:indexterm><db:primary>merge algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>merge algorithm</db:secondary></db:indexterm>merge algorithm). In doing so, it can validate the authored content, for instance, it can ensure that the names of parameters in the authored content match those in the function definition. This ability to validate authored content against extracted data is an important aid to <db:indexterm><db:primary>conformance</db:primary></db:indexterm><db:indexterm><db:primary>process</db:primary><db:secondary>conformance</db:secondary></db:indexterm>conformance and <db:indexterm><db:primary>auditing algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>auditing algorithm</db:secondary></db:indexterm>auditing.</db:para>
<db:para>However, the <db:indexterm><db:primary>merge algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>merge algorithm</db:secondary></db:indexterm>merge algorithm does not require that the authored content and the extracted content be part of the same file. You can just as easily place the authored content in a separate file. In many cases, this will be the only available approach, since some source formats do not provide any place to include documentation. To merge the two, you need two things:</db:para>
<db:orderedlist>
<db:listitem>
<db:para>Sufficient structure in both the extracted data and the written content that you can identify the pieces you are selecting to merge (this is required for <db:indexterm><db:primary>composition</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>composition</db:secondary></db:indexterm>composability).</db:para>
</db:listitem>
<db:listitem>
<db:para>An unambiguous term or combination of terms in the extracted data that you can use as a key to connect the extracted data with the authored content by entering the same terms as a field or fields in the authored content.</db:para>
</db:listitem>
</db:orderedlist>
<db:para>For example, on one project I worked on, we needed to create a reference for a large body of operating system components. The components were defined in a data file that allowed for a one-line description of the component, which was intended for display in a GUI configuration editor. We needed to supply much more extensive documentation for each component, so we created an <db:indexterm><db:primary>extract algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>extract algorithm</db:secondary></db:indexterm>extract algorithm to pull information from the data file that defined the components and save it as <annotation type="markup-language"><db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML</annotation>. We then developed a <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain <annotation type="markup-language"><db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML</annotation> format to capture the additional information we needed to document each component. We then merged the two sources using the name of the component as the key, as shown in <db:xref linkend="fig.merge"/>. (And note the similarity of this diagram to <db:xref linkend="fig.merge_text_and_font"/>)</db:para>
<db:figure xml:id="fig.merge"><db:title>Merging extracted and authored content</db:title><db:mediaobject><db:imageobject condition="fo"><db:imagedata fileref="../graphics/merge.svg" contentwidth="5.0in" align="center"/></db:imageobject><db:imageobject condition="epub"><db:imagedata fileref="../graphics/merge.png"/></db:imageobject><db:textobject><db:para>A diagram showing the merging of two content sources.</db:para></db:textobject></db:mediaobject></db:figure>
<db:para>This produced an integrated <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain document, which we then processed into the document-domain format we used for the whole documentation system. We then processed that document to produce the formatted reference. Because the operating system components we were documenting supplied additional APIs to the operating system, we also merged in information from the API reference and created links from the component reference to the API reference, all with algorithms.</db:para>
<db:para>One of the downsides of API documentation tools like JavaDoc is that they tend to be tightly coupled systems that directly produce <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media-domain output such as formatted <annotation type="markup-language"><db:indexterm><db:primary>HTML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>HTML</db:secondary></db:indexterm>HTML</annotation>, thus providing little or no control over presentation or formatting. This is a problem because it means that your API reference content will not look like the rest of your content. And worse, your API reference won’t be integrated with or linked to the rest of your content. This means any mention of an API routine in your programmer’s guide won’t link to the documentation for that routine in the API reference.</db:para>
<db:para>It would be much better to generate subject-domain content from the API documentation tool and then process it with the rest of your content. Many API documentation tools make this possible by allowing you to export <annotation type="markup-language"><db:indexterm><db:primary>XML</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>XML</db:secondary></db:indexterm>XML</annotation>, which may be either <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain or <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain. Even if the output is document-domain XML, it may be regular enough that you can extract subject-domain structures reasonably easily. You can then skip the API documentation tool’s built-in publishing chain and run the XML output through your regular <db:indexterm><db:primary>publishing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publishing</db:secondary></db:indexterm>publishing chain.</db:para>
<db:indexterm class="endofrange" startref="idp1478442996"/><db:indexterm class="endofrange" startref="idp1478437236"/><db:indexterm class="endofrange" startref="idp1478442996x"/><db:indexterm class="endofrange" startref="idp1478437236x"/></db:chapter>
