<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.management-domain"><db:title>The Management Domain: an Intrusion</db:title><db:indexterm class="startofrange" xml:id="idp140534931319568"><db:primary>management domain</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp140534931319568x"><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>



<db:para>So far I have talked about three domains that content passes through and in which it can be recorded: the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain, the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, and the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain. But there is a forth domain that intrudes into this picture: the <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain.</db:para>
<db:para>Why do I call the management domain an intrusion? Because while the subject, document, and media domains are all about recording the content itself, the management domain is not about the content, but about the process of managing it.</db:para>
<db:para>Let’s suppose we run a publishing company that publishes a number of magazines. We want to create a common store of recipes for use in all the magazines. But different magazines have different requirements. <db:emphasis>Wine Weenie</db:emphasis> magazine needs to have a wine match with every recipe. <db:emphasis>The Teetotaler's Trumpet</db:emphasis>, naturally, wants a non-alcoholic suggestion.</db:para>
<db:para>Here is how that might be handled in the document domain:</db:para>
<db:programlisting language="xml">
&lt;section publication="Wine Weenie"&gt;
    &lt;title&gt;Wine match&lt;/title&gt;
    &lt;p&gt;Pinot Noir&lt;/p&gt;
&lt;/section&gt;
&lt;section publication="The Teetotaler's Trumpet"&gt;
    &lt;title&gt;Suggested beverage&lt;/title&gt;
    &lt;p&gt;Lemonade&lt;/p&gt;
&lt;/section&gt;
</db:programlisting>
<db:para>This is an example of what we call <db:indexterm><db:primary>conditional text</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>conditional text</db:secondary></db:indexterm>conditional text. The <db:code>publication</db:code> attribute on the <db:code>section</db:code> element says, display this text only in this publication. This makes it <db:indexterm><db:primary>management metadata</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management metadata</db:secondary></db:indexterm>management metadata, which means these structures are in the <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain.) It does not specify the formatting, organization, or subject matter of the document. It specifies which publication the content should appear in, which is a content management decision.</db:para>
<db:para>A content management decision is always, from the writer’s point of view, an extended decisions, not a core decision. It is not a decision that the writer has to make in order to write their content. It is a decision imposed on the writer’s task from elsewhere in the process. As such, the <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain is again an intrusion – an intrusion not only into the content but into the writer’s time and attention. In the overall scheme of things, this may sometimes be the best place to place the burden, but we should be very aware that when we do this we are increasing the complexity of the writing process and increasing both the knowledge and skills required to write successfully. We should certainly look for alternatives to the <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain wherever we can.</db:para>
<db:para>We have noted that a decision imposes two burdens: making the decision, which requires knowledge, and executing the decision, which requires skills. In the case of conditional text, we have a system that removes the execution of the decision (including or excluding the text at build time), but leaves the decision making (where and what to include) with the writer. Of course, it also require some execution skill as well, since the writer has to know how to apply conditions correctly, which is not always a simple matter. This is a common pattern with management domain structures.</db:para>
<db:section>
<db:title>Including boilerplate content</db:title>
<db:para><db:indexterm><db:primary>Management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>Management domain</db:secondary></db:indexterm>Management domain structures can be used to do a number of things. For example, let’s say you have a standard warning statement that you are required to include in a document wherever you have a dangerous procedure. Structured writing partitions complexity by factoring out invariants, and the invariant here is that this warning statement must appear whenever you describe a dangerous procedure.</db:para>
<db:para>Just as we extracted formatting information into a separate file when we moved content from the media domain to the document domain, we now extract the invariant warning from the document and place it in a separate file. Any place we want this warning to occur, we insert an instruction to include the contents of the file at that location.</db:para>
<db:programlisting language="sam">
procedure: Blow stuff up
    &lt;&lt;&lt;(files/shared/admonitions/danger.sam)
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting>
<db:para>In the SAM markup above the <db:code>&lt;&lt;&lt;</db:code> is an include command. It includes the content of the file located at <db:code>files/shared/admonitions/danger.sam</db:code> in the source file as it is read.</db:para>
<db:para>The equivalent in XML would look something like this:</db:para>
<db:programlisting language="XML">
&lt;procedure&gt;
    &lt;title&gt;Blow stuff up&lt;/title&gt;
    &lt;xi:include href="files/shared/admonitions/danger.xml"/&gt;
    &lt;step&gt;Plant dynamite.&lt;/step&gt;
    &lt;step&gt;Insert detonator.&lt;/step&gt;
    &lt;step&gt;Run away.&lt;/step&gt;
    &lt;step&gt;Press the big red button.&lt;/step&gt;
&lt;/procedure&gt;
</db:programlisting>
<db:para>Why is this operation part of the <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain, rather than the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain? Because it deals with a system operation: locating a file in the system and loading its contents. If we were purely in the document domain, the author would be the one performing this operation: finding the file with the warning in it, opening it, and copying the contents into the document. The include instruction is just that: an instruction. It is not a declaration about the subject matter or structure of a document, such as we find in <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain or document domain markup. It is an instruction to a machine to perform an operation. The <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain consists of instructions or the declaration of data required to perform management functions.</db:para>
<db:para>Different structured writing systems have different instruction sets for handling the situation described above. In <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA, for instance, this use case is handled using something called a <db:code>conref</db:code> or a <db:code>conkeyref</db:code>. In Docbook it can be handled using a generic XML facility called <db:indexterm><db:primary>XInclude</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>XInclude</db:secondary></db:indexterm>XInclude, as in the XML example above.</db:para>
</db:section>
<db:section>
<db:title>An alternative approach in the subject domain</db:title>
<db:para>The downside of the management domain include instruction is that it requires system knowledge to make the decision to to specify to the algorithm how to implement that decision. Adding decisions to the author’s task is always a problem because the author’s attention is a limited resource and everything that takes away their attention from writing has a direct impact on content quality.</db:para>
<db:para>But the use of a conditional expression or an include instruction is not just a problem for the author, it also makes <db:indexterm><db:primary>change management</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>change management</db:secondary></db:indexterm>change management and <db:indexterm><db:primary>content management algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content management algorithm</db:secondary></db:indexterm>content management more complicated by distributing management domain structures like conditions and file paths throughout the content. Management domain structures encode management decisions in the content itself. Changing those decisions later means changing management structures all over the content set.</db:para>
<db:para>Is there a way to partition the management complexity from the authoring and keep management decisions out of the content? In many cases this can be accomplished using the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain.</db:para>
<db:para>This is how we might approach the two magazines problem in the subject domain:</db:para>
<db:programlisting language="xml">
&lt;wine-match&gt;Pinot Noir&lt;/wine-match&gt;
&lt;beverage-match&gt;Lemonade&lt;/beverage-match&gt;
</db:programlisting>
<db:para>This markup says nothing about which documents should contain either of these pieces of information (a clear example of partitioning). Nor does it contain the subheadings what would introduce either of them in the appropriate publication. All these decisions are now left to algorithms (and the people who write them). This allows us to do far more things with this content without having to rewrite the source files in any way (a partitioning that significantly reduces the complexity of <db:indexterm><db:primary>change management</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>change management</db:secondary></db:indexterm>change management, an algorithms we will look at in <db:xref linkend="chapter.change"/>).</db:para>
<db:para>Every time you can move a decision out of the content and into an algorithm, you accomplish two things. You make the authoring task easier, and you preserve you ability to make different decisions later without changing content. Factoring out the management domain it thus a big win on two fronts.</db:para>
<db:para>Can we factor out the decision involved in including the warning in dangerous procedures? As we saw in <db:xref linkend="chapter.subject-domain"/>, factoring out invariant text is a feature of the subject domain. Since we are dealing with invariant text here, the subject domain may provide the solution. To understand the subject domain approach to this problem, remember what the invariant rule is here: A dangerous procedure must have a standard warning.</db:para>
<db:para>The management domain approach to this is to allow authors to insert the standard warning so that it is only stored once instead of being repeated in every procedure (something that is often called <db:indexterm><db:primary>content reuse</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>content reuse</db:secondary></db:indexterm>content reuse) an algorithms we will look at in <db:xref linkend="chapter.reuse"/>. Notice that the management domain markup does not encapsulate our invariant rule that dangerous procedures must have a standard warning (a rhetorical rule). It just provides a generic mechanism for inserting content as a reference to a file. The requirement has not been partitioned, we have merely provided a mechanism for implementing each case of the requirement. It leaves it entirely up to the author to remember and enforce the rule about dangerous procedures.</db:para>
<db:para>The subject domain approach, on the other hand, is all about the invariant rhetorical rule itself. Specifically, it expresses the aspect of the subject domain that triggers the rule: whether a procedure is dangerous or not:</db:para>
<db:programlisting language="sam">
procedure: Blow stuff up
    is-it-dangerous: yes
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting>
<db:para>This markup simply records that this procedure is dangerous, a fact about the subject matter, and one that our rhetorical standards require us to mention. This partitions the requirement, by retaining the information on which our invariant rule is based, but factors out the action to be taken. Rather than asking authors to remember to include the file (and how to included it, and how to find it) we delegate those decisions to the <db:indexterm><db:primary>publication algorithm</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>publication algorithm</db:secondary></db:indexterm>publication algorithm. It is now the algorithm, not the writer, that needs to remember to include the material in <db:code>files/shared/admonitions/danger</db:code> whenever the <db:code>is-it-dangerous</db:code> field of a <db:code>procedure</db:code> structure is set to “yes”. This is the sort of task that algorithms are much better at than humans.</db:para>
<db:para>Of course, the human writer does still have a job to do here. They have to remember to set <db:code>is-it-dangerous</db:code> to “yes”. But we can make remembering to do this much easier if we make <db:code>is-it-dangerous</db:code> a required field in the procedure structure. In other words, we set up our structured writing language in such a way that an error will occur if <db:code>is-it-dangerous</db:code> is not specified for a procedure. This transfers the complexity of remembering the requirement and fulfilling it from the writer and editor to the conformance algorithm and the <db:indexterm><db:primary>publication algorithm</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>publication algorithm</db:secondary></db:indexterm>publication algorithm.</db:para>
<db:para>This approach makes the writer’s job much easier because they not only get reminded of the need to address the question of danger with every procedure, they are also asked it in a way that does not require them to know anything about how the content management system works, what warning text is required, or were it is located. They are recording a fact about the subject, not giving an instruction or interpreting a style guide. This is a much more efficient partitioning of the requirement that does a better job of distributing complexity of this important rule to the person or process best able to handle it, thus minimizing the possibility that this complexity could get dumped on the reader, for whom there might be potentially painful consequences.</db:para>
<db:para>One the other hand, this approach only factors out the reuse of one particular piece of content – the warning for dangerous procedures. If you had multiple such invariant rhetorical rules about different kinds of subject matter you would need separate subject domain structures for each of them, whereas a single management domain include instructions would let authors handle them all.</db:para>
<db:para>On the other other hand, if you have many such invariant rules, and you expect all of them to be enforced by authors from memory, you are dumping an awful lot of complexity on your authors and you are going to limit your pool of authors to a few highly trained individuals. Even then they are still likely to miss some instances, dumping this dangerous complexity on the reader again.</db:para>
</db:section>
<db:section>
<db:title>Hybrid approaches</db:title>
<db:para>It is not always an either/or decision to use pure <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain or pure <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain approaches. Management domain structures tend to be used in generic document domain languages, since such languages are not designed to be specific to any particular subject matter. Nonetheless, such languages often have roots in particular fields and sometimes include <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain structures from those fields. Both DocBook and DITA, for instance, originated in the field of software documentation and both include structures related to the subject of software, such as code blocks and structures for describing user interface elements.</db:para>
<db:para>In some cases, such languages can mix subject domain structures into their management structures. One example is the <db:code>product</db:code> attribute, which is part of DITA’s conditional text processing system.</db:para>
<db:para>In DITA, you can add the <db:code>product</db:code> attribute to a wide variety of elements. You can then set a value for products in the build systems and any element with the <db:code>product</db:code> attribute will only be included in the final output if it matches one of the product values specified in the build.</db:para>
<db:programlisting language="DITA">
&lt;p&gt;The car seats 
&lt;ph product="CX-5"&gt;5&lt;/ph&gt;&lt;ph product="CX-9"&gt;7&lt;/ph&gt;
&lt;/p&gt;
</db:programlisting>
<db:para>DITA can afford to use this bit of subject domain markup for products because product variations are an extremely common reason for using conditional text processing in technical communication, the area for which DITA was created. (Through a process called “<db:indexterm><db:primary>specialization</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>specialization</db:secondary></db:indexterm>specialization”, DITA can add other subject domain attributes for conditional processing in other subject areas.)</db:para>
<db:para>The reason I call this a hybrid approach is that the DITA product attribute does not exist merely to declare that a piece of text applies to a particular product. It is specifically a conditional processing attribute. That is, it is an instruction, even though it is phrased as a subject domain declaration.</db:para>
<db:para>To appreciate the difference, consider that there is another approach to documenting multiple versions of a product. Rather than generating a separate document for each product variant, you could create a single document that covered all product variants and highlighted the differences between them. A pure subject domain approach would support either approach by simply recording the data for each variant:</db:para>
<db:programlisting language="sam">
seats:
    CX-5: 5
    CX-9: 7
</db:programlisting>
<db:para>This information could be presented as data similar to its source format or it could be used to algorithmically construct a sentence like this:</db:para>
<db:blockquote>
<db:para>The CX-5 seats 5 and the CX-9 seats 7.</db:para>
</db:blockquote>
<db:para>That is not something that the product attribute supports:</db:para>
<db:programlisting language="DITA">
&lt;p&gt;The car seats 
&lt;ph product="CX-5"&gt;5&lt;/ph&gt;&lt;ph product="CX-9"&gt;7&lt;/ph&gt;
&lt;/p&gt;
</db:programlisting>
<db:para>This markup is only designed to produce a CX-5 or CX-9 specific document. It is not designed to support the production of a document that covers both cars at once because it does not specify that the values 5 and 7 are numbers of seats. That information is in the text, but not in a form that a publishing algorithm could reliably locate and act on.</db:para>
<db:para>Also, creating a single document covering both cars is not the expectation that goes with creating the markup. It is not what the author is told the markup means. The markup is not a simple declaration of facts about each car, it is markup of a document intended to produce a document about one car or the other, not both. It is conditional text markup, and therefore an instruction.</db:para>
<db:para>Really, is it a contraction of the more explicitly imperative form (not actually used in DITA):</db:para>
<db:programlisting language="xml">
&lt;ph condition="product=CX-5"&gt;5&lt;/ph&gt;
</db:programlisting>
<db:para>While the introduction of subject domain names into <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain structures is an appropriate bit of semantic sugar for authors, this hybrid approach really remains firmly in the management domain.</db:para>
<db:para>We will see many more examples of the management domain, and the cases in which there is and is not a <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain alternative, in the following chapters.</db:para>
<db:indexterm class="endofrange" startref="idp140534931319568"/><db:indexterm class="endofrange" startref="idp140534931319568x"/></db:section>
</db:chapter>
