<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.management-domain"><db:title>The Management Domain: an Intrusion</db:title><db:indexterm class="startofrange" significance="preferred" xml:id="idp140481924616896"><db:primary>management domain</db:primary></db:indexterm><db:indexterm class="startofrange" xml:id="idp140481924616896x"><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>




<db:para>So far I have talked about three domains: the <db:indexterm><db:primary>media domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>media domain</db:secondary></db:indexterm>media domain, the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, and the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain. But there is a fourth domain that intrudes into this picture: the <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain.</db:para>
<db:para>Why do I call the management domain an intrusion? Because while the subject, document, and media domains are about recording the content itself, the management domain is not about the content itself; it’s about the process of managing content.</db:para>
<db:para>Suppose you run a company that publishes magazines, and you want to create a common store of recipes for use in all the magazines. However, different magazines have different requirements. <db:emphasis>Wine Weenie</db:emphasis> magazine needs to have a wine match with every recipe. <db:emphasis>The Teetotaler's Trumpet</db:emphasis>, naturally, wants a non-alcoholic suggestion.</db:para>
<db:para><db:xref linkend="ex.md-1"/> shows how you could handle this in the document domain:</db:para>
<db:figure xml:id="ex.md-1"><db:title>Conditional text markup (XML)</db:title><db:programlisting language="xml">
&lt;section publication="Wine Weenie"&gt;
    &lt;title&gt;Wine match&lt;/title&gt;
    &lt;p&gt;Pinot Noir&lt;/p&gt;
&lt;/section&gt;
&lt;section publication="The Teetotaler's Trumpet"&gt;
    &lt;title&gt;Suggested beverage&lt;/title&gt;
    &lt;p&gt;Lemonade&lt;/p&gt;
&lt;/section&gt;
</db:programlisting></db:figure>
<db:para>This is an example of <db:indexterm><db:primary>conditional text</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>conditional text</db:secondary></db:indexterm>conditional text. The <db:code>publication</db:code> attribute on the <db:code>section</db:code> element says, display this text only in this publication. Conditional text structures are <db:indexterm><db:primary>management metadata</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management metadata</db:secondary></db:indexterm>management metadata, which means they are in the <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain. They do not specify the formatting, organization, or subject matter of the document. They specify which publication the content should appear in, which is a content management decision.</db:para>
<db:para>Content management decisions are always external to the writer’s core task. They are not decisions about subject matter or rhetoric. They are decisions imposed on writers from elsewhere in the process. As such, the <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain is an intrusion not only into the content but also into the writer’s time and attention. Some management-domain decisions should be made by writers, but putting the burden on writers increases the complexity of the writing process and the knowledge and skills required to write successfully. Wherever you can, look for alternatives to the <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain.</db:para>
<db:para>Any decision imposes two burdens: making the decision, which requires knowledge, and executing the decision, which requires skills. A conditional text system removes the execution of the decision (including or excluding the text at build time), but leaves the decision making (where and what to include) with the writer. But it also introduces new knowledge and skill requirements, since the writer has to know how to apply conditions and apply them correctly, which is not always a simple matter.</db:para>
<db:para>This is a common pattern with management-domain structures; the knowledge requirement they introduce is often greater then the one they factor out. When we factored out list formatting in the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain, leaving the writer to record the fact that they were creating a list, this was a simple reduction of requirements, since the writer always had to make the decision to create a list. But here we are introducing something brand new to learn: conditional markup and its logic and behavior. Let’s look at another example that exhibits the same pattern.</db:para>
<db:section>
<db:title>Including boilerplate content</db:title>

<db:para>Suppose you must include a standard warning statement with any content that describes a dangerous procedure. Structured writing partitions complexity by factoring out invariants, and the invariant here is that this warning statement must appear whenever you describe a dangerous procedure.</db:para>
<db:para>Just as we extracted formatting information into a separate file when we moved content from the media domain to the document domain, we now extract the invariant warning from the document and place it in a separate file. Any place we want this warning to occur, we insert an instruction to include the contents of the file at that location. (see <db:xref linkend="ex.md-2"/>).</db:para>
<db:figure xml:id="ex.md-2"><db:title>Include a warning in a dangerous procedure (SAM markup)</db:title><db:programlisting language="sam">
procedure: Blow stuff up
    &lt;&lt;&lt;(files/shared/admonitions/danger.sam)
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting></db:figure>
<db:para>In the SAM markup in <db:xref linkend="ex.md-2"/>, <db:code>&lt;&lt;&lt;</db:code> is a command that includes the content of the file located at <db:code>files/shared/admonitions/danger.sam</db:code> in the source file replacing the <db:code>&lt;&lt;&lt;</db:code> command.</db:para>
<db:para>The equivalent in XML would look something like <db:xref linkend="ex.md-3"/>.</db:para>
<db:figure xml:id="ex.md-3"><db:title>Include a warning in a dangerous procedure (XML markup)</db:title><db:programlisting language="XML">
&lt;procedure&gt;
    &lt;title&gt;Blow stuff up&lt;/title&gt;
    &lt;xi:include href="files/shared/admonitions/danger.xml"/&gt;
    &lt;step&gt;Plant dynamite.&lt;/step&gt;
    &lt;step&gt;Insert detonator.&lt;/step&gt;
    &lt;step&gt;Run away.&lt;/step&gt;
    &lt;step&gt;Press the big red button.&lt;/step&gt;
&lt;/procedure&gt;
</db:programlisting></db:figure>
<db:para>Why is this operation part of the <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain, rather than the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain? Because it deals with a system operation: locating a file in the system and loading its contents. If we were purely in the document domain, the writer would be the one performing this operation: finding the file with the warning in it, opening it, and copying the contents into the document. The include instruction is just that: an instruction. It is not a declaration about the subject matter or structure of a document, such as we find in <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain or document-domain markup. It is an instruction to a machine to perform an operation. The <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain consists of either instructions or the declaration of data required to perform specific management instructions. It requires the writer to understand these instructions and other features of the content management system such as the location of files.</db:para>
<db:para>Different structured writing systems have different instruction sets for handling the situation described above. In <db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>language</db:primary><db:secondary>DITA</db:secondary></db:indexterm><db:indexterm><db:primary>DITA</db:primary></db:indexterm><db:indexterm><db:primary>standard</db:primary><db:secondary>DITA</db:secondary></db:indexterm>DITA, for instance, this use case is handled using something called a <db:indexterm><db:primary>conref</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>conref</db:secondary></db:indexterm><db:code>conref</db:code> or a <db:indexterm><db:primary>conkeyref</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>conkeyref</db:secondary></db:indexterm><db:code>conkeyref</db:code>. DocBook uses a generic XML facility called <db:indexterm><db:primary>XInclude</db:primary></db:indexterm><db:indexterm><db:primary>tool</db:primary><db:secondary>XInclude</db:secondary></db:indexterm>XInclude, which is shown in <db:xref linkend="ex.md-3"/>. Thus the writer needs to learn the specific management features of the languages and tools they are using.</db:para>
<db:para>One downside of the management-domain include instruction is that writers must have system knowledge to use it correctly. However, the use of conditional expressions or include instructions is not just a problem for writers, it also complicates <db:indexterm><db:primary>change management</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>change management</db:secondary></db:indexterm>change management and <db:indexterm><db:primary>content management</db:primary></db:indexterm><db:indexterm><db:primary>process</db:primary><db:secondary>content management</db:secondary></db:indexterm>content management by distributing management-domain structures such as conditions and file paths throughout your content. Management-domain structures encode management decisions in the content itself. Changing those decisions means changing management structures all over the content set.</db:para>
<db:para>Is there a way to partition management complexity from authoring and keep management decisions out of the content? In many cases this can be accomplished using the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain.</db:para>
</db:section>
<db:section>
<db:title>An alternative approach in the subject domain</db:title>

<db:para><db:xref linkend="ex.md-4"/> shows how you might approach the two-magazines problem in the subject domain:</db:para>
<db:figure xml:id="ex.md-4"><db:title>Subject domain alternative for conditional content</db:title><db:programlisting language="xml">
&lt;wine-match&gt;Pinot Noir&lt;/wine-match&gt;
&lt;beverage-match&gt;Lemonade&lt;/beverage-match&gt;
</db:programlisting></db:figure>
<db:para>This markup says nothing about which documents should contain either of these pieces of information. Nor does it contain the subheadings that would introduce either of them in the appropriate publication. All these decisions are now left to algorithms. This allows you to do far more with this content without having to rewrite the source files in any way. Writers don’t have to understand how the conditional text systems works. They just record two pieces of information.</db:para>
<db:para>We noted in <db:xref linkend="chapter.subject-domain"/> that the subject domain can factor out rhetorical decisions by simply recording facts about the subject. This is another example of this. By recording two different beverage matches, we can make different rhetorical decisions when presenting the recipe to two different audiences. The management domain markup was also attempting to capture two different rhetorical alternatives, but rather than factor them out, it embedded both alternative into a single file. This approach not only makes the writer responsible for making the decision, it also means that changing the decision require you to reopen the file and every file in which a similar decision is made. Thus the subject domain approach not only makes the writer’s live easier, it makes the <db:indexterm><db:primary>change management</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>change management</db:secondary></db:indexterm>change management process much simpler. (I will look more at change management in <db:xref linkend="chapter.change"/>.)</db:para>
<db:para>Every time you move a decision out of the content and into an algorithm, you accomplish two things: you make authoring easier, and you preserve the ability to make different decisions without changing content. Factoring out the management domain is a big win on both fronts.</db:para>
<db:para>Let’s see if we factor out the decision involved in including the warning in dangerous procedures. As we saw in <db:xref linkend="chapter.subject-domain"/>, factoring out invariant content is a feature of the subject domain. In this case, the invariant content comes from the rule: A dangerous procedure must have a standard warning.</db:para>
<db:para>The management-domain approach allows writers to insert a standard warning that is stored in one place.<db:footnote>
<db:para>This approach is a form of content reuse, an algorithm discussed in <db:xref linkend="chapter.reuse"/>.</db:para>
</db:footnote> Notice that the management-domain markup does not encapsulate the invariant rhetorical rule that dangerous procedures must have a standard warning. It simply provides a generic mechanism for inserting content from an external file. The writer must still remember and execute the rule about dangerous procedures.</db:para>

<db:para>The subject-domain approach, on the other hand, is all about the rhetorical rule itself. Specifically, it expresses the aspect of the subject domain that triggers the rule: whether a procedure is dangerous or not. <db:xref linkend="ex.md-5"/> shows how you might mark up this information.</db:para>
<db:figure xml:id="ex.md-5"><db:title>Subject-domain markup for a warning notice</db:title><db:programlisting language="sam">
procedure: Blow stuff up
    is-it-dangerous: yes
    step: Plant dynamite.
    step: Insert detonator.
    step: Run away.
    step: Press the big red button.
</db:programlisting></db:figure>
<db:para>This markup identifies the procedure as dangerous, a fact about the subject matter that our rhetorical standards require us to mention. Rather than making authors remember that a warning is required, locate the warning file, and include a reference to the file, we delegate those decisions to the <db:indexterm><db:primary>publication algorithm</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>publication algorithm</db:secondary></db:indexterm>publication algorithm. The algorithm, not the writer, must remember to include the material in <db:code>files/shared/admonitions/danger</db:code> whenever the <db:code>is-it-dangerous</db:code> field of a <db:code>procedure</db:code> structure is set to <db:code>yes</db:code>. Algorithms are much better at this sort of task than humans are.</db:para>
<db:para>Of course, writers still must remember to set <db:code>is-it-dangerous</db:code> to <db:code>yes</db:code> when they write a procedure (another example of creating a new constraint when we factor out an old one). But you can make it much easier for them to remember this requirement by making <db:code>is-it-dangerous</db:code> a mandatory field in the procedure structure and raising an error if the field is not included. This transfers the complexity of remembering the requirement and fulfilling it from the writer to the <db:indexterm><db:primary>conformance</db:primary></db:indexterm><db:indexterm><db:primary>process</db:primary><db:secondary>conformance</db:secondary></db:indexterm>conformance and <db:indexterm><db:primary>publication</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publication</db:secondary></db:indexterm>publication algorithms.</db:para>
<db:para>With this approach, the writers cannot complete a procedure without supplying the required information. This removes a decision, simplifying the writer’s job. In addition, writers don’t need to know how the content management system works, what warning text is required, or where the text is located. They simply record a fact about the subject – factoring out the complex rhetoric and all of its permutations.</db:para>
<db:para>One the other hand, this approach only factors out the reuse of one particular piece of content – the warning for dangerous procedures. If you have multiple invariant rhetorical rules about different kinds of subject matter, you need a separate subject-domain structure for each of them, whereas a single management-domain include instruction would let the writer handle them all.</db:para>
<db:para>On the other other hand, if you have many invariant rules, and you expect writers to remember all of them, you are asking your writers to carry an awful lot of rhetorical constraints in their heads, and you are going to limit your pool of writers to a few highly trained individuals. And those individuals are still likely to miss some instances leading to omissions – rhetorical failures – that can have dangerous consequences for the reader.</db:para>
</db:section>
<db:section>
<db:title>Hybrid approaches</db:title>

<db:para>It is not always an either/or decision to use pure <db:indexterm><db:primary>management-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management-domain</db:secondary></db:indexterm>management-domain or pure <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain approaches. Management-domain structures tend to be used in generic document-domain languages, since such languages are not designed to be specific to any particular subject matter. Nonetheless, such languages often have roots in particular fields and sometimes include <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain structures from those fields. Both DocBook and DITA, for instance, originated in the field of software documentation, and both include structures, such as code blocks, that are related to the subject of software.</db:para>
<db:para>Some languages mix subject-domain structures into their management structures. One example is the <db:indexterm><db:primary>@product</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>@product</db:secondary></db:indexterm><db:code>product</db:code> attribute, which is part of DITA’s conditional-text processing system.</db:para>
<db:para>DITA lets you add the <db:indexterm><db:primary>@product</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>@product</db:secondary></db:indexterm><db:code>product</db:code> attribute to a wide variety of elements. Your build system can then include or exclude elements in a particular output based on the value of that attribute. <db:xref linkend="ex.md-7"/> shows an example of the DITA <db:indexterm><db:primary>@product</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>@product</db:secondary></db:indexterm><db:code>product</db:code> attribute.</db:para>
<db:figure xml:id="ex.md-7"><db:title>DITA product attribute example</db:title><db:programlisting language="DITA">
&lt;p&gt;
the car seats &lt;ph product="CX-5"&gt;5&lt;/ph&gt;&lt;ph product="CX-9"&gt;7&lt;/ph&gt;
&lt;/p&gt;
</db:programlisting></db:figure>
<db:para>DITA can afford to use this bit of subject-domain markup because product variations are a common reason for using conditional text processing in technical communication, the area for which DITA was created.<db:footnote>
<db:para>DITA can add other subject-domain attributes for conditional processing through a process called <db:emphasis>specialization</db:emphasis>. <db:xref linkend="chapter.extensible"/> has additional information about DITA specialization.</db:para>
</db:footnote></db:para>

<db:para>I call this a hybrid approach because the DITA <db:indexterm><db:primary>@product</db:primary></db:indexterm><db:indexterm><db:primary>structure</db:primary><db:secondary>@product</db:secondary></db:indexterm><db:code>product</db:code> attribute does not exist merely to declare that a piece of text applies to a particular product. It is a conditional-processing attribute. That is, it is an instruction, even though it is phrased as a subject-domain declaration.</db:para>
<db:para>To appreciate the difference, consider another approach to documenting multiple versions of a product. Rather than generating a separate document for each product variant, you could create a single document that covers all product variants and highlights the differences. Pure subject-domain markup would support either approach by simply recording the data for each variant:</db:para>
<db:programlisting language="sam">
seats:
    CX-5: 5
    CX-9: 7
</db:programlisting>
<db:para>This information could be presented as data similar to its source format or it could be used to algorithmically construct a sentence like this:</db:para>
<db:blockquote>
<db:para>The CX-5 seats 5 and the CX-9 seats 7.</db:para>
</db:blockquote>
<db:para>The product attribute does not provide this flexibility:</db:para>
<db:programlisting language="DITA">
&lt;p&gt;The car seats 
&lt;ph product="CX-5"&gt;5&lt;/ph&gt;&lt;ph product="CX-9"&gt;7&lt;/ph&gt;
&lt;/p&gt;
</db:programlisting>
<db:para>This markup is designed to produce only a CX-5 or a CX-9 specific document. It is not designed to produce a document that covers both cars at once, because it does not specify that the values 5 and 7 are numbers of seats. That information is in the text, but not in a form that a publishing algorithm could reliably locate and act on.</db:para>
<db:para>Also, no writer would expect this management-domain markup to be used to create a single document covering both cars. No writer would interpret the markup to mean this. Rather than declaring facts about each car, this markup was designed to produce a document about one car or the other, not both. It is conditional-text markup and, therefore, an instruction.</db:para>
<db:para>While the introduction of subject-domain names into <db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain structures provides an appropriate bit of semantic sugar for authors, this hybrid approach really remains firmly in the management domain.</db:para>
<db:para>In the following chapters we will see many more examples of the management domain, including cases where there is and is not a <db:indexterm><db:primary>subject-domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject-domain</db:secondary></db:indexterm>subject-domain alternative.</db:para>
<db:indexterm class="endofrange" startref="idp140481924616896"/><db:indexterm class="endofrange" startref="idp140481924616896x"/></db:section>
</db:chapter>
