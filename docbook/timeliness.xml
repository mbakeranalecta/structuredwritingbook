<?xml version="1.0"?>
<db:chapter xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings" version="5.0" xml:id="chapter.timeliness"><db:title>Timeliness</db:title>




<db:para>Information tends to change quickly these days, and readers no longer have any patience with outdated content. But there are many difficulties in ensuring that content is always timely. How do you detect when content is out of date? How do you push updated content to the reader quickly? How do make sure updates in one place don’t break content in another place? These are all sources of complexity in the content process. They are also part of the complexity of many of the algorithms we have already looked at. Poor partitioning and redirection of complexity in any of these algorithms, or any leaking of complexity within them or in the way they hand off responsibilities to other partitions, will impact your ability to deliver in a timely fashion.</db:para>
<db:para>Traditional paper <db:indexterm><db:primary>publication</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>publication</db:secondary></db:indexterm>publication could endure considerable inefficiency in these processes because publication was a rare event. Indeed, publication was treated very much like a wedding day. All the effort and coordination of the preceding months went into making that day work, and normal life for many of those involved ceased several day before the event itself. The complexity of getting everything ready for that day, and of executing all the events of the day, was enormous, and tolerable only because such wedding day publication events were rare.</db:para>
<db:para>For modern Web publishing, a wedding day model of publication is untenable. Publication has to be a simple and quick process because it happens every day. Every day is publication day. You cannot treat every day like a wedding day. There can be no elaborate process of getting ready. Instead, you need to maintain your systems and your content in a constant state of readiness to publish. To attempt to do this without the correct partitioning and distribution of complexity in your content system is to be certain that much of the complexity will get dumped on the reader in the form of outdated, inaccurate, or inconsistent content. Structured writing provides ways to address all of these issue.</db:para>
<db:para>Timeliness really rests on executing the entire content process, from ideas in the head to dots on a page in the hands of a reader, in the shortest time possible, while maintaining all of your <db:indexterm><db:primary>quality</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>quality</db:secondary></db:indexterm>quality goals. Thus all of the structured writing algorithms can contribute to timeliness.</db:para>
<db:variablelist>
<db:varlistentry>
<db:term><db:indexterm><db:primary>Separating content form formatting</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>Separating content form formatting</db:secondary></db:indexterm>Separating content form formatting</db:term>

<db:listitem><db:para>Formatting content by hand takes time and is subject to unintended variation through human error. If you want to publish quickly and with consistent formatting, you need to factor out the formatting from the content and hand the formatting task over to a formatting algorithm. This will allow you to shorten the time it takes to publish by making formatting and output virtually instantaneous once the writing is finished. It also helps speed up the writing process and improve content quality by avoiding the division of the writer’s attention between writing and formatting. However, it is important to make sure that the structures you create to factor out formatting are not more complicated for authors to deal with than the formatting they replaced.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:indexterm><db:primary>Single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>Single sourcing</db:secondary></db:indexterm>Single sourcing</db:term>

<db:listitem><db:para>If you are delivering content to multiple media, you need to avoid having to separately prepare the content for publication in different media. The less manipulation of the content you have to do to output to each target media, the better. If your want to maintain equal quality across different media, taking a <db:indexterm><db:primary>differential single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>differential single sourcing</db:secondary></db:indexterm>differential single sourcing approach will ensure high quality in each media without slowing down the publishing process.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:indexterm><db:primary>content reuse algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content reuse algorithm</db:secondary></db:indexterm>Content reuse</db:term>

<db:listitem><db:para>Content reuse can improve timeliness by avoiding the need to create content twice. If a new piece of content can be created by pulling in pieces of existing content, that may allow you to get it out faster. Be careful not to assume that this is an automatic win, however. The reuse process itself takes time. A lot of its payoff comes not from reducing end to end authoring time but from avoiding re-<db:indexterm><db:primary>translation</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>translation</db:secondary></db:indexterm>translation of content. Complex reuse systems also require the work to be done by authors who are conversant with the tools and with the content set (so that they can find reused content efficiently). The availability of those authors may impact your ability to move quickly. Reuse can be a timeliness win under the right circumstances, but don’t loose track of the fact that simplicity can often be a key virtue when you need to act quickly.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Eliminating duplication</db:term>

<db:listitem><db:para>Where it can be achieved, maintaining a <db:indexterm><db:primary>single source of truth</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>single source of truth</db:secondary></db:indexterm>single source of truth can be a huge win for timeliness. If you can assure that there is only one source for a particular truth (however you define truth for this purpose) then you simply deliver it where required.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:indexterm><db:primary>linking algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>linking algorithm</db:secondary></db:indexterm>Linking</db:term>

<db:listitem><db:para>One of the most challenging aspects of adding new content or removing old content in a timely fashion is managing the links. The new content should link to all relevant content in the current content set, and the current content should link to the new content where appropriate. When content is removed, all the content that links to it should be updated, either to remove the link or to link to something else. Any structured writing approach that manages links will help with this, but by far the most efficient way to deal with it is to use the soft linking approach detailed in <db:xref linkend="chapter.linking"/>.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:indexterm><db:primary>Publishing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>Publishing</db:secondary></db:indexterm>Publishing</db:term>

<db:listitem><db:para>Automating publishing can allow you to release content much more quickly. This is particularly important if you are going to release content to multiple media or if the changes you need to make affect multiple pieces of content. If you are going to do continuous publishing successfully, this means that most of your publishing processes have to be hands off and highly reliable. Merely automating the publishing build does little for you if you then have to do extensive manual quality assurance of the output. You need to build reliability into the content and processes from the beginning so that you can confidently press the publication button without needing to look at the output.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term>Generating content</db:term>

<db:listitem><db:para>Changes to subject matter don’t just affect individual pieces of content. They affect the overall information architecture. If you know that your content is going to change on a regular basis, it makes sense to create an information architecture that is highly adaptable to change. The more of your architecture that can be generated by algorithms, the easier it will be to make architectural changes in response to change. But having your information architecture implemented by algorithms requires structured writing techniques that enable the architectural routines to access the aspects of the content they need to organize it. A bottom-up information architecture is particularly effective at handling rapid and constant change. Implementing a bottom-up architecture, which relies heavily on well structured topics connected by rich linking, benefits enormously from structured writing techniques. By changing the way content is organized and linked, these techniques can allow you to add and remove individual pages from a content set without fear of breaking things.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:indexterm><db:primary>extract algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>extract algorithm</db:secondary></db:indexterm>Extract</db:term>

<db:listitem><db:para>The extract algorithm is not just a great shortcut for generating content, it is also a great way to keep up with changes in the real world. If the data source that you are drawing content from is updated, simply repeating the extraction and republishing the content will bring it up to date. If you want to be really up to date, you can also run the extract algorithm dynamically, only pulling content from source when the reader requests it. If you have a fully automated publishing process that does not require any user intervention, you can effectively publish live data right out of the source file.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:indexterm><db:primary>merge algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>merge algorithm</db:secondary></db:indexterm>Merge</db:term>

<db:listitem><db:para>In many cases the <db:indexterm><db:primary>extract algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>extract algorithm</db:secondary></db:indexterm>extract algorithm works with the <db:indexterm><db:primary>merge algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>merge algorithm</db:secondary></db:indexterm>merge algorithm to combine content extracted from another source with content written by authors. In this case, you can use changes in the source as a flag to tell you when changes in the written content are required.</db:para></db:listitem>
</db:varlistentry>
</db:variablelist>
<db:para>Similarly, all the elements of your process must be working well in order to maintain quality while providing timely delivery.</db:para>
<db:variablelist>
<db:varlistentry>
<db:term><db:indexterm><db:primary>Content management</db:primary></db:indexterm><db:indexterm><db:primary>process</db:primary><db:secondary>Content management</db:secondary></db:indexterm>Content management</db:term>

<db:listitem><db:para>Every change in a content set is a content management action. Unless you design your system very carefully, the cost of each content management action will increase as the size of the content set grows, as each action has to take account of the possible impacts on a greater number of resources. Using structured writing techniques to automate aspects of content management can help avoid the cost of content management escalating as the content set grows and can make each individual content management action easier and more reliable.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:indexterm><db:primary>Collaboration</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>Collaboration</db:secondary></db:indexterm>Collaboration</db:term>

<db:listitem><db:para>Collaboration can do a great deal to improve the timeliness of content by making more authors available to contribute content and by moving content creation close to the source of information changes. Structured writing can be a double edged sword when it comes to collaboration. By automating publishing and information architecture, it can make it much easier to coordinate the efforts of multiple contributors. By supporting composability, it can make sure that the contributions of different collaborators work well together. And by enforcing content constraints, it can help assure that all contributors create content that does the job it is supposed to do. At the same time, however, many structured writing systems are difficult to learn and use, making it difficult for collaborators to contribute. They can also be expensive, making it uneconomical to include occasional contributors as authors. Both of these problems can be avoided by focusing heavily on the functional lucidity of your structures and markup, which not only avoids the heavy learning curve of structured writing, but removes the need for complex editing tools.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:indexterm><db:primary>Auditing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>Auditing</db:secondary></db:indexterm>Auditing</db:term>

<db:listitem><db:para>A huge part of timeliness is knowing when new content, or edits to old content, are required. The world changes all the time, but unless you have an efficient way to determine the impact of those changes on your content set, you can’t respond to those changes in a timely manner. Taking a structured writing approach to auditing, as outlined in <db:xref linkend="chapter.audit"/>, can go along way to ensuring that you always know when changes need to be made, and that you can find all of the content that needs to be changed.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:indexterm><db:primary>Change management</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>Change management</db:secondary></db:indexterm>Change management</db:term>

<db:listitem><db:para>While the <db:indexterm><db:primary>audit</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>audit</db:secondary></db:indexterm>audit algorithm will alert you to the need for changes in a timely manner, the execution of those changes still needs to be managed in order to respond in a timely manner without compromising quality. Using structured writing techniques to facilitate change management can help ensure that the required changes get made quickly and reliably.</db:para></db:listitem>
</db:varlistentry>
<db:varlistentry>
<db:term><db:indexterm><db:primary>Repeatability</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>Repeatability</db:secondary></db:indexterm>Repeatability</db:term>

<db:listitem><db:para>Repeatability is key to timely delivery. Repeatability is the ability to make sure that you are doing the same thing each time, and if you don’t have a good process for doing that, you can’t deliver quickly without the risk of introducing variability into your content and its quality.</db:para></db:listitem>
</db:varlistentry>
</db:variablelist>
<db:para>The way in which you select and integrate all of the other structured writing algorithms and processes that you use has a big impact on your ability to deliver in a timely fashion. Optimizing individual pieces may not gain you the time you are looking for, or may not maintain your quality standards while delivering quickly. You need to think careful about where bottlenecks can occur in your overall process and about any points in the chain where complexity may go unhandled and end up being dumped on the reader.</db:para>
<db:para>While much of your content structure design activities will be done in terms of the specific algorithms you want to support, a concern with timeliness demands that you think about how those structures affect the timeliness and quality of the entire process. Complex <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain/<db:indexterm><db:primary>management domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>management domain</db:secondary></db:indexterm>management domain <db:indexterm><db:primary>reuse</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm>reuse structures, for instance, may save time by avoiding duplicate work, but you need to think about the time it takes authors to use these features, and any quality traps that lurk in their use. You also need to think about whether the use of such features could leave you overly dependent on particular writers with particular training to make changes when they are needed. The most technically efficient system is of little value if the only person who can execute it is on vacation. All structured writing systems require special skills in certain key roles, but it pays to avoid setting up your system in a way that creates skill bottlenecks for executing short term content changes.</db:para>
<db:para>One of the key features of the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain is that subject domain structures support multiple algorithms with the same markup. This can be an enormous benefit in ensuring timeliness. Not only does it simplify the content changes that need to be made to respond in a timely fashion, it hands more of the management and production phases over to algorithms, which are always faster than people. It also means that content updates require no knowledge of the management systems, which helps avoid a skills bottleneck for content changes.</db:para>
</db:chapter>
