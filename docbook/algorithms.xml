<?xml version="1.0"?>
<db:partintro xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings">

<db:para>Most books on structured writing begin by describing structures: the various ways in which you can partition a document. Only later do they talk about algorithms, the way you process that document based on the structures into which it has been partitioned.</db:para>
<db:para>I think this is the wrong way to look at the problem. There are two main reasons that we structure documents. One is to govern their rhetoric, what they say and how they say it, and the other is to enable us to process them with algorithms. The structures themselves are merely enablers. Until we know what rhetoric we want to govern and what algorithms we want to run, there is no point is talking about the structures we want to create. Therefore this book will begin with algorithms, which are the subject of this part. We will look at rhetoric at the beginning of the next part, which deals with structures.</db:para>
<db:para>Most of this part of the book will deal with specific algorithms – specific ways of processing content within an overall content system. But it will begin with a consideration of <db:indexterm><db:primary>quality</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>quality</db:secondary></db:indexterm>quality. The design of algorithms – the design of processes generally – should always begin with quality. The purpose of an algorithm or process is to produce a quality product. However, it is all too easy to lose sight of quality when you are down in the nitty gritty of algorithm design, and to end up doing things merely because they are efficient, ignoring their impact on quality. This has happened too often in the design of content systems and it is an error I think we have to be particularly careful to avoid going forward.</db:para>
<db:para>Another issue that we have to keep in mind while designing a content process or algorithm is <db:indexterm><db:primary>writing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>writing</db:secondary></db:indexterm>writing. Writing is at the heart of any content process, which is to say that writers are at its heart. An algorithms is not merely a process happening within a computer system. Algorithms are, in fact, an interaction, a conversation, between a human being and a machine. This is why interface design and user experience design are now recognized are fundamentally important to system and application design. No algorithm can perform successfully if it is hobbled at the start by a poor interaction with the human. An algorithms that is designed entirely for its own internal efficiency, but which presents a difficult interface to the user, is doomed to be neither efficient nor effective. The chapter on writing, therefore, seeks to lay out the basic considerations that must be made for the writer in the design of any structured writing algorithm.</db:para>
<db:para>Keeping the goal of quality and the necessity of creating a good user experience for writers firmly in mind, I will then look at the major structured writing algorithms. We will see that each of the algorithms can be approached differently in each of the structured writing domains. The choice of domains can radically shift the cost and quality effects of an algorithm, the ease of use for writers, as well as the ways in which the content system is partitioned.</db:para>
<db:para>When going through the algorithms, it is important to remember that the overall goal is to partition your whole content system so that every decision in your content system is handled by a person or process with the skills, time, and resources to handle it. Your focus should not be on implementing any single algorithm, but on using the appropriate algorithms, and the appropriate structured writing domains, to optimize your whole system.</db:para>
<db:remark>mb - 
Integrate the above with the below
</db:remark>
<db:para>When we use structured writing to partition the complexity of the content system, we are partitioning much of that complexity to algorithms. This means that functions that used to be performed by people will now be performed by algorithms. This means that the people who are responsible for these functions will no longer be doing them by hand but will instead by responsible for defining, creating, and maintaining the algorithms that do them. This can include writers, who may create structures and algorithms to guide the rhetorical structure of content or to validate and audit content. If they don’t create these algorithms themselves, they will at least need to understand how to commission others to do it for them.</db:para>
<db:para>For this reason, the study of structured writing is first and foremost the study of algorithms. The chapters in this section will explore each of the main structured content algorithms, looking at both the function the algorithm performs and the structures that define the interfaces that supply information to those algorithms. However, these are not chapters on programming. Defining an algorithm for a process and writing software to implement that algorithm are two separate tasks. They may be performed by the same person or by different people. But the aim of this section is to introduce you to the design and capability of structured writing algorithms, not to the coding of software.</db:para>
<db:para>The chapters in this section cover a wide range of subjects, from publishing to reuse, from linking to collaboration, and from authoring to auditing. Some of these go well beyond what we think of as traditional publishing or content management functions. They also consider how each algorithm is performed in each of the structured writing domains. Some algorithms can be implemented in different domains. Some can only be effectively addressed in some of the domains, and the difference in both approach and reliability between implementations in different domains can be substantial.</db:para>
<db:para>As you go through these algorithms, however, be careful not to get too attached to any one domain or any one algorithm. As I noted at the beginning, quality in a modern content system is produced by partitioning the complexity of the whole systems so that every part of that complexity is handled by a person or process with the skills, time, and resources to handle it completely. Implementing any one algorithm in isolation can result in complexity being distributed out to other parts of the content system that are not well equipped to handle it. The aim is not to optimize any one function, but to ensure that complexity is being handled effectively across the whole content system. That will require a combination of algorithms designed to partition the content system appropriately to handle the unique set of factors that contribute complexity to your individual content system.</db:para>
<db:para>Following the chapters on quality and writing, the rest of this part of the book covers the following:</db:para>
<db:section>
<db:title>The basics</db:title>
<db:para>The next two chapters will review the basics of structured writing: how we partition the various elements of our content and how we put them back together again. The classic piece of content partitioning that everyone has heard of is <db:indexterm><db:primary>separating content form formatting</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>separating content form formatting</db:secondary></db:indexterm>separating content form formatting, so we will look at how this is done. In doing so we will examine all the basic techniques that will be used to enable all the other algorithms.</db:para>
<db:para>Then we will look at how to define the algorithms that unite content and formatting for publishing. Here again we will learn a few basic principles that will apply to all the other algorithms we will examine.</db:para>
</db:section>
<db:section>
<db:title>Single sourcing and reuse</db:title>
<db:para>The classic applications of structure writing and content reuse. As we will see, there is far more to structured writing than just these things, but they remain an important part of the structured writing picture.</db:para>
<db:para>We will look at <db:indexterm><db:primary>single sourcing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>single sourcing</db:secondary></db:indexterm>single sourcing, and see that, depending on how different our target outputs are, we may require more or less separation and may need to use different domains to get the partitioning we need, particularly when we need to practice differential single sourcing – creating different forms of content for different audiences and different media.</db:para>
<db:para>We will look at the several different techniques that can be used to <db:indexterm><db:primary>reuse</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>reuse</db:secondary></db:indexterm>reuse content, and the pluses and minuses of each. Here again we will see that the use of different domains can make a big difference in both quality and efficiency.</db:para>
<db:para>We will then look at the related problem of <db:indexterm><db:primary>composition algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>composition algorithm</db:secondary></db:indexterm>composition: creating content that can be assembled like building blocks, and the quality pitfalls that lies in wait in this area.</db:para>
<db:para>Then we will look at the problem of <db:indexterm><db:primary>avoiding duplication</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>avoiding duplication</db:secondary></db:indexterm>avoiding duplication and see that the central problem is to define when two pieces of content are duplicates, and when they are useful variations. Again we will see that implementing a duplication detection and avoidance system can work very differently in the different <db:indexterm><db:primary>structured writing domains</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>structured writing domains</db:secondary></db:indexterm>structured writing domains.</db:para>
</db:section>
<db:section>
<db:title>Linking and the connections between subjects</db:title>
<db:para>Next we will look at <db:indexterm><db:primary>linking algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>linking algorithm</db:secondary></db:indexterm>linking, and I will show that linking is really a larger problem than managing links. Linking is actually about managing the relationship between content and its subject matter. In a differential single-sourcing situation you may want to handle this differently in different media, using links in some media and other devices in others. This requires a step back from thinking about links to thinking about the relationships between subjects and the content that describes them. In this case, the choice between the <db:indexterm><db:primary>document domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>document domain</db:secondary></db:indexterm>document domain and the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain becomes absolutely crucial to both quality and efficiency.</db:para>
</db:section>
<db:section>
<db:title>Quality control</db:title>
<db:para>One of the less appreciated aspects of structured writing is the huge role it can play in content quality control. We will look at two quality control algorithms that can have a huge impact on both quality and efficiency.</db:para>
<db:para>The first of these is the <db:indexterm><db:primary>conformance algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>conformance algorithm</db:secondary></db:indexterm>conformance algorithm, which is concerned with making sure that your writers, and all the other roles that contribute to your content system, consistently produce work that meets your quality standards. We will look at three fundamental components of conformance: factoring out constraints, enforcing constraints, and enabling and encouraging voluntary conformance.</db:para>
<db:para>The second quality control algorithm is <db:indexterm><db:primary>auditing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>auditing</db:secondary></db:indexterm>auditing: the ability to ascertain at any given moment the state of your content set, what your have, what you need, and how conformant it is.</db:para>
<db:para>Again we will see that the choice of the domain in which you create your content can have a huge impact on the degree of conformance you can achieve and the cost, reliability, and extent of the auditing you can do.</db:para>
</db:section>
<db:section>
<db:title>Finding content</db:title>
<db:para>The ability to find content is crucial. It is essential to writers, to content managers, to readers, and to algorithms. The key to finding things is the <db:indexterm><db:primary>relevance algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>relevance algorithm</db:secondary></db:indexterm>relevance algorithm. Searchers seeks content that is relevant to their concerns. The relevance algorithm is about first making sure that content expresses its relevance, so it can be found, and second that it actually is relevant audience and the subject matter it claims to be.</db:para>
</db:section>
<db:section>
<db:title>Generating content</db:title>
<db:para>Not all content has to be written from scratch. Much commercial content is essentially the narration of company or product data and algorithms can make the process of narrating that data much faster and more reliable. As a bonus, generated content can also be an enormously useful resource for auditing the rest of your content set.</db:para>
<db:para>There are three algorithms used in generating content. The first is the <db:indexterm><db:primary>extract algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>extract algorithm</db:secondary></db:indexterm>extract algorithm, which pulls content out of existing data sources and puts it into a format that can be published as content.</db:para>
<db:para>The second is the <db:indexterm><db:primary>merge algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>merge algorithm</db:secondary></db:indexterm>merge algorithm. Often the content our readers need is a combination of generated content and content written by writers. The merge algorithm enables us to take extracted and written content and combine them to create useful outputs for readers.</db:para>
<db:para>The third is the <db:indexterm><db:primary>modeling algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>modeling algorithm</db:secondary></db:indexterm>modeling algorithm. In some cases, extracting content to describe some highly regular aspect of a system would make perfect sense, but there is no existing data set to draw the information from. In these cases, we can use structured writing techniques to create data that model the product or process we are documenting so that we can use extract and merge techniques to generate content. The model can also be a major source of data for <db:indexterm><db:primary>auditing</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>auditing</db:secondary></db:indexterm>auditing other parts of your content.</db:para>
</db:section>
<db:section>
<db:title>Information architecture</db:title>
<db:para><db:indexterm><db:primary>information architecture algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>information architecture algorithm</db:secondary></db:indexterm>Information architecture is the overall arrangement of a content set so that readers can find information. It covers everything from the purpose and scope of individual documents to linking, search, and navigational aids. Maintaining a consistent and effective information architecture, especially on a large and constantly changing site, is dauntingly complex. Structured writing techniques can not only help you define and manage your information architecture, and audit its effectiveness, they can be used to generate and maintain architectural features that would not be possible by individual human effort. Again we will see that the choice of domain is crucial to both quality and efficiency in information architecture.</db:para>
</db:section>
<db:section>
<db:title>Managing content and process</db:title>
<db:para>Content has to be manged, and the management of content introduces lot of complexity into the content process. As we will see in these chapters, the effective management of content cannot be separated from its structure. In fact, its structure is key to its manageability.</db:para>
<db:para>One of the largest sources of complexity in the content system is dealing with <db:indexterm><db:primary>change</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>change</db:secondary></db:indexterm>changes in subject matter and business requirements, a problem that has become much more acute in the age of the Web where everyone expects all content to be constantly up to date. The structure of content deeply effects your ability to find content that needs to change, to change it quickly and effectively, and to deal with the ripple effects of change.</db:para>
<db:para>In a large content organization, were the activities of many contributors have to be coordinated, the management of content assets themselves becomes a major source of complexity. <db:indexterm><db:primary>content management algorithm</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>content management algorithm</db:secondary></db:indexterm>Content management system are themselves highly structured, and the structure of the content management system and the structures of the content meet and may overlap. Matching your content management strategy to the structure of your content is key to distributing content management complexity effectively.</db:para>
<db:para><db:indexterm><db:primary>Collaboration</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>Collaboration</db:secondary></db:indexterm>Collaboration has become an ever more important part of the content system as the Web forces us to deliver information in real time and to continually integrate the work of many different contributors. Without effective partitioning, the overhead of collaboration an overwhelm a system making it impossible to keep to schedule and maintain quality. Specific approaches to structured writing, particularly in the <db:indexterm><db:primary>subject domain</db:primary></db:indexterm><db:indexterm><db:primary>concept</db:primary><db:secondary>subject domain</db:secondary></db:indexterm>subject domain can greatly reduce collaboration overhead and allow diverse contributions from diverse contributors to be integrated smoothly into the content collection.</db:para>
<db:para>The immediacy of the Web and the speed of modern commerce make <db:indexterm><db:primary>timeliness</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>timeliness</db:secondary></db:indexterm>timeliness and indispensable aspect of modern content. Yet handling the complexities of the content process can significantly slow the pace at which content goes from requirement to writing to publishing. All of the structured writing algorithms can contribute to enhanced timeliness, but most important of all is using them together in a way that ensures the no complexity is neglected in the process of getting content rapidly to market.</db:para>
<db:para>Finally, <db:indexterm><db:primary>repeatability</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>repeatability</db:secondary></db:indexterm>repeatability is the core goal of all management processes. Doing the right thing once is a work of craft. Ensuring that the right thing is done time after time is a work of management. But repeatability in content is about more than ensuring a efficient process. It is key to achieving consistent <db:indexterm><db:primary>quality</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>quality</db:secondary></db:indexterm>quality, and also the key to measuring the quality of your content and whether it is working effectively for your readers.</db:para>
</db:section>
<db:section>
<db:title>Publishing</db:title>
<db:para>In the end, of course, all content must be published in order to be accessible to readers. Publishing in a structured writing environment is complex, largely because so many of the other structured writing algorithms are actually executed during the publishing process. To facilitate this, most structured writing system implement a multi-step publishing process that allows different algorithms to be plugged in at the appropriate points in the process. This chapter will outline the partitioning of a structure publishing system, indicating were each of the other algorithms are executed in the process.</db:para>
<db:para>But publishing today is often about more than producing static outputs. In many cases, we publish <db:indexterm><db:primary>active content</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>active content</db:secondary></db:indexterm>active content, content that either shapes itself to the reader or allows the reader to manipulate it on the fly. All of the active content algorithms are actually the same structured writing algorithms we have already looked at, but publishing active content changes were they fit in the publishing process. And preparing for active content means structuring your content for the algorithms that will be used to generate the active content. This is another area in which the structured writing domain you have chosen, as well as the specific structures you have implemented will make a huge difference in what you are able to deliver to the reader.</db:para>
</db:section>
<db:section>
<db:title>Translation</db:title>
<db:para>Finally, <db:indexterm><db:primary>translation</db:primary></db:indexterm><db:indexterm><db:primary>algorithm</db:primary><db:secondary>translation</db:secondary></db:indexterm>translation is a major source of complexity in many content systems. Translation deserves a book all to itself, but this chapter will show some of the basic ways in which structured writing, and the various structured writing algorithms, can make a big difference for translation quality and costs.</db:para>
</db:section>
</db:partintro>
