<?xml version="1.0"?>
<db:partintro xmlns:db="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:strings="http://exslt.org/strings">

<db:para>Most books on structured writing begin by describing structures: the various ways you can partition documents. Only later do they talk about algorithms: the way you process documents.</db:para>
<db:para>I think this is the wrong way to look at the problem. We structure documents for three main reasons:</db:para>
<db:itemizedlist>
<db:listitem>
<db:para>To govern rhetoric, what we say and how we say it</db:para>
</db:listitem>
<db:listitem>
<db:para>To enable us to manage content and the processes that create it</db:para>
</db:listitem>
<db:listitem>
<db:para>To enable us to process documents with algorithms</db:para>
</db:listitem>
</db:itemizedlist>
<db:para>We create structures to partition the content production process between different roles and algorithms. The structures are created to pass information forward from one partition to another. The definition of structures, therefore, depends on the needs of the partitions to which the structures are passed, and most of these partitions are implemented by algorithms.</db:para>
<db:para>Until we understand the basics of structured writing algorithms, therefore, we are not really in a position to define appropriate structures.</db:para>
<db:para>Structured writing algorithms basically come down to four operations: separate, combine, relate, and transform. The chapters in this part we will look at how these basic operations are used to implement the fundamental structured writing algorithms.</db:para>
<db:para>However, these are not chapters on programming. Defining an algorithm and writing software to implement that algorithm are two separate tasks. This part introduces you to the design and capability of structured writing algorithms, not to the coding of software.</db:para>
</db:partintro>
