chapter:(#chapter.media-domain) Writing in the Media Domain

    <<<(annotations.sam)

    index:: type, term
        concept, media domain
        concept, document domain 
        concept, subject domain
        concept, formatting algorithm
        concept, presentation algorithm
        concept, rendering algorithm
        concept, structured writing domains
        
    In the media domain, structures relate to the medium in which the content is displayed. Such content is often considered unstructured, but all content has structure, and you can find all the patterns and techniques of structured writing in the media domain. This makes it a good place to begin our study of the fundamentals of {structured writing}(concept).

    At its most basic, a hand guiding a pen over paper or a chisel into stone is working in the media domain through direct physical interaction with the medium. The writer guiding that pen both makes and executes decisions about the shape of letters, along with all the other decisions that fall on a writer.

    >>>(image ../graphics/handwritten-photo.xml)

    The closest you get to pen and paper in the computer world is to use a paint program to directly place dots on the screen. You select the pen tool and use your mouse or a stylus to write. This records the text as a matrix of dots. 
    
    >>>(image ../graphics/handwritten-bitmap.xml)

    There is little structure here. There's just a pattern of dots, which represents text characters only in the sense that humans can recognize the pattern as text. The computer records the effect of your decisions about letter shapes, but it has no idea that they are letters. 
    
    This is an inefficient way to write. You can work faster if you use the paint program's text tool.   

    >>>(image ../graphics/typed-bitmap.xml)

    The text tool is our first step into structure. It partitions the complexity of forming letter shapes from the task of writing letters and directs that complexity to an algorithm in the paint program, which forms letters better and more efficiently, as you can see from the much neater letter shapes in the sample above. However, those letters are still recorded as a set of dots, not as characters, so you can't go back and edit your text as text, only as dots. The paint program forms the letter shapes, but it records dots. Therefore, it loses the partitioning when it records the content.
    
    This failure to maintain the partitioning is a common problem in structured writing. For example, some {wiki} systems allow you to define content templates but don't record the structure of the template in the resulting page. The ability to maintain the partitioning of complexity is a key feature of a mature and reliable content system, but it is often neglected.
    
    To partition the complexity of forming and editing letter shapes completely, you need to move away from dots and start using a tool that records characters as characters. You could go to a text editor, but a text editor does not keep any formatting information,[*fn.md1] thus dropping the complexity of shaping letters, not partitioning it. For most publishing purposes, plain text is inadequate. We need to maintain the ability to format the document.

    footnote:(*fn.md1)
        This is true unless you add markup to your text, but that would be getting ahead of ourselves.
        
    One type of program that records text with formatting attached is a vector graphics program. A vector graphics program creates graphics as a collection of objects. For example, to represent a circle, a vector graphics program records an abstraction: a mathematical formula that uses the essential properties of a circle -- the center, diameter, line weight, etc. -- rather than a set of dots. The program partitions the complexity of circle drawing into the circle object. The computer then lets you manipulate that abstraction as an object, only rendering it as actual dots when the graphic is displayed on screen or paper.

    figure:(*objects-vs-dots) Objects vs. dots
        >>>(image ../graphics/object-vs-dots.xml)

    In [*objects-vs-dots] you see a circle as an object displayed in a vector graphics program (Inkscape) on the left and a circle as a set of dots in a graphics program (Microsoft Paint) on the right.

    In a typical vector graphics program, a shape is rendered into dots on screen instantly as you draw or edit the shape. Nonetheless, the computer is storing data describing the shape, not a circular pattern of dots, as it would in a paint program. In structured writing we call this {separating content from formatting}. The mathematical abstraction of a circle is the content; the dots that represent it on screen are the formatting or, rather, the result of applying formatting to the object.

    By partitioning aspects of the content into a form that algorithms can work with, we can make it easier to create and manage the content. All the principles of structured writing are present in this basic piece of computer graphics. 

    section: Partitioning font information

        Just as a vector graphics program represents a circle as a circle object, it represents text as a text object. A text object is a rectangular area that contains characters. It has numerous {media-domain} properties, such as margins, background and foreground colors, the text string, and the font face, size, and weight used to display that text (see [*text-object]).

        figure:(*text-object) A vector graphics text object
            >>>(image ../graphics/text-object.xml)

        A vector graphics program displays text in a chosen font. If you change the value of the text object's font attribute, it will immediately redraw the text in the new font. Not only has the drawing of letter shapes been partitioned, but the partitioning has been recorded in the source file, meaning you can change the font and font attributes as much as you like without editing the text itself.    
        
        The shape of each character in the font is required to render the text object in the media domain. However, that information is not stored as part of the text object. The representation of the text in the paint program includes the shape of the letters but in the vector graphics program it does not. That information has been partitioned out. 

        figure:(*merge_text_and_font) Merging text and font information
            >>>(image ../graphics/TextPlusFont.xml)

        The shape of the letters (technically, {glyphs}+(italic)) that make up the font are stored separately in font files. Font files consist of a set of shape objects that describe each glyph, together with metadata such as the name of the font and the name of each glyph. To actually display the text, the graphics program uses information in the text object to identify the correct font file, locate the right glyph in that font file, and then draw the appropriate glyph on the current medium (see [*merge_text_and_font]). 

        The font system built into every modern operating system partitions the complexity of rendering formatted text. By transferring this complexity to the operating system, the OS designers make it easier for developers to create applications that work with formatted text. Rather than programming font handling themselves, programmers call operating system APIs ({Application Programming Interfaces}(concept)) to do it for them. It also makes things easier for font designers, since it partitions off the problems of installing fonts and making them available to applications.

        Font handling is a particularly powerful example of partitioning complexity because it means that professionals working in the content domain -- font-designers, tool-developers, and writers -- no longer need to communicate or coordinate to contribute to the content delivery process. 
        
        This is a recurring pattern. We partition information that is constant for a particular application into a separate file -- the shape of the capital letter C is consistent, no matter how many times it occurs in a text -- so we can keep that information separate from the text. This simplifies the format of the information and keeps the downstream presentation more consistent. 

        Designing a content structure, regardless of the domain you choose to work in, essentially consists of identifying the places in the content where we can partition out these invariant properties into separate structures, distributing complexity to where it can be most effectively handled.

    section: Partitioning pagination

        !!!(RLH)
            I don't think you need this much about the document domain at this point. The previous paragraph sums things up nicely. I would either remove this section or change it into a short (one paragraph) lead in to the next chapter. If you want to discuss pagination, I think it would be better to do that in the document-domain section.

        You can cleanly partitioning font handling in the media domain. However, some functions
        Writing a document in a vector graphics program is certainly better than in a paint program -- there are fewer decisions for the writer to make and execute -- but you quickly run into a problem if you try to write a document that covers more than one page. A vector graphics program works purely in the media domain, and pretty much lets you put shapes and text boxes anywhere you like. This certainly allows you to create a new page whenever you need one, simply by creating a new drawing. But what happens when you want to edit the text and need to change how it flows from one page to the next? Pagination is a complex process, one requiring a lot of decisions about how and where to break, and it is tedious and time consuming to execute those decisions by hand. So we look for a way to partition that complexity from the writing task and distribute it elsewhere, preferably to an algorithm.  
         
        Word processors and desktop publishing programs partition the pagination process from the writing process by introducing some document domain constraints. A document is made up of a series of pages that have margins and contain text flows. Text flows are made up of blocks (paragraphs, headings) inside of which text can flow, even from one page to the next. Common features like tables are supported as objects than can exist in text flows. New pages are created automatically as text expands. In other words, the application creates a bunch of text containers and manages the basic decisions about how to fit text into those containers. This leaves authors free to focus on writing and leave pagination decisions to the program.

        Pages, paragraphs, headings, and tables, are all {document domain}(concept) objects. Rather than working on a blank slate, as you do in a graphics program, the writer is now working within the {constraints}(concept) of these document domain objects.  These constraints remove or constrain decisions about positioning of elements, which makes creating documents faster and more consistent. Structured writing is about making content that obeys constraints, and these basic document domain constraints are the next step in that journey.

        Partitioning off the pagination problem is not without its drawbacks, however. There are certain page layout effects that are difficult or impossible to achieve in Word or FrameMaker because you have given up some of the liberty of a vector graphics program. We also gave up some liberty when we moved from raster to vector graphics, which is why photo editing, which requires adjusting individual pixels, is done in raster rather then vector format.

        There is an important lesson here. Handing regular decision making -- meaning decisions based on rules -- to an algorithm is a big advantage. But if you need to make completely ad hoc decisions on the same subject, you may no longer have available the structures to express an arbitrary decision. We are starting to see that different partitioning of the content creation process is appropriate for different kinds of content. There is no one universal correct partitioning and distribution of content complexity that works for every type of content or every organization. This will continue to be the case as we look at more advanced forms of structured writing.        

