chapter:(#chapter.merge) Merge

    <<<(annotations.sam)
    
    index:: type, term
        algorithm, merge
        algorithm, merge algorithm
        
    If the {extract algorithm} gives us access to new sources of {subject domain} content, it does not always give us everything we need for a complete document. Sometimes we need to combine the content we have extracted with content we have written in order to present a complete set of information. This is the job for the {merge algorithm}.
    
    The information that we can extract about an API function from the code that implements it is useful content, there is not enough detail to build a complete  API reference. A good reference entry also requires some explanation of the purpose of the function, a little more detail on its parameters, and possibly a code sample illustrating its use. 
    
    To address this, we can merge authored content covering these topics with the content we have extracted from the source.  
    
    In the case of API documentation tools, the authored content for merging is often written in the source code files. It is contained in code comments and is often written in small {subject-domain}(concept) markup languages that are specific to that tool. (Though as with all subject-domain structures, any other tool can read them if it wants to.)

    Here is an example of authored content combined with source code in JavaDoc[https://en.wikipedia.org/wiki/Javadoc#Example]:

    ```(Java)
        /**
         * Validates a chess move.
         *
         * Use {@link #doMove(int theFromFile, 
         *                    int theFromRank, 
         *                    int theToFile, 
         *                    int theToRank)} to move a piece.
         *
         * @param theFromFile file from which a piece is being moved
         * @param theFromRank rank from which a piece is being moved
         * @param theToFile   file to which a piece is being moved
         * @param theToRank   rank to which a piece is being moved
         * @return            true if the move is valid, otherwise false
         */
        boolean isValidMove(int theFromFile, 
                            int theFromRank, 
                            int theToFile, 
                            int theToRank) {
            // ...body
        }

    
    In this example, everything between the opening `/*` and the closing `*/` is a comment (as far as {Java} itself is concerned), and the rest is a function definition in {Java}. However, {JavaDoc} sees the comment block as a block of structured text using a style of {markup} specific to {JavaDoc}.
    
    The {JavaDoc} processor will extract information from the function definition itself (the {extract algorithm}) and then merge it with information from the authored structured content (the {merge algorithm}). In doing so, it has the chance to validate the authored content, for instance by making sure that the names of parameters in the authored content match those in the function definition itself. This ability to validate authored content against extracted data is an important aid to {conformance} and {auditing}.
    
    However, the {merge algorithm} does not require that the authored content be part of the same file as the data you will be extracting other information from. You can just as easily place the authored content in a separate file. In many cases, this will be the only available approach, since the source format will not provide any place to include documentation. All you need to be able to merge the two is an unambiguous term or combination of terms that you can find in the source data. You then enter that term or terms as a field or fields in the authored content where it can be used to match the authored content to the relevant extracted data.
    
    For example, on one project I worked on, we needed to create a reference for a large body of operating system components. The components were defined in a data file that allowed for a one line description of the component which was intended for display in a GUI configuration editor. We needed to supply much more extensive documentation for each component, so we created an {extract algorithm} to pull information from the data file that defined the components and dumped it to {XML}. We then developed a {subject-domain} {XML} format for capturing all the additional pieces of information we needed to document about each component. We then merged the two sources using the name of the component as the key. This produced an integrated {subject-domain} document, which we then processed into a common document-domain format used for the whole documentation system and processed that document to produce the the formatted reference. Because the operating system components we were documenting supplied additional APIs to the operating system, we also merged in information from the API reference and created links from the component reference to the API reference, all with algorithms. 
     

    One of the downsides of API documentation tools like JavaDoc is that they tend to be tightly coupled systems that produce {media domain} output such as formatted {HTML} directly, often providing little or no control over presentation or formatting. This is a problem because it means that your API reference content does not look like the rest of your content. And worse, it is not integrated with or linked to the rest of your content. This has obvious consequences, like mentions of API routines in you programmer's guide not being linked to the documentation of that routine in the API reference. It would be much better to generate subject domain content from the API documentation tool and then process it with the rest of your content. For many API documentation tools this is actually possible because many of them offer an {XML} output which may be either {subject domain}(concept) or {document domain}(concept). Even if it is document domain, it may be regular enough that you can extract the subject domain structures reasonably easily. You can then skip the API doc tool's built in publishing chain and run its output through your regular {publishing} chain.
    

    
