chapter:(#chapter.content-management) Content Management

    <<<(annotations.sam)
    index:: type, term
        process, content management

    One of the most fundamental parts of managing a content process is managing the content assets. Any large collection of content needs to be managed, and when you are managing the work of many contributors to produce an integrated {information architecture}, management of the content assets becomes key.

    Managing content requires locating and examining content to make decisions about it. These are functions that can be performed by algorithms is there is sufficient accurate metadata attached to the content. Attaching metadata to content to allow algorithms to make decisions about it is, of course, precisely what we do in all forms of structured writing. So, content management is a structured writing process. In this section we will add a set of management algorithms to the basic content manipulation algorithms described in [#part.algorithms]. And like any other structured writing algorithm, management algorithms work differently depending on which domain your content is written in.

    But what if your content does not contain sufficient metadata to perform management tasks by algorithm -- or even by hand? In that case you can use a content management system to attach additional metadata to the content as an external label. Most commercial CMSs are designed to do just this. 

    Of course, you can also decide to manage your content by hand. This means that all those who have a role in the management of the content -- which will be everyone on your content team -- will have to have the knowledge and skills necessary to perform the management tasks, and will have to take the time to perform them. Since these conditions are hard to meet with perfect consistency, this does raise the prospect of content management complexity falling through the cracks and resulting, as unmanaged content complexity always does, in inferior rhetoric and inefficient process. But it does avoid introducing a lot of complex tools into your system. The introduction of tools is never neutral. New tools always bring new complexity and unless they provide or enable a better partitioning of complexity overall, they can end up causing more problems than they solve. 

    Some content management systems attempt to be all encompassing -- to be the only tool anyone in the organization ever uses to create and deliver content. Others are designed to work in concert with other tools. Some are more {frameworks} than tools, platforms on which you can construct your own content management functionality. All of them implement some form of structured writing for at least some of their functions, some in the {media domain}, some in the {document domain} with more or less of the {management domain} mixed in. Some work with, or at least support certain management functions for, the {subject domain}. Some content management systems attempt to manage the whole of the content creation process, from design and authoring to workflow and publishing. Others focus on more limited aspects of the process. Some are mostly or entirely focused on a single media platform (usually the Web) while others may support multiple media. 

    A content management system does exactly what I have been describing thought this book: it partitions and distributes the tasks of the content process. Each system does the partitioning differently, in large ways or in small. There is, of course, no guarantee that this partitioning is the one that is the best fit for your organization or that this partitioning is guaranteed to direct all complexity to people or processes that have the skills, knowledge, and resources to handle it. And if not, unhandled process complexity results in poor rhetorical quality.  

    As tempting as it may be to simply go shopping for a content management system, buying a CMS effectively means you are buying a complete process and partitioning, and that may not be the best fit for your organization. A far better approach is to design the partitioning of your system for yourself and then go shopping for the tools that will fit the process you have designed. Depending on how you have partitioned your process, and how and where complexity is directed in that process, you may not need a conventional content management system at all. 

    Many of the decisions you have to make in a large content system involve examining large volumes of content. Thus the main interface to many content management systems is a file system or database view of the content repository. Whatever specific tasks the system is performing, the essence of its interface is that it allows you to view and apply metadata to large volumes of content. However, if your content already contains the metadata needed to make these decisions, the need for such an interface diminishes (thought the need for the algorithms themselves remains).   

    Structured writing and content management systems both work to make {metadata} available to algorithms. But as we noted in [#part.algorithms], the algorithms work differently, and therefore require a different class of metadata, in each structured writing domain. CMSs tend to supply {subject domain} and {management domain} metadata for algorithms for use with document domain and media domain content. But subject domain content supplies the subject domain metadata itself, and, as we have seen, you can often factor out the need for management domain metadata by moving content to the subject domain. Just as a single set of subject domain structure can often serve the needs of multiple content manipulation algorithms so they can often serve the needs of multiple management algorithms as well.

    This does not mean that if your content is in the subject domain you will never need for a CSM, but it does mean that you may not need one, or that you may require a less elaborate system because there will be less you need it to do. Certainly it means that if you do need one, it should be one that is will adapted to the kind of partitioning that is involved in the use of the subject domain.

    Where the content does not contain the metadata necessary for management, the {CMS} has to gather and store it separately. This naturally adds complexity to the CMS interface, a complexity that is a major source of pain for many users. In the case of CMSs that are designed to be the only tool you use, this generally means that the structured writing format is baked in and can only be changed in limited ways, if at all. A transfer of metadata from the CMS to the structures of the content would involve a major reconfiguration of the entire CMS. If you buy this kind of system, therefore, you need to look at the total picture -- how it partitions and redistributes all of the complexity of the content systems, and what complexity, if any, it neglects and lets fall through. There will likely be little you can do to change the partitioning or distribution after the fact, so you better make sure it is what you want going in. 
    
    Most off-the-shelf {content management systems} are designed for {media domain} or basic {document domain} content. This makes sense from a commercial point of view because it allows them to develop their own {metadata} scheme and associated {management} algorithms independent of the content that will be stored. This means they can be sold to a wider variety of clients and also that they can advertise that they have simple editors or work with the editors that people already have. The problem with this model, in terms of developing a comprehensive solution for managing complexity across the content system, is that it draws a hard line between the {management} going on in the CMS and any type of {management} or constraint you may wish to impose on the rhetoric of your content. This means that algorithms that depend on the consistency of content or its relationships with other content are largely unsupported by the CMS, and there is no integration between those algorithms and the algorithms preformed by the CMS. The result is often that a lot of complexity gets dropped due to this lack of integration, with the usual consequences for rhetoric and for the reader.   
    
    Other CMSs are built for more complex {document domain} languages, which typically means that they are built to support the specific {management domain} features of those languages. By far the most common instances of such systems today are based on {DITA}. Typically, such systems are specific to the one language they support and are sold as such: a DITA CMS or an {S1000D} CMS.
    
    You might expect that the principal type of metadata contained in a CMS would be {management domain} metadata. After all, we described the management domain as an intrusion into the structured writing world, since it does not actually describe the structure of content. The reason for the intrusion of the {management domain} into content is to allow for the management of the content below the level of whatever file or chunk size you store in the CMS.[*XMLDatabase]
    
    footnote:(*XMLDatabase)
        In some CMSs, this distinction between the chunk stored in the {CMS} and the structures expressed inside that chunk is moot. A CMS based on a native {XML database}, for instance, makes no distinction between the chunk and the structure of the chunk, but treats the entire {repository} as a single XML resource that it can query and manage down to any level of granularity. Even with such a system, however, this distinction remains for the writer, who has to deal with the structure of whatever sized chunk of content they are being asked to write. 

    But while you will rarely find much in the way of {media domain} or {document domain} {metadata} stored at the {CMS} level, CMSs often contain a great deal of {subject domain} metadata. If you are managing a large volume of content, you will need some way to find content on a particular subject. If you are doing {content reuse}, for example, you will constantly be asking if content already exists on the subject you are preparing to write about. If your CMS is managing the delivery of content dynamically to the Web, it will need to respond to queries based on subject matter. And if you are optimizing your content for {search} you will need to provide the search engine with subject {metadata} in the form of keywords or {microformats}. All of this depends on {subject domain} {metadata}. Subject domain metadata is therefore central to CMS operations. This is also why the use of {subject domain} structures in your content can lessen your reliance on content management systems.
    
    To figure out what type of content management system you may need, if any, it is helpful to understand how content management systems work with metadata and where the metadata in question resides in your content. Essentially structured writing and content management systems both work to make metadata available to algorithms, so structured writing and content management systems are both working towards the same goal, and depending on your process you may want to assign more of that task to one or to the other.  

    section: The location of metadata
    
        {Content management system} do their job largely through the collection and management of {metadata}. Partitioning and redirecting complexity requires a method to pass information between partitions in a reliable way, and that is what structure and metadata do. Metadata provides a record of the identity and status of content. Management actions are actions on metadata: either creating and updating metadata or performing actions (running algorithms) based on metadata. 
              
        The location of the {metadata} that records the identity and status of the content and the constraints it obeys, differs from one structured writing domain to another. The {media domain} captures virtually no {metadata} that is useful for {content management}, the {document domain} captures some, but not enough, and the {subject domain} often captures almost everything your may need, except perhaps for {workflow} information. (Though workflow information is {management domain} data and there is nothing to prevent you from adding those structures to your {document domain} or {subject domain} content itself if you want to.) 
                
        
        It is a very common pattern for a {CMS} to store {document domain} or {media domain} content and attach {subject-domain} metadata to it as an external label. For instance, a CMS might store recipes written in {MarkDown} and attach separate {metadata} records to each recipe listing the key recipe metadata needed for retrieval and sorting of recipes. One of the things that writers often complain about with CMS systems is that they are not allowed to submit content to the system without filling out complicated metadata records. 
        
        An alternative approach would be to write recipes in a {subject domain} format in which all the recipe {metadata} is included in the content from the beginning. The {CMS} then requires no external metadata label, though it does obviously require a way to access and query the metadata embedded in the content. (CMSs based on {XML databases} often have this capability as a natural consequence of the XML database architecture.)
        
        Which approach is preferable? The conventional CMS approach arises because most CMS's are based on relational databases, which are good at storing metadata records and attaching them to blobs of text, but are not good at storing or querying the {hierarchical structure} of structured content. It has several disadvantages, all of which introduce complexity which is often not well handled.
        
        1. It can only record the characteristics of a chunk of content as a whole. It cannot look down into the content to find more fine grained {metadata}. One of the advantages of writing a recipe is the {subject domain} is that it allows you to do things like querying the collection of recipes for all those with a calorie count below 100. But unless the metadata record for the recipe includes that level of detail, the {CMS} cannot respond to that {query}. And if the CMS does store that level of detail, it is effectively asking the writer to write the entire content twice, once in the {document domain} document and once in the {subject domain} metadata label. Not only is this more work, it is quite likely that the two versions will fall out of sync with each other. 

        2. It gives no support for {subject-domain} {validation} of the content. It does nothing to help improve content quality. By requiring {document-domain} content as the storage format, it precludes the use of the {subject domain} for writing and cuts you off from all the advantages it provides. 
        
        3. The system has no way of telling if the content {conforms} to its constraints. It records the content constraints in a separate record without ever validating that the content meets them. 
        
        4. It separates the {metadata} from the content is describes. This allows for drift between the content and the metadata. 
                
        But storing {metadata} in the content presents some challenges as well. Having each piece of content stored in the {subject domain} makes a lot of sense from a rhetorical point of view and makes it easy to submit content, since no additional metadata forms have to be filled out. The problem is how to retrieve it. A CMS is essentially a database, and the way you retrieve information from a database is to write a {query}. A query is different from a {search}. A search is fuzzy. A {search engine} takes a plain text question or search phrase and tries to figure out which documents are the best match. Search engines may be powerful and sophisticated, but their results are essentially a sophisticated mechanical guess, and sometimes they get it wrong. Ask a search engine for a list of recipes with less than 100 calories, and it will give you a bunch of guesses based mostly on the plain text of those documents. Chances are it will catch some, miss others, and give you some false hits. 
        
        >>>(image ../graphics/search.xml)
        
        A {query}, on the other hand, is a precise request for items whose {metadata} precisely matches specified criteria. If you write a query to return recipes for which the value of the field `recipe/nutrition/calories` is less than 100, it will return all the results, miss none, and give you no false hits. However, it will work only for content that is stored that way. To write that query, you will need to know exactly how recipes are stored in the system. 
        
        >>>(image ../graphics/query.xml)
        
        If you have many different content structures in your repository, you will need to know how each of them is structured in order to create the {queries} to return them. This is not the end of the world. {Information architects} and {content engineers} can save writers from having to remember how to do all of the queries by creating saved queries that they can run at any time. But is is still a complicating factor. 
                
        In the end there is no way around this. Accurate reliable {queries} depend on precise consistent {metadata}. Precise consistent metadata is specific to the object it belongs to. There is no such thing as a generic metadata record. They are always specific to the things they describe. Subject domain metadata is specific to its subject. If you want to be able to find all recipes with calorie counts less than 100, you need recipe-specific metadata that specifically records the number of calories in the recipe. If you want to find a used car listing for a blue convertible, you need metadata that specifically records the car color and body style. There is no generic metadata format that supports both these queries. The inherent variability of content means no generic query system is possible. The trick is to find the right balance and to make your content as queryable as possible. 

    section: Hybrid approaches

        There is an alternative to the two approaches described above, which we might call a hybrid of document and database. We have noted that in the {subject domain} you often created what is essentially fielded data from which content is then derived by algorithm. The relational database on which most CMSs are based is great at managing fielded data, and this allows you to create a hybrid system in which the fielded data parts of a subject domain document type are created directly as database fields and any more narrative content is stored in text fields in some basic document domain markup such as markdown or HTML. These types of hybrid systems are common in custom Web CMS solutions (where they are not looked on as hybrids so much as logical extensions of the database model). 

        The advantage of this model is that the writer is no longer adding metadata after the fact, since it is part of their normal authoring environment (which is now essentially a database form). This is a perfectly legitimate implementation of subject domain structured writing (there is noting to say that the structures have to be expressed and captured as markup). Nonetheless, many {content strategists} have come to realize the limitations of this model, which is the lack of any kind of constraint on the content of the narrative fields which make it hard to create the consistent rhetoric that {content strategy} tries to foster. 

    section: Alternate repositories

        At the heart of any content management solution is a repository, a place to put the content assets you are managing. The simplest form or repository is a file system, either local or shared on a network. The amount of metadata you can associate with content on a file system is very limited. Some people will use a separate metadata store such as a spreadsheet, but there are obvious limits to how far such a system can scale and it is very difficult to apply algorithms to content management in a setup like this. 

        Virtually every full fledged CMS you can buy comes with and is built around a repository, and that repository is set up to capture the metadata use for content management. The fact that the repository is baked into the CMS has obvious integration benefits for the CMS itself, but be aware that this means that access to your content by any algorithm not provided by the CMS itself comes only by permission of the CMS, and many CSM are not designed to make access to their content easy for outside processes (in part because the makers want to present their system as providing everything you need, but also in part to preserve the integrity of their metadata store).

        If you don't need the services of a full-fledged CMS, or you simply can't find one that supports the partitioning you want for your content system, there are still some content management features that you may want for your content repository: version control and the ability to control the access of different authors to shared resources. Both of these services can be provided by the {version control system}s used by software developers. 

        A version control system is a tool that allows content to be maintained in an ordinary file system, which has the great benefit that tools and algorithms do not have to know anything about the VCS in order to work on the content. However, the VCS stores all changes that are made to files under its control, storing each iteration along with labels and commentary that allow you to find any version you might want to go back to. 

        VCSs also allow the backing up of the content, along with all of its version metadata to a central server which can be accessed by many different contributors. Each contributor maintains a local copy of the files on their workstation, and any changes they make can then be pulled down the the workstations of other contributors, so that everyone has a version of the latest content. 

        VCSs have various mechanisms for preventing people from accidentally overwriting each other's work, including the ability to create a branch of the the repository where you can make changes independent of other contributors and merge them into the mainline of the repository when they are ready for release. 

        A VCS has nothing like the complex facilities of a typical CMS, but they are used successfully for very large software projects involving hundreds of developers. How it possible to have collaboration on this scale with such simple repository features? The key is that code is by its nature highly structured text to which all of the same algorithms I have described for structured writing can be applied. The code can be strongly partitioned to minimize the collaborative overhead and a rich set of tools is available to ensure {conformance} and to perform {audits} to make sure that code is complete and conforms to its constraints. In short, software projects do not need the kind of services provided by a typical CMS on the content side because the code itself contains the metadata necessary to perform these same functions with external algorithms and the right kind of discipline among contributors. The open nature of the VCS is ideal for this because it does not impose any barriers to implementing new processes or new algorithms to manage the content. 
 
        There is a movement within the documentation community called Docs as Code[http://www.writethedocs.org/guide/docs-as-code/] which advocates for using the same management processes and tools for content as developers use for code, including the use of version control systems and scripted content builds, rather than conventional CMS solutions.  

    section: Making content manageable
    
        If you want to manage your content, it is important to make your content easy to manage. The danger here is that if you start out with the principal aim of making your content manageable, you may find your {management} goals at odds with your {rhetorical} goals. It is easier to manage content (or anything else) if it is more uniform. The constraints that you will naturally wish to impose to make content more manageable are those that make it more uniform. Thus a system like {DITA} which, as a starting point, proposes that there are just three types of content (concept, task, and reference) has an obvious appeal from a management point of view. Remember though, that it is the accomplishment of your {rhetorical} goals that serves your readers. Your management goals should logically be subservient to your rhetorical goals. 
       
        The constraints that you impose to improve content quality are those which make sure that a piece of content does just the job it is supposed to to. They are the kind of constraints that make sure that a recipe contains everything a recipe needs and is presented in the way a recipe should be presented. They are highly specific to the subject matter and to the audience. Three generic content types are not going to provide all the constraints we need to effectively manage content {quality}. Indeed, some of the constraints that are designed to facilitate content management may be positively damaging to content quality.
           
        But while uniformity might be the approach you would naturally choose if you merely set out to implement a content management system -- if improved content {quality} were not one of your business goals -- I would argue that managing {subject domain} content may actually lead to better content management in the long run.
        
        In any system that relies on constraints, on data that is known to meet certain constraints, it is necessary to make sure that the constraints are actually being met. As we have seen it is often much easier to provide effective {guidance} and perform effective {validation} in the {subject domain}. Also, the subject domain allows you to factor out many constraints, which is the most effective way of making sure they are obeyed. The {document domain} provides far fewer opportunities for factoring out constraints and providing effective guidance and is much more difficult to {audit} correctly.
        
        Thus while a simple {document domain} system of concept, task, and reference {topics} meets the content manager's desire for uniformity, it provides little opportunity for ensuring that the full range of constraints necessary to make content management and reuse work are actually followed. The result can be deterioration of the quality of the content set over time, a process that tends to be self perpetuating, as disorder in current content makes it harder to impose order on new content. (Just as you cannot put things away neatly in a messy drawer.)
        
        The variety of constraints and formats found in a {subject-domain} system may present a greater {content management} challenge initially, but it can go a very long way to ensuring that the necessary constraints are met. And, as we have seen, you can often use {subject domain} structures to factor out {management domain} concerns (see [#chapter.management-domain]), which can go along way to removing the conflict between {rhetorical} structures and {management} structures in content. This not only leads to more effective management, but also to a simpler writing experience.  

        We saw that the key to {conformance} was to create structures that are easy to conform to. The {content management algorithm} relies heavily on the conformance to constraints and to structures. Successful management of content depends on knowing exactly what assets you are managing. The more you know about each asset, and the more reliable what you know about that asset is, the more confidently you can manage it, and the less likely the management system is to slowly descend into chaos. 

        This means that the content management algorithm depends on content that is easy to manage. It may seem like simple generic units of content would be the easiest to manage, but the problem with such generic units is that you know very little about them and what you do know is often unreliable. Generic units may be easy to create and easy to store, but they are not easy to manage. It may require more initial though and effort to plan for the management of highly specific well constrained content units, but such units will in fact prove to be the easiest to manage over time, especially as your content set grows.         
 
     section: Managing structured writing assets     
        
        Finally, we should note that doing structured writing requires recording content in {media domain}, {document domain} or {subject domain} structures, factoring out invariants into separate files, expressing constraints, and creating algorithms to translate the content to the {media domain} for {publishing}. All of this creates a lot of artifacts to keep track of, and requires a process both for keeping track of them and for running the structured authoring and publishing {tool chain}. 

        Thus there is a need to manage both the artifacts and the process. Don't fall into the trap of assuming that this is a generic processes. All these artifacts that require managing are the result of partitioning your content system, and how they should be managed is determined by how the partitions communicate with each other. This is specific to the overall partitioning strategy of your particular content system. You need to find a tool that fits that partitioning strategy.

        One class of tool commonly used for document/management domain structured writing systems, particularly {DITA}, is a specialized type of content management system called a {component content management system} or {CCMS}. A CCMS is specifically designed for managing small fragments of content rather than whole documents, and {content reuse} is their primary design objective. Most DITA tools are build around a CCMS.

        If your content is in the {subject domain}, however, you may not need all the services of a CCMS and may be able to do just fine with a relatively simple {version control system}. 

