chapter:(#chapter.partitioning) Partitioning Complexity

    <<<(annotations.sam)

    index:: type, term
        concept, partitioning

    !!!(MB)
        This chapter is about partitioning. Removing the original first para made it start talking about complexity and only brought partitioning in paragraph 5, where it seemed disconnected. I have added and opening sentence and closing sentence to establish the theme of partitioning and tie it to complexity. 

    To understand how to successfully partition the complexity of a content system, we must begin by asking what complexity is. The complexity of a task in the content process (or any other process) can be measured by the number of decisions people have to make and execute. Every decision requires knowledge (to make the correct choice) and skill (to execute that choice). The more decisions a task involves, the more knowledge and skill it requires, and the more knowledge and skill a task requires, the more complex it is. We can reduce the complexity of tasks by partitioning the complexity to minimize the knowledge and skills required for each task. 

    We can divide the decisions involved in a task into two kinds:

    * *Core:* decisions that are fundamental to the task. These decisions are central to the task and cannot be removed by changing your processes. 

    * *Extended:* decisions that are introduced into the task by your processes or tools. Theoretically, at least, these decisions can be removed from the task by changing your processes or tools.

    The more extended decisions you can remove from a task, the simpler you make that task. The purpose of partitioning the content system is to remove these decisions from key tasks, making them less complex and, therefore, improving productivity and quality. 

    Of course, those decisions don't just vanish into thin air. They still must be made and acted on somewhere in the system. Complexity cannot be destroyed, but it can be moved around to ensure that every decision is made by the person or process with the information, skill, and resources to make and execute it best. 

    Simplifying the tasks of individual people and processes is not the only reason to change where decisions get made. Making decisions earlier or later in the content process can also have profound effects on the efficiency of your process and the kinds of output it can produce. For instance, partitioning decisions about document formatting away from the writer means that those decisions are not recorded in the content itself. If you later need to change how your content is formatted, you can change the formatting algorithm, without touching the content. The possibilities in this area go well beyond formatting, as we will see in later chapters. 

    All modern content systems are partitioned, but not all are partitioned in a way that fully handles the complexity of the content development and delivery process. As a result, many organizations produce content of poor or variable quality and lose money. Why are so many content systems poorly partitioned? We can find some answers by looking at the evolution of content development.

    section: Desktop publishing

        One of the biggest changes in the partitioning of the content system was ushered in by the {desktop publishing}(concept) (DTP) revolution of the 1980s. Prior to the introduction of desktop publishing, creating a formatted printed document generally meant handing off a manuscript from an author to a typesetter for re-keying, followed by mechanical pasteup by a page-layout artist, preparation of proofs by a printer, correction of proofs, and printing.

        This was in many ways a well partitioned process. Professionals in each trade had a piece of the decision making and the tools to implement those decisions. However, the overhead of passing information from one trade to the next was cumbersome resulting in a process that was time consuming and expensive with many potential points of failure.   

        {Desktop publishing} eliminated much of that overhead by putting all of these functions -- writing, design, layout, and proofing -- in the hands of a single operator: the writer. This greatly sped up the publishing process and generally reduced costs by eliminating most of the trades traditionally involved in the process. 

        However, this radical change in partitioning introduced three problems:

        First, it put a huge amount of complexity on the writer. In a desktop publishing environment, writers must make many more decisions, which require knowledge and skills in addition to those required to research and write content. The demand for writers who can handle this complexity changed hiring practices. Desktop publishing skill became a major hiring criteria for writers and remains so today. The focus in hiring moved from writing skills and knowledge of subject matter to the ability to manage the publishing process.

        Second, because writers did layout and design while writing, their attention was divided between these tasks. Attention is a finite resource; when writers pay attention to layout and design rather than writing, the quality of the writing suffers. And since the layout and design are only getting partial attention, their quality suffers as well.

        Third, although desktop publishing removed the need for a lot of vertical communication between writers, designers, and typesetters, it made no provision for horizontal communication between writers, leaving every writer on an island. Every book was a separate project. The division of the writer's attention and the lack of horizontal coordination left huge amounts of complexity unhandled in large content systems. {Duplication}, {omissions}, and {inconsistencies} became difficult to detect and fix, and providing effective {navigation} between books were virtually impossible. All of this unhandled complexity was dumped on the reader in the form of poor quality content. Desktop publishing did not create this problem, but it did nothing to fix it.   

    section: Style sheets    

        One of the most visible early signs of unhandled complexity creating quality problems came in the form of the dreaded "desktop publishing look" -- an explosion of poorly designed and poorly laid out documents, characterized by bizarre font combinations, poor use of whitespace, poorly designed and placed graphics, and a seemingly random profusion of lines, shades, colors, and other decorative elements. 

        To help contain this, desktop publishing systems introduced {style sheets}(concept), which partially partition content from formatting. Style sheets allow a writer to format text using pre-defined, named styles. Each style encapsulates a set of decisions about content formatting that have been made by a style sheet designer. Style sheets allow you to partition decisions about what the text looks like from decisions about what the text says. 

        Style sheets do not completely partition formatting decisions from writers, however. Writers still must pass information to the partition that makes formatting decisions, which means writers must decide which styles to apply (knowledge) and know how to apply them (skill). Although this is less complex and requires less design skill than formatting by hand, experience shows that many writers do not use styles correctly or even at all.   

        Although style sheets remove some formatting decisions, the WYSIWYG (What You See is What You Get) display used by desktop publishing systems has another flaw. A key aspect of any interface between partitions is the feedback it gives users to let them know if they have done their work correctly. A WYSIWYG display tells you only one thing: does it look right? It does not tell you whether you have used styles correctly or at all. And what looks right to you may not look right to the next person.

        Another problem is that style sheets partition the design of individual elements of a document, such as a title or a list, but not the overall design of the document. Document design remains on the writer's side of the partition. The style sheet restricts the formatting pallet, but it does not tell writers how to use that pallet to achieve an effective overall document design. Since writers are not document designers by trade, they may not always do this well, and multiple writers working on a common projects will almost certainly do it inconsistently.
                      
        Many organization use {style guide}s to tell writers how to use the style pallet to design documents. But the style guide only provides instructions, it does not partition the task away from the writer. The style guide merely adds another knowledge requirement, adding complexity.

        Styles, therefore, provide only limited relief to the complexity dumped on the author, and they are only moderately successful in promoting consistent document appearance.

    section: Content management systems

        Meanwhile, the Web brings a new set of challenges. A modern website is not a library of independent volumes; it's a complex {hypertext} consisting of many smaller pieces of content related in much more complex ways than paper documents ever were. {Search engines} and {social networks} have profoundly changed how readers seek and use content. Meeting those needs requires a level of coordination between writers -- and between the pieces of content they create -- that {desktop publishing} cannot provide. 

        To help manage these challenges, most organizations are adopting {content management systems} (CMS). This has led to new forms of partitioning and new roles, such as {webmaster}, {information architect}, and, more recently, {content strategist}.

        Some of this new partitioning is useful, but sometimes content management systems can make things worse. For instance, some content management systems give control of the page header and sidebar to an {information architect} but let writers design the document part of the page pretty much as they did with a {desktop publishing system}. Unfortunately, this approach just wraps a frame around all of the shortcomings of desktop publishing, highlighting those shortcomings by closely juxtaposing the work of different writers. 

        Increasingly, therefore, content management systems have begun to incorporate more structured techniques and rely on a technology that actually predates desktop publishing: markup languages.  

    section: Markup languages
        
        A {markup language} is a system for indicating the structure of a text via marks in the text itself. Markup languages were used for publishing on mainframe computers long before desktop computers had the processing power required for desktop publishing. A markup language -- {HTML} -- gave birth to the Web by enabling writers to include in a document the information needed to format and display that document in a Web browser. In other words, HTML markup is an interface between writers and web browsers.

        {HTML} is probably the single most widely used markup language in the world today, but there are thousands of others, and people create new markup languages for specific purposes all the time. Each markup language represents a specific interface between partitions in a content system.  

        Markup languages are by far the most general type of content interface, and they can be used to implement nearly any kind of partitioning you might need. In fact, markup languages are usually found behind the scenes in WYSIWYG and forms-based interfaces. However, markup languages can also stand alone as interfaces in their own right. {Markdown}, for instance, has become a popular markup language for writing simple Web content. 

        There can be (and usually are), multiple partitions in a content system. The interfaces between those partitions are frequently markup languages, including interfaces that writers never use themselves. For instance, an organization may use {Markdown} to author some of their content but then convert {Markdown} to {HTML} for publishing and use a {CSS} style sheet (another markup language) to specify the formatting for that content.

        Today the term "structured writing" is often taken as a synonym for the use of markup languages. This is not really fair, since, as we will see, any use of computers for writing and publishing necessarily involves structured writing techniques. The reason we associate markup languages so strongly with structured writing, however, is that markup languages allow organizations to create their own structures and, thus, change the way their content systems are partitioned. Any serious attempt to better manage the complexity of the content system by changing how the system is partitions is likely to involve the use of markup languages, usually several markup languages in different roles.  

        Most of the discussion in this book focuses on the use of markup languages, because markup languages provide the greatest range of possibilities for effectively partitioning the content system. You may be able to hide some of the markup techniques discussed here behind WYSIWYG or forms-based interfaces. However, in this book I use markup to illustrate them all, because markup provides the clearest view of the structure and interfaces that define partitions. 


    section: Algorithms

        To take content created using a markup language and turn it into a formatted document requires an algorithm. Algorithms are also used to manage the content process. An algorithm is simply a regular codified repeatable method for doing a task. 

        Most complex tasks have repeatable elements in them. A design question that has been settled once can be implemented over and over again without having to redo the design work. If one piece of content is formatted a certain way, chances are many similar pieces can be formatted the same way. Algorithms are great at doing the same task the same way over and over, so partitioning such tasks away from authors and directing them to algorithms is a great way to reduce the complexity of the author's task.  

        And while algorithms are repetitive by nature, they can also incorporate considerable knowledge, make sophisticated decisions, and execute complicated processes, which makes them capable of meeting both the knowledge and skill requirements to make useful decisions. Thus we can use algorithms to execute many of the extended decisions in a content process, leaving writers and designers free to focus on the core decisions. 

        A computer program is an encoding of an algorithm that a computer can execute. A program describes an algorithm to a computer, but you do not need to be a programmer to design an algorithm. The real trick is to discern which parts of a process can be defined as algorithms. That is why an understanding of the main structured writing algorithms is vital to effectively partitioning your content system.  

        Algorithms are fundamental to structured writing. Algorithms and structures work together, and you can't design one without the other. The heart of this book describes the principal structured writing algorithms and the structures that support them. The structures support the algorithms by constraining the content. 

    section: Partitioning and Roles 
        
        Partitioning a content system often means changing the roles that people play in the organization. The introduction of {desktop publishing}, for instance, merged the role of writer and {typesetter}, and, to a certain extent the roles of {document designer} and {pre-press operator} as well. The introduction of structured writing techniques will likely mean the introduction of new roles and/or the modification of existing ones within your organization. 

        Writing an algorithm redistributes complexity away from the person who used to do the task, but it directs that complexity to the person who writes and maintains the algorithm. For example, using a {CSS} style sheet to format lists redistributes the task of designing list formatting from writers, whose job is to know what they are talking about and how to say it, to a {publications designer}, whose job it is to know how to attractively format lists and how to code good {CSS}.  
        
        Using {CSS} partitions the complexity of formatting a page, distributing that complexity away from the writer. Now, the writer does not have to know about formatting or design, and the designer does not have to know about writing or the subject matter. This allows writers to focus on writing and designers to focus on design. The result is better writing and better, more consistent, design.  

        As we discuss the major structured writing algorithms in [#part.algorithms] we will see how these algorithms partitions tasks differently between writers and roles such as {information architect}s, {content engineer}s, and {content strategist}s. 

    section: Quality and value

        Many structured writing systems focus only on the separation of content from formatting and on content management functions. Separating content from formatting can help improve content quality by freeing more of the writer's time and attention to focus on writing. However, there is much more you can do to improve the quality of content by placing explicit constraints on the rhetorical structures that writers create. 

        Organizations are becoming more aware of the impact that {rhetorical quality} has on their business. The {Web} has made it easier for users to access our information, but it has also made it easier for them to detect content that is inconsistent in tone and style, outdated, redundant, incomplete, or just plain useless. The Web did not create these flaws, but it made them painfully apparent. It has also given organization a much more direct way to see and to measure the impact of the their content and of its flaws. Organizations can no longer ignore that their existing content often has major rhetorical faults. This has led to the emergence of the discipline of {content strategy} as organizations feel the impact of poor content quality and see content quality as a strategic value.

        In the age of physical typesetting, we had no automated tools to help with the rhetorical quality of content, and the desktop publishing revolution was mostly concerned with digitizing the previously mechanical design and layout process. The limitations of the available tools forced organizations to partition their processes in ways that did not always properly handle the full complexity of content creation. The result was poor-quality content.

        Modern structured writing tools allow us to partition the content system in ways that significantly enhance the {rhetorical quality} of content. This includes methods that free writers to focus on quality, to create consistent content, to validate and audit content quality, and to create content structures and products that would not be possible with other methods. 

        The idea that you can build quality into a process by managing the complexity of the design and production process, though well accepted in other fields, has not been widely considered in the content field. To a large extent, where we have sought process improvements, they have been in the areas of publishing and content management, not in the area of content quality. Where structured writing tools have replaced desktop publishing or word processing tools, it has largely been in pursuit of process goals. But a more holistic view would show that process and quality are intimately related, and that treating them holistically can significantly improve both.

        Unfortunately, many current content systems not only fail to provide active rhetorical support to writers, they also fail to remove distractions and complexity from the writer's workspace. This ends up making the writer's life more complex rather than less. If the writer ends up with more complexity than they can comfortable handle, the result is dropped complexity, which means diminished content quality. Sometimes that unhandled complexity also derails the attempts to make the process more efficient because the information coming through the complex interface is not reliable enough for the new process to work correctly.

        The sad truth is that many content systems have never seriously attempted to minimize the amount of complexity they dump on the writer. Writing and publishing have largely been treated as separate concerns, as if the publishing process and its demands had no influence, for good or bad, on the quality of content that the system  produced. The result has been widespread dissatisfaction with content tools and systems, and with their results. Lack of attention to where complexity falls in a system also typically results in breakdown and failure of the system over time, particularly as new features are added to address specific needs without adequate thought given to the impact of complexity they introduce, a process content strategist Joe Gollner calls the "barnacalization of systems". 

    section: Towards a more effective partitioning of the content system
        
        The impact of poor quality content goes straight to the bottom line. To address it, we need a new partitioning of the content creation process. This book does not prescribe a single new vision of content partitioning for all organizations. The attempt to create a single system to meet all needs has been a large factor in the poor partitioning of many content systems. Each organization has different needs and different audiences. They face different sources and degrees of complexity, and they need to partition their content system accordingly. Therefore, rather than prescribe any one partitioning, this book explores structured writing strategies you can use to partition your content system and suggests how you can determine which approach will work best for your organization. 

        
