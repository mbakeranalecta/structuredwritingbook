chapter:(#chapter.partitioning) Partitioning Complexity with Structured Writing

    <<<(annotations.sam)

    index:: type, term
        concept, partitioning

    Partitioning a process requires creating an interface between the partitions. The job of the interface is to transfer information from one partition to another. In some cases, when you transfer information into a partition, it transfers other information back. When you hit a key on a computer keyboard, the application responds by showing you a corresponding letter shape on screen. The application has take over the complexity for forming letter shapes, but it shows you the letter shape that has been created as feedback. This help you ensure that the information you have given is correct.  

    Partitioning complexity at different points in the process requires transferring different types of information between processes, which means you need different interfaces. This also means you get different kinds of feedback from those interfaces. 

    However, it is easy to become accustomed to certain kinds of interfaces and certain kinds of feedback. We may be reluctant to move away from familiar styles of interface even when we are seeking a new partitioning that may require very different kinds of information transfer. 


    Each of these things are complex tasks in themselves and they become all the more complex when you have to coordinate them all. Not everyone has the skills or the knowledge to do all these things well, and if too much of the complexity falls on one person's shoulders, it will limit their ability to perform well or deliver on time. In particular, writing well is an activity that requires the whole of the writer's attention. Any part of the complexity of the content creation process that divides the writer's attention makes it more difficult for them to write quality content. 


    The fundamentals of these techniques are not new. In fact, they all exist in the desktop publishing paradigm. When we define a stylesheet in {FrameMaker}. When we use CSS to separate formatting from our HTML content, we are using structured writing techniques. What we call structured writing today is simply about taking those techniques one or two steps further to allow us to better partition and distribute all of the complexity of content creation in or organizations.


    Every partitioning requires the creation of an interface that passes information from one partition to another. Sometimes the interface to a new partition can turn out to be more complicated that the interface to the old partition. This ends up making the writer's life more complex rather than less. If the writer ends up with more complexity than they can comfortable handle, the result is dropped complexity, which means diminished content quality. Sometimes that unhandled complexity also derails the attempts to make the process more efficient because the information coming through the complex interface is not reliable enough for the new process to work correctly.


    Most content systems have never  seriously attempted to minimize the amount of complexity they dump on the reader. Quality and process have largely been treated as separate concerns, as if the process and its demands had no influence, for good or bad, on the quality of content that writers produced. 
    
    The idea that you can build quality into a process by managing the complexity of the design and production process, though well accepted in other fields, has not been widely considered in content. To a large extent, where we have sought process improvements, they have been in the areas of publishing and content management, not in content itself. Where structured writing tools have replaced desktop publishing or word processing tools it has largely been for process goals. But a more holistic view would show that process and quality are intimately related, and the treating them holistically can significantly improve both.



    To distribute complexity, you must partition it along clean lines without dropping any of the complexity in the process. For example, the style sheets in a word processor partition the complexity of consistently formatting a document by allowing writers to apply named styles to paragraphs. This partitions the task of designing the look of a document, and defining styles to implement that design, and directs it to the stylesheet designer. The writer is left with the nominally easier job of assigning named styles to paragraphs as they write. (I say nominally because, as we know, styles are rarely used correctly, or at all. Mere technical partitioning often fails because it does not fully encapsulate the complexity it is attempting to partition.) 
    
    Partitioning and redistributing complexity is not just about shifting complexity from one person to another. It is also about shifting complexity from people to algorithms. Most complex tasks have repeatable elements in them. A design question that has been settled once can be implemented over and over again without having to redo the design work. If one piece of content is formatted a certain way, chances are many similar pieces can be formatted the same way. Algorithms are great at doing the same task the same way over and over.  
    
    Writing an algorithm to do a repetitive task redistributes complexity from the person who used to do the task to the algorithm, but also to the person who writes and maintains the algorithm. For example, using a CSS stylesheet to format lists redistributes the task of designing list formatting from the writers, whose job is to know what they are talking about and how to say it, to a publications designer, whose job it is to know how to attractively format lists and how to code good CSS. 
    
    Using CSS partitions the complexity of formatting a page so that we can distribute the complexity of formatting away from the writer.  Now the writer does not have to know about formatting or design, and the designer does not have to know about writing or the subject matter. This simplifies the writer's life, allowing them to focus on writing. It also simplifies the designers life, allowing them to concentrate on design. The result is better writing and better, more consistent, design.  
    
    CSS does an effective job of partitioning the complexity of formatting, but CSS is itself complex. Introducing CSS in to our process means introducing new complexity. All tools introduce new complexity into the processes they serve. People have to design the tools and build the tool and learn to use the tool, and maintain the tool. All this is new complexity that did not exist before. We accept this new complexity into our processes because a good tool allows us to distribute our existing complexity more efficiently, so that less of the complexity falls on the people and more on the tools, and so that each person in the system only has to deal with the complexity that they are able to cope with. Managing where the complexity falls is ultimately much more effective than merely minimizing total complexity. 
    
    Adding complexity to the system in order to distribute complexity better is pervasive today. The complexity of the technology stack that lets you send an email or a text message is staggering, but its directs the complexity of communicating over distance away from the users towards systems and the people who maintain them for a huge net gain in productivity. 
    
    The content creation stack is similarly complex. Yet the content creation stack does not do such a good job of partitioning and distributing all of the complexity of content creation, with the result that complexity is pervasively being dumped on the reader in the form of poor quality content. 
    
    There is some very elaborate partitioning and distribution going on in the content creation stack, in the form of complex content management and publishing systems, as well as new roles for human contributors, such as information architects and content strategists. However, most of the content creation going on in the content stack today is taking place using WYSIWYG authoring interfaces from the desktop publishing era. 

    In its time, desktop publishing represented an interesting repartitioning and redistribution of the complexity of content creation. At the time, creating a formatted printed document generally meant handing off a manuscript from an author to a typesetter for re-keying, followed by mechanical pasteup by a page-layout artist, the preparation of proofs by a printer, correction of proofs, and the final printing. This was a complex and time consuming process that cost a lot of money and had many points where failure could occur or error be introduced. The various function were well partitioned from each other, but the overhead of passing information from one to another was cumbersome and time consuming. 

    Desktop publishing eliminated much of that overhead by putting all the tools of document creation -- writing, design, layout, proofing -- in the hands of a single operator. The problem with this model are twofold. First, it put too much of the complexity on one person: the writer. The writer's attention is divided between multiple tasks, and since attention is a finite resource, this meant the quality of writing, design, layout, and proofing all suffered. The fact that desktop publishing skill became a major hiring criteria for writers (and remains so today) shows how the focus was taken off writing and knowledge of subject matter and placed on the ability to manage the complexity of the publishing process.   

    Secondly, while it removed a lot of complexity of vertical communication between writer, designer, and typesetter, desktop publishing left every writer on an island, making no provision for any kind of horizontal coordination between writers. Everyone worked on their own book as a separate project. The division of the writer's attention and the lack of horizontal coordination meant the huge amounts of complexity were going unhandled in large content systems. Duplication omissions, and inconsistencies were very difficult to detect and fix, while providing effective navigation between books was virtually impossible. All this unhandled complexity was dumped on the reader in the form of poor quality content. Desktop publishing did no create this problem, but it did nothing to fix it.   

    Content management system have tried very hard to partition and redirect the complexity of that horizontal coordination, but with results are are, at best, incomplete. Meanwhile, the advent of the Web had brought a new set of challenges. A modern website is not a library of independent volumes but a complex hypertext consisting of many smaller pieces of content related in much more complex ways than paper documents ever were. Search engines and social networks have profoundly changed how readers seek and use content. Meanwhile, many organizations are trying to deliver content to both the paper model and the Web model simultaneously. Content creation and delivery has got a lot more complex and reader's expectations far more demanding. The desktop publishing model is fundamentally unsuited to handling this complexity. 