!smart-quotes: on
chapter:(#chapter.partitioning) Partitioning Complexity

    <<<(annotations.sam)

    subjects:: type, term
        concept, structured writing
        concept, complexity
        concept, partitioning
        
    Understanding how to successfully partition the complexity of a content system starts with asking what {complexity}+(index "complexity;decisions and") is. The complexity of a task in the content process (or any other process) can be measured by the number of {decisions}+(index "decisions;complexity and") people have to make and execute. Every decision requires knowledge (to make the correct choice) and skill (to execute that choice). The more decisions a task involves, the more knowledge and skill it requires, and the more knowledge and skill a task requires, the more complex it is. You can reduce the complexity of a task by partitioning it into separate less complex tasks that each require less knowledge or fewer skills than the original task. 

    It is helpful to divide the decisions involved in a task into two kinds:

    |Core| {decisions}+(index "decisions;core")+(index "core decisions") that are fundamental to the task. These decisions are central to the task and cannot be removed by changing your processes. 

    |Extended| {decisions}+(index "decisions;extended")+(index "extended decisions") that are introduced into the task by your processes or tools. Theoretically, at least, these decisions can be removed from the task by changing your processes or tools.

    The more extended decisions you remove from a task, the simpler you make that task. The purpose of partitioning the content system is to remove these decisions from key tasks, making them less complex and, therefore, improving productivity and quality. 

    Of course, those decisions don't just vanish into thin air. They still must be made and acted on somewhere in the system. Complexity cannot be destroyed, but it can be moved around to ensure that every decision is made by the person or process with the information, skill, and resources to make and execute it best. 

    Simplifying the tasks of individual people and processes is not the only reason to change where decisions get made. Making decisions earlier or later in the content process can also have profound effects on the efficiency of your process and the kinds of rhetoric it can produce. For instance, partitioning decisions about document formatting away from the writer means that those decisions are not recorded in the content itself. If you later need to change how your content is formatted, you can change the formatting algorithm, without touching the content. The possibilities in this area go well beyond formatting, as we will see in later chapters. 

    All modern content systems are partitioned, but not all are partitioned in a way that fully handles the complexity of the content development and delivery process. As a result, many organizations produce content of poor or variable quality, and lose money. Why are so many content systems poorly partitioned? Some answers can be found by looking at the evolution of content development.

    section: Desktop publishing

        One of the biggest changes in the partitioning of the content system was ushered in by the {desktop publishing} (DTP) revolution of the 1980s. Prior to the introduction of desktop publishing, creating a formatted printed document generally meant handing off a manuscript from a writer to a typesetter for re-keying, followed by mechanical pasteup by a page-layout artist, preparation of proofs by a printer, correction of proofs, and printing.

        This was in many ways a well-partitioned process. Professionals in each trade had a piece of the decision making and the tools to implement those decisions. However, the overhead of passing information from one trade to the next was cumbersome, resulting in a process that was time-consuming and expensive with many potential points of failure.   

        {Desktop publishing} eliminated much of that overhead by putting all of these functions -- writing, design, layout, and proofing -- in the hands of a single operator: the writer. This greatly sped up the publishing process and generally reduced costs by eliminating most of the trades traditionally involved in the process. 

        However, this radical change in partitioning introduced three problems:

        First, it put a huge amount of complexity on the writer. In a desktop publishing environment, writers must make many more decisions, which require knowledge and skills in addition to those required to research and write content. The demand for writers who could handle this complexity changed hiring practices. Desktop publishing skill became a major hiring criteria for writers and remains so today. The focus in hiring moved from writing skills and knowledge of subject matter to the ability to manage the publishing process.

        Second, because writers did layout and design while writing, their attention was divided between these tasks. Attention is a finite resource; when writers pay attention to layout and design rather than rhetoric, the quality of the writing suffers. And since the layout and design are only getting partial attention, their quality suffers as well.

        Third, although desktop publishing removed the need for a lot of vertical communication between writers, designers, and typesetters, it made no provision for horizontal communication between writers, leaving every writer on an island. Every book was a separate project. The division of the writer's attention and the lack of horizontal coordination left huge amounts of complexity unhandled in large content systems. Duplication, omissions, and inconsistencies became difficult to detect and fix, and providing effective {navigation} between books was virtually impossible. All of this rhetorical complexity was dumped on the reader in the form of poor quality content. Desktop publishing did not create this problem, but it did nothing to fix it.   

    section: Style sheets
        subjects:: type, term
            concept, style sheets

        One of the most visible early signs of unhandled complexity creating quality problems came in the form of the dreaded "desktop publishing look" -- an explosion of poorly designed and poorly laid out documents, characterized by bizarre font combinations, poor use of whitespace, poorly designed and placed graphics, and a seemingly random profusion of lines, shades, colors, and other decorative elements. (Insofar as these design defects hinder the reader's reception of the content, or detract from the image of the organization, they are also rhetorical problems.)

        To help contain this, desktop publishing systems introduced {style sheets}, which partially partition content from formatting. Style sheets allow a writer to format text using predefined, named styles. Each style encapsulates a set of decisions about content formatting that have been made by a style sheet designer. Style sheets allow you to partition decisions about what the text looks like from decisions about what the text says. 

        Style sheets do not completely partition formatting decisions from writers, however. Writers still must pass information to the partition that makes formatting decisions, which means writers must decide which styles to apply (knowledge) and know how to apply them (skill). Although this is less complex and requires less design skill than formatting by hand, experience shows that many writers do not use styles correctly or even at all.   

        Although style sheets remove some formatting decisions, the {WYSIWYG}+(index "WYSIWYG;style sheets and") (What You See is What You Get) display used by desktop publishing systems has another flaw. A key aspect of any interface between partitions is the feedback it gives users to let them know if they have done their work correctly. A WYSIWYG display tells you only one thing: does it look right? It does not tell you whether you have used styles correctly, or at all. And what looks right to you may not look right to the next person.

        Another problem is that style sheets partition the design of individual elements of a document, such as a title or a list, but not the overall design of the document. {Document design}+(index "document structure;style sheets and") remains on the writer's side of the partition. The style sheet restricts the formatting pallet, but it does not tell writers how to use that pallet to achieve an effective overall document design. Since writers are not document designers by trade, they may not always do this well, and multiple writers working on a common project will almost certainly do it inconsistently.
                      
        Many organizations use {style guide}s to tell writers how to use the style pallet to design documents. (For instance, which styles to use when creating a bibliography.) But the style guide only provides instructions, it does not partition the task away from the writer. The style guide merely adds another knowledge requirement, adding complexity.

        Styles, therefore, provide only limited relief to the complexity dumped on the writer, and they are only moderately successful in promoting consistent document appearance.

    section: Content management systems
        subjects:: type, term
            tool, content management system

        Meanwhile, the web brings a new set of challenges. A modern website is not a library of independent volumes; it's a complex {hypertext} consisting of many smaller pieces of content related in much more complex ways than paper documents ever were. {Search engines} and {social networks} have profoundly changed how readers seek and use content. Meeting those needs requires a level of coordination between writers -- and between the pieces of content they create -- that {desktop publishing}+(index "desktop publishing;content management systems and") cannot provide. 

        To help manage these challenges, most organizations have adopted {content management systems} (CMS). This has led to new forms of partitioning and new roles, such as {webmaster}, {information architect}, and, more recently, {content strategist}.

        Some of this new partitioning is useful, but sometimes content management systems can make things worse. For instance, some content management systems give control of the page header and sidebar to an {information architect} but let writers design the document part of the page pretty much as they did with a {desktop publishing system}. Unfortunately, this approach just wraps a frame around all of the shortcomings of desktop publishing, highlighting those shortcomings by closely juxtaposing the work of different writers. 

        Increasingly, therefore, content management systems have begun to incorporate more structured techniques and rely on a technology that actually predates desktop publishing: markup languages.  

    section: Markup languages
        subjects:: type, term
            concept, markup languages
        
        A {markup language} is a system for indicating the structure of a text via marks in the text itself. The structured writing examples we have looked at so far have all been written in markup languages. Markup languages were used for publishing on mainframe computers long before desktop computers had the processing power required for desktop publishing. A markup language -- {HTML} -- gave birth to the web by enabling writers to include in a document the information needed to format and display that document in a web browser.  

        The HTML document includes both information to be displayed to the reader and information to be used by the browser to display the document -- information that is not shown to the reader. This combination of two different streams of information in a single stream of characters is at the heart of how a markup language works and the role it plays in a content process. It allows you to partition tasks within the content process by passing the information those tasks need along with the content intended for the reader. 

        {HTML} is probably the single most widely used markup language in the world today, but there are thousands of others, and people create new markup languages all the time. Each markup language represents a specific interface between partitions in a content system.  

        Markup languages are by far the most general type of content interface, and they can be used to implement nearly any kind of partitioning you might need. In fact, markup languages are usually found behind the scenes in WYSIWYG and forms-based interfaces. However, markup languages can also stand alone as interfaces in their own right. {Markdown}, for instance, has become a popular markup language for writing simple web content. 

        There can be (and usually are), multiple partitions in a content system. The interfaces between those partitions are frequently markup languages, including interfaces that writers never use themselves. For instance, an organization may use {Markdown} to author some of their content but then convert {Markdown} to {HTML} for publishing and use a {CSS} style sheet (another markup language) to specify the formatting for that content.

        Today the term "structured writing" is often taken as a synonym for the use of markup languages. This is not really fair, since any use of computers for writing and publishing necessarily involves applying structure to text. The reason we associate markup languages so strongly with structured writing, however, is that markup languages allow organizations to create their own structures and, thus, change the way their content systems are partitioned. Any serious attempt to better manage the complexity of the content system by changing how the system is partitioned is likely to involve the use of markup languages, usually several markup languages in different roles.  

        Most of the discussion in this book focuses on the use of markup languages, because markup languages provide the greatest range of possibilities for effectively partitioning the content system. You may be able to hide some of the markup techniques discussed here behind WYSIWYG or forms-based interfaces. However, in this book I use markup to illustrate them all, because markup provides the clearest view of the structure and interfaces that define partitions. 


    section: Algorithms
    
        subjects:: type, term
            concept, algorithms

        block-index:
            {algorithms}+(index "algorithms;introduction") 
            
        To take content created using a markup language and turn it into a formatted document requires an algorithm. Algorithms are also used to manage the content process. An algorithm is simply a regular, codified, and repeatable method for doing a task. 

        Most complex tasks have repeatable elements in them. A design question that has been settled once can be implemented over and over again without having to redo the design work. If one piece of content is formatted a certain way, chances are many similar pieces can be formatted the same way. Algorithms are great at doing the same task the same way over and over. Therefore, partitioning such tasks away from writers and directing them to algorithms is a great way to reduce the complexity of the writer's task.  

        And while algorithms are repetitive by nature, they can also incorporate considerable knowledge, make sophisticated decisions, and execute complicated processes, which makes them capable of meeting both the knowledge and skill requirements to make useful decisions. Thus, you can use algorithms to execute many of the {extended decisions}+(index "extended decisions;using algorithms to make") in a content process, leaving writers and designers free to focus on the core decisions. 

        A {computer program}+(index "computer program, defined") is an encoding of an algorithm that a computer can execute. A program describes an algorithm to a computer, but you do not need to be a programmer to design an algorithm. The real trick is to discern which parts of a process can be defined as algorithms. That is why an understanding of the main structured writing algorithms is vital to effectively partitioning your content system.  

        Algorithms are fundamental to structured writing. Algorithms and structures work together to support rhetoric and process, and you can't design one without the other. The heart of this book describes the principal structured writing algorithms and the structures that support them. 
        

    section: Partitioning and roles 
        
        {Partitioning}+(index "partitioning;roles and") a content system often means changing the roles that people play in the organization. The introduction of {desktop publishing}, for instance, merged the role of writer and {typesetter} and, to a certain extent, the roles of {document designer} and {prepress operator}. Introducing more sophisticated (or simply more appropriate) structured writing techniques will likely mean introducing new roles or modifying existing ones.

        Writing an algorithm redistributes complexity away from the person who used to do the task, but it directs that complexity to the person who writes and maintains the algorithm. For example, using a {CSS} style sheet to format lists redistributes the task of designing list formatting from writers, whose job is to know what they are talking about and how to say it, to a {publication designer}, whose job it is to know how to attractively format lists and how to code good {CSS}.  
        
        Using {CSS} partitions the complexity of formatting a page, distributing that complexity away from the writer. Now, the writer does not have to know about formatting or design, and the designer does not have to know about writing or the subject matter. This allows writers to focus on writing and designers to focus on design. The result is better writing and better, more consistent, design supported by two distinct roles with different skill sets.  

        As I discuss the major structured writing algorithms in [#part.algorithms], you will see how these algorithms partition tasks between writers and professionals such as {information architect}s, {content engineer}s, and {content strategist}s. 

    section: Quality and rhetoric

        Many structured writing systems focus only on the {separation of content from formatting} ([#chapter.separating]) and on content management functions ([#chapter.content-management]). Separating content from formatting can help improve content quality by freeing more of the writer's time and attention to focus on writing. However, you can do much more to improve the quality of content by placing explicit constraints on the rhetorical structures that writers create. 

        Organizations are becoming more aware of the impact that {rhetorical quality} has on their business. The {web}+(index "web;rhetorical quality and the") has made it easier for users to access our information, but it has also made it easier for them to detect content that is inconsistent in tone and style, outdated, redundant, incomplete, or just plain useless. The web did not create these flaws, but it made them painfully apparent. It has also given organizations a much more direct way to see and to measure the impact of their content and of its flaws. Organizations can no longer ignore major rhetorical faults. This has led to the emergence of the discipline of {content strategy} as organizations feel the impact of poor content quality and see content quality as a strategic value.

        In the age of physical typesetting, there were no automated tools to help with the rhetorical quality of content, and the desktop publishing revolution was mostly concerned with digitizing the previously mechanical design and layout process. The limitations of the available tools forced organizations to partition their processes in ways that did not always support, encourage, or even permit, the highest quality rhetoric. The result was poor-quality content.

        Modern structured writing tools allow you to partition the content system in ways that significantly enhance the {rhetorical quality} of content. This includes methods that free writers to focus on quality, to create consistent content, to validate and audit content quality, and to create content structures and products that would not be possible with other methods. 

    section: Build quality into the process

        The idea that you can build {quality}+(index "quality;building in") into a process by managing the complexity of the design and production process, though accepted in other fields, has not been widely adopted in the content field. To a large extent, process improvements have been in publishing and content management, not rhetoric and content quality. Where structured writing tools have replaced desktop publishing tools, it has largely been in pursuit of process goals. But process and rhetoric are intimately related and treating them holistically can significantly improve both.

        Unfortunately, many current content systems not only fail to provide active rhetorical support to writers, they also fail to remove distractions and complexity from the writing environment. This ends up making the writer's life more complex rather than less. If writers end up with more complexity than they can comfortable handle, the result is reduced attention to rhetoric, which means diminished content quality. Sometimes that unhandled complexity also derails attempts to make the process more efficient because the information coming through the complex interface is not reliable enough for the new process to work correctly.

        Sadly, the developers of many content systems have never seriously attempted to minimize the amount of complexity they dump on the writer. They treat writing and publishing as separate concerns, as if the publishing process and its demands had no influence on the quality of content that the system produced. The result has been widespread dissatisfaction with both content systems and the resulting output. Lack of attention to where complexity falls in a system, and to the intimate relationship between process and rhetoric, typically results in breakdown and failure of the system. And it gets worse as features are added without adequate thought being given to the impact of the complexity they introduce, resulting in what content strategist {Joe Gollner}(person "Gollner, Joe") calls the "barnacalization of systems." 

    section: Towards a more effective partitioning of the content system
        
        The impact of poor quality content goes straight to the bottom line. To improve content quality on a consistent and economical basis, organizations need an approach to structured writing that recognizes the intimate relationship between process and rhetoric and that partitions the complexity of the content process to the people or processes with the time, skills, and resources to handle it effectively.

        Every organization has different process challenges and rhetorical goals. Thus, there is no one structured writing system that is a perfect fit for every organization. The attempt to create a single system to meet all needs has been a large factor in the poor partitioning of many content systems. Rather than prescribe any one partitioning, this book explores structured writing strategies you can use to partition your content system and suggests how you can determine which approach will work best for your organization. 

        
