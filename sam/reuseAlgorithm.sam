!smart-quotes: on
chapter:(#chapter.reuse) Reuse

    <<<(annotations.sam)

    subjects:: type, term
        algorithm, reuse algorithm
        concept, content reuse

    Another source of {complexity}+(index "complexity;content reuse as a source of") in content creation occurs when you want the same information to occur in more than one publication. If there is no coordination between writers, each writer who wants to include that piece of information will research and write it independently. Individual writers who want to use the same information in more than one publication will copy the information from one publication to another. However it happens, you now have two or more instances of the same information that you have to maintain and edit whenever the subject matter changes. If some instances do not get updated, or some of them get updated incorrectly, that is content maintenance complexity that is not being handled, and, as always, it falls through to the reader in the form of inconsistent or incorrect information. 
    
    Content reuse is an attempt to handle the complexity associated with using the same information in more than one place. Reuse has become one of the main drivers of structured writing, particularly with the widespread adoption of {DITA}+(index "DITA;content reuse in"). Unfortunately, most reuse techniques also introduce a lot of {management-domain}+(index "management domain;content reuse in the") complexity. A single-minded focus on reuse has sometimes led to the implementation of systems that dump large amounts of complexity on writers.

    If you are not careful, reuse can lead to more unhandled complexity than you started with, resulting in both process problems and significant damage to {rhetoric}+(index "rhetoric;reuse and its impact on"). Reuse is also an area in which process and rhetorical goals can easily be at odds; although using the same content for multiple purposes can deliver process benefits, it may not be the best rhetorical strategy. 
    
    It is important to remember that {content reuse}+(index "content reuse;alternatives to") is a means for creating {duplication}+(index "duplicate content;reuse and") in content. It eliminates duplication on the writing side, but it creates duplication on the output side. It is important to evaluate why you want that duplication at all and see if there are viable alternatives, such as publishing the information once and linking to it from various places. Here are some scenarios where you might want to duplicate information in more than one place: 
    
    * You are writing about different products that share common technology, and you want to duplicate information on the common features in the documents for each individual product. 
    
    * You are writing about several different releases of a product, and you want information on features that have not changed to be duplicated in the documents for the next release. 
    
    * You are writing documents for different audiences (marketing material, technical documentation for various roles, training material, etc.), and you want the same product descriptions in all these documents. 
    
    * You are writing general information (e.g., copyright and trademark statements), and you want to duplicate that information in many different publications. 
    
    The term _reuse_ can suggest that this activity is akin to rummaging through that jar of old nuts and bolts you have in the garage looking for one that is the right size to fix your lawnmower. While you can do it that way, that approach is neither efficient nor reliable. The efficient and reliable approach involves deliberately creating content for {duplication}+(index "duplicate content;reuse and") in multiple locations. This means that you need to place {constraints}+(index "constraints;reuse") on the content to be reused and the content that reuses it, and that means you are in the realm of structured writing.

    section: Fitting pieces of content together
    
        To create one piece of content that can be used in many outputs, you have to make sure it fits in each of those outputs. In other words, you have to {partition}+(index "partitioning;reuse and") it appropriately for reuse.
        
        If you {cut and paste}+(index "cut-and-paste reuse")+(index "content reuse;cut-and-paste"), this is not a concern. You can cut any text you like, paste it in anywhere, and edit it to fit if you need to. But if you reuse a single instance of text that is already used in other places, you can't edit it to fit because that might cause it to no longer fit in the other places. For reuse to work, the content must be written to fit in multiple places. In other words, it has to meet a set of constraints that ensure that it will fit in multiple places. I will look at this in more detail in [#chapter.composition]. In this chapter I focus on the algorithms for fitting the pieces together.
                
        There are seven basic {models}+(index "reuse models") for fitting pieces of content together:
        
        * Common into variable 
        * Variable into common
        * Variable into variable
        * Common with conditions
        * Factor out the common
        * Factor out the variable
        * Assemble from pieces
        
    section: Common into variable

        In the {common-into-variable}+(index "common-into-variable reuse") case, you have a common piece of content that occurs in many places. The common content could occur in many documents, in many places in the same document, or both (see [*fig.common2variable]). 

        figure:(*fig.common2variable) Common-into-variable diagram
            >>>(image ../graphics/common2variable.xml)
        
        There was an example of this in [#chapter.management-domain], where a set of dangerous procedures each required a standard warning. Each individual procedure is the variable part and the standard warning is the common part (see [*fig.blow-stuff-up-sam]).
        
        figure:(*fig.blow-stuff-up-sam) Common-into-variable markup example
            ```(sam)
                procedure: Blow stuff up
                    >>>(files/shared/admonitions/danger)
                    step: Plant dynamite.
                    step: Insert detonator.
                    step: Run away.
                    step: Press the big red button.        
         
        To ensure that the included content will always fit, you need to make sure that there is a clear partitioning of responsibilities between the common content and each place it will be inserted into. In [*fig.blow-stuff-up-sam], the inserted content should be the {safety warning}+(index "safety warnings, reusing"), the whole safety warning, and nothing but the safety warning. The procedure structure should describe the steps and only the steps and should insert the reusable warning at the right place. 
        
        You can also use the subject-domain approach to the common-into-variable case, which I described in [#chapter.management-domain]. I will go into more detail on that approach later in this chapter.
        
    section: Variable into common
        
        With the {variable-into-common}+(index "variable-into-common reuse") technique, you have a single document that will be output in many different ways by inserting variable content at certain locations (see [*fig.variable2common]). 

        figure:(*fig.variable2common) Variable-into-common diagram
            >>>(image ../graphics/variable2common.xml)
        
        For instance, if you are writing a manual to cover a number of car models, you can factor out the number of seats each model has. 
        
        ```(sam)
            The vehicle seats >($seats) people.
        
        
        This is the fixed content that will occur in all manuals, with the number of seats pulled in from an external source. Let's say you have a collection of vehicle data that is stored in a structure like [*fig.variable2common-sam].

        figure:(*fig.variable2common-sam) Variable-into-common data structure example
            ```(sam)
                vehicles:
                    vehicle: compact
                        seats: four
                        colors: red, green, blue, white, black
                        transmissions: manual, CVT
                        doors: four
                        horsepower: 120
                        torque: 110 @ 3500 RPM
                    vehicle: midsize
                        seats: five
                        colors: red, green, blue, white, black
                        transmissions: CVT
                        doors: four
                        horsepower: 180
                        torque: 160 @ 3500 RPM        
        
        [*fig.variable2common-pseudo] shows an algorithm that selects the correct insert by querying the structure in [*fig.variable2common-sam].

        figure:(*fig.variable2common-pseudo) Pseudocode for the variable-into-common algorithm
            ```(pseudo)
                match insert where variable = $seats
                    $number_of_seats = vehicles/vehicle[$model]/seats
                    output $number_of_seats        
       
        Of course, the insert and query mechanism in [*fig.variable2common-pseudo] is {pseudocode}+(index "pseudocode;reuse algorithm"). Exactly how things work and exactly how you delineate, identify, and insert content will vary from system to system. 
        
        With the variable-into-common technique, you create a common source by factoring out all the parts of the different outputs that are not common. This is, in some ways, the inverse of the usual pattern of factoring out invariants: you are actually factoring out the variants. But, really, it amounts to the same thing. You are factoring variants from {invariants}+(index "invariants;factoring out variants from"). The only real difference between this and the common-into-variable technique is whether the common parts are embedded in the variable parts or vice versa. Either way, you still end up with two artifacts: the variable piece or pieces and the common piece or pieces. 
        
    section: Variable into variable
    
        The {variable-into-variable}+(index "variable-into-variable reuse") technique is a variation on common-into-variable reuse in which you select different common elements to pull into a set of variable documents.
        
        For example, suppose you decide to sell your product line in a new market. The new market has different safety regulations, which means you need to insert a different standard warning into your manuals for that market. In this case, you want to swap out the common elements used in your home market and substitute the common elements for the foreign market (see [*fig.variable2variable-diagram]). 

        figure:(*fig.variable2variable-diagram) Variable-into-variable diagram
            >>>(image ../graphics/variable2variable.xml)
        
        In the common-into-variable example, you inserted the contents of a file that contained a standard warning. But for variable-into-variable reuse, this approach does not work. Variable-into-variable reuse requires you to load a different file for each market, but the content specifies a particular file name, making it difficult to select a different file for the new market. 
    
        As always in structured writing, you look for a way to factor out the problematic content. So here, you look for a way to factor out the file name and replace it with something else.
        
        section: Using IDs
        
            subjects:: type, term
                concept, IDs
    
            The most basic way to factor out the file name is to give the file an ID. An ID is a {management-domain}+(index "management domain;IDs in the") structure used to identify a piece of content in a location-independent way. No matter where the content is stored, it keeps the same ID. [*fig.warning-danger-id] shows the warning file with the ID `#warn_danger` added. 

            figure:(*fig.warning-danger-id) Danger warning with an ID added
                ```(sam)
                    warning:(#warn_danger) 
                        title: Danger
                        
                        Be very very careful. This could kill you.
            
            You can then insert the warning into your procedure by referring to that ID (see [*fig.warning-danger-ref]).

            figure:(*fig.warning-danger-ref) Procedure that refers to a warning using an ID
                ```(sam)
                    procedure: Blow stuff up
                        >>>(#warn_danger)
                        step: Plant dynamite.
                        step: Insert detonator.
                        step: Run away.
                        step: Press the big red button.
                                
            The decision about which warning to include has been shifted from the writer to the algorithm in [*fig.warning-danger-pseudo].

            figure:(*fig.warning-danger-pseudo) Pseudocode to locate a warning using its ID
                ```(pseudo)
                    match insert with ID
                        $insert_content = find ID in $content_set
                        output $insert_content
            
            This is a constant pattern in structured writing. When it comes to choosing and locating resources, you want to move that responsibility from the writer to the algorithm, which means moving the identity of the resource out of the content and into the algorithm. This makes it easier to update locations, but it also gives you far more options for storing and managing your content, since algorithms can interact with a variety of systems in sophisticated ways, rather than just storing a static address. It also means you can make wholesale changes in how your content is stored without having to edit the content itself. This is a major win in terms of partitioning complexity so it can be distributed and handled more efficiently.  
            
            This method requires that the algorithm have a way to resolve the {ID}+(index "IDs;resolving with a CMS") and find the content to include. In many cases, a {content management system}+(index "content management system;resolving IDs in a") can resolve the ID. In other cases, you can do something as simple as having the algorithm search through a set of files to find the ID or building a catalog that points to the files that contain content with IDs.
            
            To do {variable-into-variable reuse}+(index "variable-into-variable reuse;IDs with") in a system that uses IDs, you maintain a separate set of files that contain the variable content for each market. Each set uses the same IDs but different content. You simply point the algorithm at the set for the market you are generating output for. So if your foreign market requires a different warning, you can create a file that contains the message shown in [*fig.warning-danger-id-2].

            figure:(*fig.warning-danger-id-2) Alternate warning message for a different market
                ```(sam)
                    warning:(#warn_danger) 
                        title: Look out!
                        
                        Pay close attention. You could really hurt yourself.            
            
            By telling the algorithm that builds the foreign market docs to search this file for IDs, rather than the file with the domestic market warning, you automatically get the foreign warning rather than the domestic one. 
        
        section: Using keys
        
            subjects:: type, term
                concept, keys 
        
            Another way to do this is with another {management-domain}+(index "management domain;keys in the") structure called a _key_. A key is similar to an ID, but it is not directly tied to a resource. Instead, the same key can point to different resources at different times. Since a key does not represent any one concrete resource, you don't assign the key to a resource. Instead, you use an intermediate {lookup table}+(index "lookup table for keys")+(index "keys;lookup algorithm") to resolve keys to particular resources for a particular purpose.
            
            Suppose you have the warning in a file called `files/shared/admonitions/domestic/danger` with the content shown in [*fig.variable2variable-key-1] (no ID):

            figure:(*fig.variable2variable-key-1) Warning content in a key-based system
                ```(sam)
                    warning: 
                        title: Danger
                    
                        Be very very careful. This could kill you.            

            pagination-tweak:
                min-space: 1.5in
                
            [*fig.variable2variable-key-2] shows a procedure that includes the warning using the key `%warn_danger`.

            figure:(*fig.variable2variable-key-2) Procedure that includes a warning using key-based linking
                ```(sam)
                    procedure: Blow stuff up
                        >>>(%warn_danger)
                        step: Plant dynamite.
                        step: Insert detonator.
                        step: Run away.
                        step: Press the big red button.
        
            (These examples use `#` to denote IDs and `%` to denote keys. This is the notation that {SAM}+(index "SAM;ID and key markup in") uses for IDs and keys, but it is purely arbitrary and has nothing to do with how they work. Different systems denote IDs and keys in different ways.)
            
            To connect the key to the warning file, you create a key lookup table (see [*fig.variable2variable-key-3]).

            figure:(*fig.variable2variable-key-3) Key lookup table
                ```(sam)
                    keys:
                        key:
                            name: warn_danger
                            resource: files/shared/admonitions/domestic/danger            
            
            When the algorithm in [*fig.variable2variable-key-4] processes the procedure, it sees the key reference `%warn_danger` and looks it up in the key lookup table. The {key}+(index "keys;lookup algorithm") lookup table tells the algorithm that the key resolves to the resource `files/shared/admonitions/domestic/danger`. The algorithm then loads that file and inserts the contents into the output.

            figure:(*fig.variable2variable-key-4) Pseudocode for the key lookup algorithm
                ```(pseudo)
                    match insert with key
                        $resource = find key in lookup-table
                        output $resource            
            
            To output your content for the foreign market, you prepare a new key lookup table (see [*fig.variable2variable-key-5]) and tell the algorithm to use this table instead.

            figure:(*fig.variable2variable-key-5) Key lookup table for a new market
                ```(sam)
                    keys:
                        key:
                            name: warn_danger
                            resource: files/shared/admonitions/foreign/danger            
            
            Using {keys}+(index "keys;IDs versus") is not necessarily better than using {IDs}+(index "IDs;keys versus"). What it comes down to is that you need some kind of bridge between the citation of an identifier in the source file and the location of a resource with that identifier in the content store. This bridge can be created by a key lookup table, by remapping file URLs, or by modifying a query to a content repository. 
            
            One advantage of keys is that, because you don't attach the key directly to the content, you can use a key to identify resources that don't have IDs, including resources you don't control. 
                      
            One downside of keys is that, by themselves, they can only point to a whole resource. This can force you to keep your reusable units in separate files. To avoid this, you can combine keys with IDs. [*fig.variable2variable-key-6] combines both danger warnings into one file and gives each an ID.

            figure:(*fig.variable2variable-key-6) Warnings file with different versions identified by IDs
                ```(sam)
                    warnings:
                        warning:(#warn_danger_domestic) 
                            title: Danger
                        
                            Be very very careful. This could kill you.

                        warning:(#warn_danger_foreign) 
                            title: Look out!
                            
                            Pay close attention. You could really hurt yourself.
                         
            Now you can rewrite your key lookup tables to use IDs to pull the right warning out of the common file. Then you can use a key lookup table like [*fig.variable2variable-key-7] for the domestic build and [*fig.variable2variable-key-8] for the foreign build.

            figure:(*fig.variable2variable-key-7) Key lookup table with ID for domestic market
                ```(sam)
                    keys:
                        key:
                            name: warn_danger
                            resource: files/shared/warnings#warn_danger_domestic
            
            figure:(*fig.variable2variable-key-8) Key lookup table with ID for foreign market            
                ```(sam)
                    keys:
                        key:
                            name: warn_danger
                            resource: files/shared/warnings#warn_danger_foreign
            
            This method partitions the warnings into separate files and also partitions the location of those files from the writer. Using keys as a bridge between two partitions can be a convenient way to manage content relationships without having to update source files every time the relationships change. 

            The downside is that keys introduce an abstract element into the writer's world, and abstractions are a form of {complexity}+(index "complexity;keys and") that can be difficult to deal with. Instead of deciding which warning to use, writers have to decide which key or ID to use. That decision is not necessarily easier to make, and it requires more system knowledge and a more abstract way of thinking than the original decision that was factored out. Keys and IDs abstract out the actual act of inclusion, but that is the least complex part of ensuring that the standard warning is used. 
        
    section: Common with conditions
    
        subjects:: type, term
            concept, conditions
            algorithm, common-with-conditions reuse
        
        In some implementations of the variable-into-common approach, the variant pieces are not factored out into a separate file. Rather, each of the possible alternatives is included in the file conditionally (see [*fig.commonconditions-diagram]). 

        figure:(*fig.commonconditions-diagram) Common-with-conditions diagram
            >>>(image ../graphics/commonconditions.xml)
        
        For instance, in content for a car manual you might have conditional text for the number of people the car seats.
        
        ```(sam)
            The vehicle seats {four}(?compact){five}(?midsize){seven}(?van).
        
        
        Here the main text is the fixed piece and the variable pieces are the words "four," "five," and "seven." Which of these will be included in the output depends on which condition is applied during the build. If the condition `midsize` is applied, then the output text will be "five" and the other alternatives will be suppressed. [*fig.commonconditions-pseudo] shows this algorithm.

        figure:(*fig.commonconditions-pseudo) Pseudocode for the common-with-conditions algorithm
            ```(pseudo)
                match phrase with condition
                    if condition in $build_conditions
                        continue
                    else
                        ignore        
        
        The upside of the conditional approach is that it keeps all the variants in one file, so your algorithm does not have to know where to go to find the external content. But there are downsides to this approach:
        
        * It gets cumbersome to read the source if you apply many different conditions.
        * When the subject matter changes, you have to find all the places where conditions occur and update them.
        * If you refer to the same data point (the number of seats) in many different documents, that information is still being duplicated all over the content, which makes it hard to maintain, verify, or change if, for example, the compact seats five in the next model year.
         
        Common with conditions is not limited to cases where there are alternate values, however. In some cases, content may simply be inserted or omitted for certain outputs (see [*fig.commonconditions-sam]). 

        figure:(*fig.commonconditions-sam) Common with conditions used for optional content
            ```(sam)
                The main features of the car are:            

                ol:
                    li: Wheels
                    li: Steering wheel
                    li:(?deluxe) Leather seats
                    li: Mud flaps        
        
        In this case, the list item "Leather seats" is only published if you specify the condition `deluxe` in the build. It would be omitted for all other builds. In cases like this, it is hard to avoid using conditionals as a reuse mechanism.
           
        This approach to reuse is often called {filtering} or {profiling}. Some systems have more elaborate ways of specifying filtering or profiling. The net effect is the same as the simple condition tokens shown in this section, but such systems may allow for more sophisticated conditions.
        
        Because common with conditions is essentially a form of variable into common where the variable content is contained inside the common source, it can technically be replaced by a variable-into-common approach in all cases. In practice, conditions are typically used in the following cases:
        
        * The number of variations is small and thought to be fixed or to change infrequently.
        
        * The variable pieces are eccentric or contextually dependent. 
        
        * The writer or organization wishes to avoid managing multiple files.
        
        * The current tools don't support variable into common.
        
        How successful a common-with-conditions approach will be also depends on what you choose for your conditional expressions. Generally, subject-domain conditions will be more stable and manageable than document-domain conditions. For instance, conditions that relate to different vehicles (subject domain) are based in the real world and are, therefore, objectively true as long as the subject matter remains the same. Conditions that relate to different publications or different media, on the other hand, are not objectively true and can't be verified independently. The only way to verify them is to build the different documents or media and see if you get the content you expected. This makes maintaining such conditions cumbersome and error prone -- an indication that complexity is not being distributed in an optimal way. 
        
    section: Factor out the common

        subjects:: type, term
            algorithm, factor-out-the-common reuse
    
        In [#chapter.management-domain], I noted that the subject-domain alternative to using an insertion instruction for the warning text was to specify which procedures were dangerous, thus factoring out the constraint that the warning must appear (see [*fig.factor-out-common-sam]).

        figure:(*fig.factor-out-common-sam) Procedure that factors out explicit inclusions             
            ```(sam)
                procedure: Blow stuff up
                    is-it-dangerous: yes
                    step: Plant dynamite.
                    step: Insert detonator.
                    step: Run away.
                    step: Press the big red button.
        
        In this case, writers do not have to identify the material to be included, either directly by file name or indirectly through an ID or a key. Instead, it is up to the algorithm to include it (see [*fig.factor-out-common-pseudo]).

        figure:(*fig.factor-out-common-pseudo) Pseudocode for the factor-out-the-common algorithm
            ```(pseudo)
                match procedure/is-it-dangerous 
                    if is-it-dangerous = 'yes'
                        output files/shared/warnings#warn_danger_domestic
        
        
        To produce the foreign market version of the documentation, you simply edit the rule, as shown in [*fig.factor-out-common-pseudo-2].

        figure:(*fig.factor-out-common-pseudo-2) Pseudocode for an alternative warning using the factor-out-the-common algorithm
            ```(pseudo)
                match procedure/is-it-dangerous 
                    if is-it-dangerous = 'yes'
                        output files/shared/warnings#warn_danger_foreign
                    
        Or, to further partition complexity in the code, you can use keys, as shown in [*fig.factor-out-common-pseudo-3].

        figure:(*fig.factor-out-common-pseudo-3) Pseudocode for the factor-out-the-common algorithm using keys
            ```(pseudo)
                match procedure/is-it-dangerous 
                    if is-it-dangerous = 'yes'
                        $resource = find key '%warn_danger' in lookup-table
                        output $resource      
        
        The beauty of this approach is that the content is entirely neutral as to what kind of reuse is going on or how dangerous procedures are treated. Because the content contains only objective information about the procedure itself, you can implement any publish or reuse algorithm you like -- in any way you like and at any time. Because the content does not specify any form of reuse or any reuse mechanism, you have made it more reusable and partitioned the complexity of reuse much more neatly and reliably. 
        
        This approach also makes the content much {easier}+(index "usability") to write, since it does not require writers to know how the reuse mechanism works, how to identify reusable content, or even that reuse is occurring at all. All they have to do is answer a simple question about the content that they should know the answer to: is the procedure dangerous or not.

        This approach partitions the entire reuse mechanism away from writers. This is a big win because the biggest problem with most reuse techniques is the amount of complexity they add for writers, which directly compromises their finite and valuable attention.  
        
        This is important from the point of view of both complexity and cost. Whenever writers are asked to consciously reuse content, they have to look for that content every time the potential for reuse occurs. This cost is incurred whether or not they find reusable content, whereas any savings from reuse are realized only when reusable content is found.

        The factor-out-the-common approach relieves writers of all responsibility for the reusable content. Locating reusable content is the job of an algorithm. If the content does not exist, the algorithm will report that it is missing, and it will be somebody's job to create it, after which the algorithm will locate it automatically every time it is needed. This is far more efficient than having writers look for reusable content over and over and over. 
        
        The downside of this approach is that it is not as general. The `is-it-dangerous` metadata applies only to dangerous procedures. It does not address the inclusion of reusable content in other places. You would need to factor out other interesting reuse cases in a similar way to create a complete subject-domain solution. Again, we see that complexity always has to go somewhere. But as we have also seen, if writers cannot fully handle the complexity thrust on them, that complexity goes unhandled, with consequences for both process and rhetoric.
        
    section: Factor out the variable

        subjects:: type, term
            algorithm, factor-out-the-variable reuse
    
        You can also factor out the variable content. In the case of the different models of a car, rather than conditionalizing the list of features in the document, you can maintain the list in a database. The organization probably already has a database of features for each vehicle, so you don't need to create anything new. Instead, you simply query the existing database. After all, reusing what already exists is what reuse is all about.

        pagination-tweak:
            min-space: 2in
            
        For example, instead of including the feature list, as shown in [*fig.factor-out-variable-sam], you can factor out the list entirely, as shown in [*fig.factor-out-variable-db].

        figure:(*fig.factor-out-variable-sam) Conditionalized feature list
            ```(sam)
                The main features of the car are:
            
                ol:
                    li: Wheels
                    li: Steering wheel
                    li:(?deluxe) Leather seats
                    li: Mud flaps        
        
        figure:(*fig.factor-out-variable-db) Factored-out feature list
            ```(sam)
                The main features of the car are:
            
                >>>(%main_features)

        Now, your algorithm looks like [*fig.factor-out-variable-pseudo].

        figure:(*fig.factor-out-variable-pseudo) Pseudocode for the factor-out-the-variable approach
            ```(pseudo)
                match insert with key
                    $resource = lookup key in lookup-table
                    output $resource        
        
        You then have a key lookup table where the resource is identified by a query on the database ([*fig.factor-out-variable-query]).

        figure:(*fig.factor-out-variable-query) Key lookup table for the factor-out-the-variable approach
            ```(sam)
                keys:
                    key:
                        name: %main-features
                        resource: from vehicles select features where model = $model        
        
        This query retrieves a different set of features from the database depending on how the variable `$model` is defined for the build. Launch the build with `$model = 'compact'` and you get the feature set for the compact model. Launch the build with `$model = 'van'` and you get the feature set for the van model.
        
        Naturally, this leaves out a lot of detail about how this query gets executed and how the results get structured into a document-domain list structure. But those are implementation details. 
    
    section: Assemble from pieces

        subjects:: type, term
            algorithm, assemble-from-pieces reuse
        
        In the assemble-from-pieces approach, there is no common vs. variable distinction and no single source document into which you insert reused content or apply conditions. Instead, you assemble a set of content units to form a finished document (see [*fig.assemble-diagram]). 

        figure:(*fig.assemble-diagram) Assemble-from-pieces diagram
            >>>(image ../graphics/assemble.xml)
        
        For example, if you have a range of products with common features, you might assemble the documentation for those products using a common introduction followed by a piece representing each feature of each model. This piece could be a flat list, or it could be a tree structure. For instance, you might assemble a chapter of a manual with an introductory piece and then several sections below it in the tree, as shown in [*fig.assemble-tree]. 

        figure:(*fig.assemble-tree) Assemble-from-pieces tree structure
            >>>(image ../graphics/tree.xml)
        
        The assembly approach requires a structure to describe how the units are assembled. This structure is often called {map}+(index "map;assemble-from-pieces reuse with a"). (It is called a map in {DITA}+(index "DITA;maps in"), for instance.) Some applications refer to it as a {table of contents}. [*fig.assemble-map] is an example of a map.

        figure:(*fig.assemble-map) Assemble-from-pieces map
            ```(sam)
                map: Widget Wrangler Deluxe User Manual
                   unit: units/ww/deluxe/intro
                       unit: units/ww/shared/basic_features
                       unit: units/ww/deluxe/deluxe_features
                   unit: units/ww/shared/install/intro
                       unit: units/ww/shared/requirements
                       unit: units/ww/deluxe/requirements
                       unit: units/ww/shared/install
                       unit: units/ww/deluxe/install_options
               
        Rather than using a map, you can allow the units themselves to pull in other units, which may in turn pull in other units. So the Widget Wrangler Deluxe install introduction unit might look like the example in [*fig.assemble-unit].

        figure:(*fig.assemble-unit) Alternate structure for the assemble-from-pieces approach
            ```
                unit: Installing the Widget Wrangler Deluxe
            
                    You should be very careful when installing the 
                    Widget Wrangler Deluxe. Follow these steps carefully:
                
                    >>>(unit units/ww/shared/requirements)
                    >>>(unit units/ww/deluxe/requirements)
                    >>>(unit units/ww/shared/install)
                    >>>(unit units/ww/deluxe/install_options)        
        
        This method avoids the need for a map, but it can make the units less reusable. In [*fig.assemble-unit], you would need a separate introduction unit for the regular Widget Wrangler, since the introduction file imports all the requirements and procedural units. By assembling units with the map, you can use a shared install introduction, which increases the amount of reuse you can do. 
        
    section: Combining multiple techniques

        There is one problem with using a common install introduction for both the regular and the deluxe Widget Wrangler. The introduction mentions the name of the product. To solve this problem without requiring two different units, you can use the variable-into-common or common-with-conditions {reuse techniques}+(index "reuse algorithm;combining multiple techniques"). [*fig.combine-unit] shows an example using variable into common:

        figure:(*fig.combine-unit) Combination of the assemble-from-pieces and variable-into-common approaches
            ```
                unit: Installing the >($product_name)
            
                    You should be very careful when installing 
                    the >($product_name). Follow these steps carefully:
                
                    >>>(unit unit/ww/shared/requirements)
                    >>>(unit unit/ww/deluxe/requirements)
                    >>>(unit unit/ww/shared/install)
                    >>>(unit unit/ww/deluxe/install_options)        

        There are a number of ways to mix and match the basic reuse patterns to achieve an overall reuse strategy. Most systems designed to support reuse allow you to use all of these approaches and combine them as needed. However, don't lose sight of the amount of complexity you introduce into your content and your writers' workload when you rely on a complex set of reuse techniques.
                       
    section: Content reuse is not a panacea
        block-index:
            {content reuse}+(index "content reuse;downsides")
    
        Content reuse can seem like an easy win, and in some cases it can return substantial benefits, but there are pitfalls to be aware of. You need to plan carefully to make sure that you avoid the traps that await the unwary.
        
        Many reuse techniques introduce a lot of complexity into the writer's job and into the content itself. These techniques may address major sources of content complexity, but they come with a high cost in terms of new complexity introduced. Even if a reuse tool looks easy to use, it can introduce large amounts of complexity.
        
        section: Rhetoric traps
            block-index:
                {rhetoric}+(index "rhetoric;reuse and its impact on")
        
            Designing content to be reused can harm its rhetoric, either by distracting writers with complexity or by motivating them to prefer reusability over rhetorical quality. There are three main rhetoric traps with content reuse:
            
            * Making content too generic
            * Losing the narrative flow
            * Failing to address the audience appropriately
    
            Many works on content reuse casually recommend making content more generic or more abstract as a means to making it more reusable, without saying anything about the potential downside. This is very dangerous and can do serious harm to the rhetorical quality of your content. Specific, concrete statements are easier to understand, and they communicate better than generic or abstract statements. Replacing specific and concrete statements with generic or abstract statements will reduce the effectiveness of your content significantly. This is a classic case of one process directing complexity away from itself without regard for the effect on the whole.
            
            Unfortunately, as noted in [#chapter.writing], human beings suffer from the {curse of knowledge}+(index "curse of knowledge;reuse and the"). The curse of knowledge is a cognitive bias that makes it very hard for people who understand an idea to appreciate the difficulties that idea presents to people who do not understand it. The curse of knowledge makes a generic or abstract statement of an idea appear to the writer to be as clear as a concrete and specific statement -- and perhaps more succinct and precise. This pulls writers away from the kind of specific and concrete statements that make ideas easier to comprehend. The desire to make content reusable reinforces this temptation. 
            
            Replacing the specific and concrete with the generic and abstract always reduces content quality and effectiveness. You may decide that the economic benefits of content reuse outweigh the economic costs of less effective content, but you should at least be aware that there are real economic consequences to this choice. 
            
            Another potential quality problem comes with the loss of {narrative flow}+(index "narrative flow"). Not all content has or needs a lengthy narrative flow, but if you start breaking your content into reusable units and putting those units back together in different ways, the narrative flow can easily be lost. In some cases you can avoid this problem by making your topics more self-contained, using an {Every Page is Page One}(concept) information design. But don't assume that you have an effective Every Page is Page One design just because you have broken your content into reusable units. If that content was written in a way that assumed a narrative flow, it won't work when reused in a way that breaks that flow. 
            
            Finally, reuse can encourage you to come up with one way of telling our story that you present to all your audiences. But not all audiences are alike, and the way you tell your story to one audience may not work for another audience. Good rhetoric tells a good story to a particular audience. Two different tellings of the same story do not constitute redundant content if they address different audiences. 
        
        section: Cost traps
            block-index:
                {content reuse}+(index "content reuse;cost considerations")
        
            It is easy to see content reuse as a method to achieve big cost savings. Reusing content means you do not have to write the same content over and over again. It is easy to add up the cost of all that redundant {writing}+(index "writing;complexity of with reuse") and regard that number as pure cost savings from a content reuse strategy.
        
            But all of the reuse techniques create multiple artifacts -- including content and algorithms -- that need to be managed. You need a mechanism to make sure that your content obeys the {constraints}+(index "constraints;reuse") required to make the pieces of content fit together reliably. You need a mechanism to make sure that your reuse processes produce the documents you need. The cost of such management can be non-trivial, and the consequences if the management breaks down can be significant. 
            
            While reuse is supposed to reduce the cost of modifying content when the subject matter changes, there are hidden cost traps here as well. It is often not until the subject matter changes that you find out if the content you have treated as common is really common. If not, you have to sort out what is common and what isn't, which can involve complex edits that have to be tested and verified.

            If you get everything right, you can realize major savings when it comes time to modify your content, but if you get it wrong, your costs can multiply. Not only that, you may find that the money you spent factoring duplicate content out in anticipation of a change that did not happen is wasted as well. Reacting to changes that actually happen is sometimes cheaper than preparing for multiple changes that never happen. 

            If you do not {audit}+(index "auditing;reuse") and validate your content collection regularly, it can become chaotic over time and lose cohesion. This can make adding new content or changing existing content increasingly difficult and expensive. 
            
            Depending on the techniques you use, content reuse strategies can complicate the lives of writers, which may reduce the pool of writers you can use or reduce their productivity. 
            
            With many reuse techniques, writers have to look for reusable content frequently. Not only does this take time and add complexity, writers have to pay that cost every time they look for content to reuse, whether they find it or not. Indeed, if writers must look for reusable content before they write anything, much of their time may be taken up with unsuccessful content queries. Reducing the expense of content queries, therefore, has to be a major component of any general reuse strategy. I look  at this in more detail in [#chapter.duplication].

            Localized and constrained forms of reuse can avoid this cost trap. For instance, if your reuse is focused on producing manuals for different versions of a product, you can train writers on techniques specifically for this purpose, thus avoiding the need for them to make frequent, broad-based queries to find reusable content.
    
            Some content reuse techniques are easy to use in non-structured ways, and early in a project, it may seem like a non-structured approach to reuse speeds things up by allowing writers to reuse content wherever they find it. Over time, however, this approach can lead to a rat's nest of dependencies and relationships that makes it hard to update the content with any confidence. 
            
            Once the cohesion and discipline of a content set starts to break down, the decline can accelerate. As it becomes harder to find content to reuse, more duplication occurs, which further complicates the search for reusable content, creating a vicious cycle. As links and other content relationships break down, people tend to form ad hoc links and relationships to get a job finished, further tangling the existing rat's nest. Under the gun, it is almost always easier to get the next document out by ignoring the discipline of the content set structure, but the effects of this are corrosive. Without consistent discipline, even in the face of deadlines, a reuse system can fail over time. 
             
            All of these issues can be managed successfully with the right techniques and the right tools, but they all introduce costs as well, both up-front costs and ongoing costs. Those costs have to be calculated and subtracted from the projected cost savings before you can determine if a content reuse strategy is going to save money.      

            One final trap: there may not be as much potential reuse as you thought. Some organizations have plunged into reuse strategies in hopes of a big payoff only to find that they had far less reusable content than they first thought. The cost of systems and the complexity added to the process by complex reuse techniques require a high level of reuse to pay off. If you can't achieve that level of reuse, your system will end up costing you more than it saves.             
            
    section: Alternatives to reuse
        block-index:
            {content reuse}+(index "content reuse;alternatives to")
    
        Here are three alternatives to content reuse:
        
        |Duplicate but label| Allow information to be stored in more than one place but clearly label the information so you can easily find it when you need to do an update. If this sounds like an inferior solution, consider that reuse techniques cannot possibly eliminate all repeated information without adding more complexity than they eliminate. Therefore, no matter how much reuse you do, when you have a major change in subject matter, you will still have to search your content for varying statements of the same fact that need to be updated.

        |Reduce duplication| Content reuse is always content duplication. Reuse is predicated on the idea that you actually want to duplicate information in multiple publications. This idea is out of date. In the paper world, you had to give each customer a book that contained all the information needed, even if the same information occurred in many different books. But in an online environment, you don't need to duplicate information to make it available to every user who needs it. Maintaining the information once and linking to it whenever it is needed is often a much less complex solution. To do this efficiently may require some of the techniques described in [#chapter.linking].
        
        |Combine and differentiate| Another approach to reducing duplication in your content is to combine information on multiple products into a single publication and differentiate them in the text. There are limits to this, obviously, and some organization got into content reuse specifically so that they could remove the complexity of handling multiple versions in a single manual. Still, there are times when it is an appropriate solution. 
        
