chapter:(#chapter.mechanical-structure) Mechanical Structure

    <<<(annotations.sam)
    
    Mechanical structure is the way we record, encode, and enforce the rhetorical structure, of a formal content model. While the rhetorical structure is concerned with how the content fulfills it purpose, the mechanical structure has to deal with specific representational issues and get the nuts and bolts of content recording right -- without dropping any complexity in the process.  
    
    However detailed you may have been in delineating the rhetorical structures your want to achieve, you will find there is more detailed work to do when it comes to the specifics of the mechanical structure, and particularly with the mechanics of factoring out structures in order to partition and transfer content system complexity. 
    
    The mechanical structure of structure writing is a computer data structure. However, conventional computer data structures like relational database tables do not work well for content because they are too regular to fit the shape of content. Creating structures that are regular enough for algorithms to deal with yet irregular enough to fit written language is an interesting problem to which more than one solution has been proposed.
    
    Raw text is just a stream of characters. Inside that stream of characters, there are rhetorical structures like headings, bibliographical entries, bold text, chapters, ingredient lists, links, wine matches, tables, function signatures, and labeled lists. The question is, how do you express these various structures within the raw stream of characters?
    
    The most common answer is that you divide the text up into a series of blocks, and divide those blocks into smaller blocks until all the structures you want to capture are contained in blocks. This is not the only way to do it. Some file formats, such as WordPerfect, use independent stop and start markers to delineate structures, meaning the the boundaries of structures can overlap. But while this kind of structured can work for the media domain, it is very difficult for many structured writing algorithms to work with. Therefore most structured writing today uses the nested block approach.[*1] 
    
    footnote:(*1)
        Is is technically possible to implement independent stop and start markers even in languages that are mainly block based. You simply define empty blocks for the start and stop markers. Both DITA and DocBook do this for things like delineating arbitrary bits of content for reuse and defining arbitrary spans of content for indexing. Both of these uses strike me as a really bad idea and I would recommend against their use in any content that has any lifespan beyond its first publication.  
        
    >>>(image ../graphics/blocks.svg)

    There are definitely cases in which the use of non-overlapping blocks for the mechanical structure of content does not fit with the rhetorical structures that we find in our content. This is more of an issue for the academic study of texts than for structured writing as a means of partitioning and redirecting complexity in the content system, but it can occur in both fields. Allowing overlapping fields, however, adds complexity to many of the structured writing algorithms, meaning it is almost never a worthwhile approach to partitioning our content. 
    
    For our purposes, therefore, I am going to deal with the mechanical structure of content strictly in terms of nested non-overlapping blocks. 

         
    section: Flat vs. hierarchical structures
    
        Even when we decided on the nested blocks approach we are still left with some fundamental choices about mechanical structure. The first is flat vs. hierarchical structure.  
        
        We noted in [#chapter.document-domain] that in HTML, you have six levels of heading (`h1` through `h6`) whereas in DocBook you have only `title`. In DocBook, you can divide a document up into sections and nest sections inside sections. You can then print the titles of sections inside sections in a smaller font that the titles of first level sections. You get to have differences in heading size without having six different heading tags. 
        
        But the DocBook model assumes that the real structure of a document is  a hierarchy of nested sections and that the size of titles announces the steps up and down that hierarchical tree. HTML makes no such assumption. It will let you put a `<h4>` immediately after an `<h1>` if you want to. It treats documents as essentially flat structures punctuated by headings of various sizes as and where appropriate. 
        
        Which model of a document is correct? Which corresponds best to the rhetorical structure of the document? You can think of a document as being organized hierarchically, with major ideas expressed in sections, sub-ideas supporting the major ideas in subsections, etc. There are many documents that fit that model. But you can also think of documents as being more like a journey in which headings function more like road signs. A city gets a big sign, a hamlet a small sign, and a town a medium sign. But the town is not inside the city, not the hamlet inside the town, and there is no guarantee that on leaving the city you will come to the town before you come to a hamlet.   
        
        Studies by Peter Flynn indicate that most authors think of the documents they are writing much more in terms of a punctuated linear model than a hierarchical model.
        
        """[#Flynn2009]
            The classical theory, derived from computer science and graph theory, is that the document is a hierarchical tree (actually inverted: a root-system) and that all necessary actions can be seen in terms of navigation around the tree, and of insertion into and withdrawal from the the nodes which form the branches and leaves.
            
            The conventional writer, however — and we expressly exclude the markup expert, as well as the experienced technical authors who responded to the survey — is by repute probably only marginally aware of this tree; but we have been unable to measure this at present. In this view, the document is seen as a continuous linear narrative, broken into successive divisions along semantic lines, and interspersed with explanatory material in the form of figures, tables, lists, and their derivatives. 


        And as Flynn's research illustrates, there is a good chance that the author is not thinking of their argument as consisting of a strict hierarchy of points either, but as a sequence of points with the occasional insertion of headings to break up the text or perhaps signal a change in emphasis or subject matter. 
        
        Clearly defining the rhetorical structure of a document demands dividing it up into blocks such as introduction, ingredients, and preparation. As we have noted, treating these parts of the rhetorical structure as blocks is essential to establishing the context in which our block names are defined and by which our processing rules tell the difference between one type of block and another. This clearly involves asking the author to think a little bit more hierarchically than they might otherwise, which means imposing a little bit of complexity on them for the sake of all the partitioning and redirection of complexity we need to do for the content system overall. Some semantic and rhetorical blocks are going to be naturally more hierarchical than others as well. But there is no need to do any more of this than the needs of our partitioning system demand.          
                
        If the {constraints} that we want to express in structured writing demand hierarchy, while {functional lucidity} demands more of a punctuated linear model, how do we reconcile these two opposing requirements in markup language design? 
        
        This is of greatest concern in the design of {document domain} languages. The structure of {media domain} languages is largely dictated by the shape and relationship of the media-domain object they are modeling. In the {subject domain}, we have abstracted content out of strict document order. Hierarchy in the {subject domain} tend to match the hierarchy of relationship in the subject matter itself.[*2] In the {document domain}, however, it is a real concern. The document domain consists of abstractions of document structures and the nature of their relationship to the structure of thought in the text is not obvious. 
        
        footnote:(*2)
            Though this is not universal. Addresses, for instance, which are based on hierarchal locations, are modeled as flat ordered lists. The order reflect the hierarchy, but the nesting of city inside country and of street within city is not reflected in the structure of an address record.
        
        The options available are:
        
        * Create a really flat document domain language. Examples are HTML and Markdown. The problem here is that they impose few constraints, and the lack of context-setting hierarchy makes it hard to model different types of document structures without creating hundred of tags -- which would negate any {functional lucidity} that you gained by keeping the language flat.
        
        * Create a hierarchical language that has a really permissive structure, so that you can put boxes inside boxes in lots of different ways. An example of this is DocBook. The problem here is that the possible permutations make writing algorithms difficult and you often need to impose additional constraints on your authors that are not expressed or enforced by the markup itself. This again diminishes {functional lucidity}, and compromises {conformance}. (An interesting property of this approach is that the flexibility of the language means that authors can choose to create documents that are very hierarchical or very flat. This is not really a virtue, however, as it is not clear how this choice contributes to improved content quality.)
        
        * Define a smaller, stricter document domain language that is appropriate to the particular types of documents you want to write, possibly as restricted subset of an existing language like DocBook. The main difficulty with this approach is that it involves you in having to do your own language design, which many organization try to avoid. In other words, it involves transferring complexity to an information architect or content engineer. Once you have decided to go this route, going to the {subject domain} instead may be no more expensive while providing better {functional lucidity} and {conformance}. 
        
        * Define a strict hierarchical document domain language that expresses the constraints you need and make people learn it. This works if you are able to recoup the expense of training your authors. It does not work if you want to include occasional authors in your pool of contributors. 
        
        * Move content creation to the {subject domain}. 
        

        
    bibliography:
        entry:(#Flynn2009)
            Flynn, Peter. “Why writers don't use XML: The usability of editing software for structured documents.” Presented at Balisage: The Markup Conference 2009, Montréal, Canada, August 11 - 14, 2009. In Proceedings of Balisage: The Markup Conference 2009. Balisage Series on Markup Technologies, vol. 3 (2009). doi:10.4242/BalisageVol3.Flynn01.        
        
        

    section: Annotating blocks
        
        Every block is annotated to tell us, and algorithms, what it means, which is to say, what constraints it meets. The most basic of these annotations is the name of the block, which describes it basic type. The name of a table block is "table", which tells us that its type is table. Blocks may also have other annotations that either refine its type of provide additional information about the block. 
        
        These additional annotations don't have to be in the same domain as the block name. We saw and example of this in [#chapter.subject-domain]:
        
        ```(xml)
            <section publication="Wine Weenie">
                <title>Wine match</title>
                <p>Pinot Noir</p>
            </section>
            <section publication="The Teetotaler's Trumpet">
                <title>Suggested beverage</title>
                <p>Lemonade</p>
            </section>

        Here the `section` element defines a block in the document domain, and the `publication` attribute adds an annotation is in the management domain. 
                
                
    section: Agreeing on names
    
        For structured writing to work, it is essential that everyone involved understands and agrees on what the names and annotations mean. These annotations tell downstream people and processes what constraints each block obeys. If the names and the values of the other attributes don't mean what we have all agreed they are to mean, communication between the partitions of the content system breaks down and complexity leaks out of the seems and descends on the reader. 
        
        Confusion and disagreement about what the names and annotations of a particular language mean are not uncommon. Large document domain languages like {DocBook} and {DITA} have large vocabularies, and many of the names they offer are quite abstract. Questions about the right way to tag certain passages are common in the communities around these languages, and opinions can vary considerably in some cases. These disagreements don't only affect low-level structures. In {DITA}, for example, it is common to debate if a topic that is operational but not procedural is a concept or a task. Some writers choose to use only generic topics because they don't feel the models of the task, concept, and reference topics fit the content they are creating. 
        
        Having precise definition of terms is important, therefore, in developing a structured writing language. But it is equally important that the language be {functionally lucid}. The {authoring algorithm} requires that creating structure should not come at the detriment of the writing itself. This requirement is not met if writers are constantly having to puzzle out or debate the right way to mark something up. As we have seen, conformance is chiefly served by designing structures that are easy to conform to. This does not only mean defining what the names mean, but choosing the structures that are it is easiest for authors to name correctly. 
        
        In the software world, meta models and abstraction are powerful tools for modeling systems. They provide clear high-level rules for the design of specific structures and create opportunities to reuse code for objects with a shared base model. But these tools can also lead to very abstract naming schemes and even to abstract structures. In the content world, such abstract names and structures can be formally correct but lack the kind of {functional lucidity} required for effective authoring.        
        
        The problem of defining a mechanical structure to express a rhetorical structure is not only one of defining a correct representation of the content. We also have to design and name structures that can be written by our intended set of authors without imposing a heavy burden on their attention. In other words, designing content structures, at least those intended for use by authors, is as much about interface design as it is about data structure design. And interface design is all about partitioning and distributing complexity.
        
        Clear concrete and specific names, and an organization of blocks that intuitively fits the subject matter, all make for easier authoring. There is no reason that such structures cannot be derived from abstract models, or that they cannot be mapped to abstract models after the fact, but it is important not to let the abstractions intrude into the world of the author. 
        
    section: Different rules for intermediate languages
    
        Of course, functional lucidity only matters for the formats that authors actually write in. As we have seen, the {publishing algorithm} typically consists of multiple steps, and each one of those steps can create a format that is closer to the media domain than the one before it. It is perfectly possible to design a document domain structure for the sole purpose of of serving as a step in the publishing chain. Separate authoring formats are created for authors to actually write in (perhaps {subject domain} formats or simplified highly constrained ad-hoc document domain formats). Content is transformed from these formats to the document domain format by the {presentation algorithm} and then the document domain format is translated in to various different media domain languages by the {formatting routine}. An arrangement like this eliminates the need to compromise between different demands in designing a single language, generally making each language in the chain simpler and more constrained, which in turn makes it each one easier to {validate} and to process.

       
        
        section: Secondary structures of interpretation    
            
            Under normal circumstance, the structures that constrain the content also constrain its interpretation. But there are cases in which annotations are added to structures to constrain a different interpretation of the content from the one specified by the structure that contains it, and not only of individual fields, but of a structure as a whole. 

            Consider these {examples of HTML Microformats from Wikipedia}[https://en.wikipedia.org/wiki/Microformat]. The first example shows an address formatted as a list. 
            
            ```(HTML)
                <ul>
                   <li>Joe Doe</li>
                   <li>The Example Company</li>
                   <li>604-555-1234</li>
                   <li>
                     <a href="http://example.com/">http://example.com/</a>
                   </li>
                </ul>

            
            Here the phrase "The Example Company" is contained in `li` tags. This is part of a list structure delineated by `ul` tags, so the markup is largely structural in the document domain. The `li` does not really tell you anything about what the content itself is about. It does not tell you anything useful beyond what document structure it belongs to.    

            The second example adds vCard microformat markup:
            
            ```(HTML)
                <ul class="vcard">
                  <li class="fn">Joe Doe</li>
                  <li class="org">The Example Company</li>
                  <li class="tel">604-555-1234</li>
                  <li>
                    <a class="url" href="http://example.com/">
                       http://example.com/
                    </a>
                  </li>
                </ul>

           
            This example adds subject domain metadata in the form of the class attributes. For example, it says that the phrase "The Example Company" is a reference to an organization (`org`). This annotation is not modifying or refining the constraint expressed by the `li` tag. It is saying something else entirely. 
            
            But this is not just about suggesting a different way of interpreting `The Example Company` (as an organization name, as well as as a list item).  There is actually a complex {subject domain} structure being expressed by the vCard markup. Not only is the list item `The Example Company` annotated as `org`, the list that contains it is annotated as `vcard`. The constraint of interpretation provided by `org` is actually dependent on it being part of a `vcard` structure.
            
            In other words, the secondary structure created by the annotations in the sample above is equivalent to pure subject domain markup like this:
            
            ```(SAM)
                vcard:
                   fn: Joe Doe
                   org: The Example Company
                   tel: 604-555-1234
                   url: http://example.com/
            
            The microformats are overlaying a second structure on the list structure. In the world of HTML, this makes sense. HTML needs to be a standardized {document domain} language so that browsers can display it for human reading. Humans don't need the vCard annotations to recognize that the content is an address, but algorithms do. (This is part of dumbing it down for robots, as we discussed in [#chapter.quality].) So the microformat adds a second, hidden, {subject domain} structure to the document for readers who are algorithms rather than people. 
            
            Structured writing constrains both the creation and the interpretation of content. In the normal case we expect that the creation of the content would be just as constrained as the interpretation. After all, it is hard to rely on the interpretation of structure if the creation of the structure is not constrained. However in this case the interpretation of the data is more constrained than the creation. 
            
            Authoring our content this way would obviously be inefficient and error prone. But this is only a problem if the content is actually authored in this format. If the content is authored in a format in which its creation is constrained to the same extent as we wish the output to be constrained, it does not actually matter that the resulting output constrains interpretation more than it constrains creation. Our concern as content creators is simply to make sure that any content we produce that promises to abide by a constraint actually does so, whether the format we deliver it in actually imposes that constraint or merely annotates it. 
            
            So, we can confidently produce this information using subject domain markup and then deliver it as HTML with hCard annotation markup using a presentation algorithm something like this (as with all example algorithms in this book, this is pseudocode):
            
            ```(pseudo)
                match vcard
                    create ul
                        attribute class = "vcard"
                        continue

                match fn
                    create li
                        attribute class = "fn"
                        continue

                match org
                    create li
                        attribute class = "org"
                        continue

                match tel
                    create li
                        attribute class = "tel"
                        continue

                match url
                    create li
                        create a
                            attribute class = "url"
                            attribute href = contents
                            continue

            
            
        section: Child blocks vs. additional annotations
        
            As noted above, sometimes the name of a block is not sufficient to fully describe the constraints it meets. In these cases, we can add additional annotations to a block. But we can also achieve much the same thing by adding child blocks to the block. A child block belongs to the main block, so it is part of it and can constrain the interpretation of the main block just as much as an additional annotation does. One of the issues in designing mechanical structures for content, therefore, is when to use additional annotation on a block and when to use child blocks. 
            
            Different markup languages have different levels of support for additional annotation on blocks, so this issue is affected by the markup language you choose. SAM, for instance, only supports a limited fixed set of additional annotation on blocks, and therefore any additional constraint of interpretation you want to do in a SAM-based markup language has to be done with child blocks.  
            
            In XML, though, there is broad (though not unlimited) support for additional annotations on blocks in the form of attributes. In the XML world, therefore, there is considerable choice, and considerable debate, about when and where you should use elements vs. attributes in your content models.         
            
            Consider, for example, this XML element that contains no content but two attributes:

            ```(xml)
                <author-name first="Mark" last="Baker">
                
            the element is named `author-name` and it has two attributes named `first` and `last` that contain my first and last name respectively. 
            
            Why is this marked up like this and not like this:
            
            ```(xml)
                <author-name>
                    <first>Mark</first>
                    <last>Baker</first>
                </author-name>
                    
            Both these constructs express the same information in a way that clearly constrains how author names are to be written and how the markup of author names is to be interpreted by algorithms. 
            
            Is one of these options correct and the other incorrect? When should you use attributes and when should you use elements?          

            Consider our vcard example. It could be written this way, using just elements:       

            ```(XML)
                <vcard>
                   <fn>Joe Doe</fn>
                   <org>The Example Company</org>
                   <tel>604-555-1234</tel>
                   <url>http://example.com/</url>
                </vcard>

            Or it could be written this way, using attributes:
            
            ```(XML)
                <vcard
                   fn="Joe Doe"
                   org="The Example Company"
                   tel="604-555-1234"
                   url="http://example.com/"
                />
            
            The first says that `fn`, `org`, `tel`, and `url` are independent structures that belong as members to a `vcard` structure. The second says that the `vcard` structure has a number of data fields -- annotations -- that complete its meaning. 
            
            Does this distinction matter terribly? Both allow you to get at the information you want. Both constrain the creation and the interpretation of data. There are limits to the version that uses attributes. You can't have more than one attribute with the same name, whereas you could have more than one member elements of the same name (multiple tel elements for someone with more than one telephone number for instance). Also, XML specifies that attributes are unordered, so can't restrain either the order in which writers create them or the order in which the parser reports them to a processing application. 

            Given this, you may be wondering why people bother with attributes, since you can do the same things with elements and have both more flexibility and more capacity to impose constraints. Yet people continue to use attributes extensively when designing markup languages in XML.  When people create XML document types for representing data, rather than for writing document, they almost always use the attribute format, perhaps because it is slightly less verbose and slightly easier to read, or perhaps because as programmers they are accustomed to representing data as key/value pairs linked with `=` signs.

            But for documents it is more complex. To understand why XML even has attributes, and why other languages, such as SAM or reStructuredText, also have similar mechanisms for adding annotations to blocks, we need to go back to the original concept of markup as something written onto a manuscript after the fact. In this view, markup is an addition to the text, not part of it. The content of an element is part of the underlying text. Anything you want to add, therefore, cannot be element content, since that would be adding to the text. Everything else has to be added to element definitions as attributes. 

            This view is reinforced by the academic interest in markup as a way to prepare texts for study. Again, here, the text is preexisting and canonical. The markup is external to it and so everything that is external to the original text must be contained in the markup itself (as attributes) and nothing that is internal to the original text must be removed or replaced by markup. (This is a form of partitioning in its own right, to serve a particular purpose.) Thus in this fragment of a Shakespeare play marked up by John Bosek we see that the original text is kept perfectly intact:
            
            ```(xml)
                <ACT>
                <TITLE>ACT I</TITLE>
                <SCENE>
                <TITLE>SCENE I. Rousillon. The COUNT's palace.</TITLE>
                <STAGEDIR>
                Enter BERTRAM, the COUNTESS of Rousillon, HELENA, and LAFEU, 
                all in black
                </STAGEDIR>
                <SPEECH>
                <SPEAKER>COUNTESS</SPEAKER>
                <LINE>
                In delivering my son from me, I bury a second husband.
                </LINE>
                </SPEECH>
                <SPEECH>
                <SPEAKER>BERTRAM</SPEAKER>
                <LINE>And I in going, madam, weep o'er my father's death</LINE>
                <LINE>anew: but I must attend his majesty's command, to</LINE>
                <LINE>whom I am now in ward, evermore in subjection.</LINE>
                </SPEECH>
            
            Had this markup employed the normal refactoring of text into markup that we have seen in our discussions of the {document}(concept "document domain") and {subject}(concept "subject domain") domains, then the number and title of scenes would have been factored out so that instead of:
            
            ```(xml)
                <SCENE>
                    <TITLE>SCENE I. Rousillon. The COUNT's palace.</TITLE>
            
            we might have factored out the scene number and the work 'SCENE' like this:
            
            ```(xml)
                <SCENE>
                    <TITLE>Rousillon. The COUNT's palace.</TITLE>
            
            Going further, we might have noted that the introduction of a scene is invariable the name of its location, so we might have done this:
            
            ```(xml)
                <SCENE>
                    <LOCATION>Rousillon. The COUNT's palace.</LOCATION>

            or even this:

            ```(xml)
                <SCENE location="Rousillon. The COUNT's palace.">
            
            And similarly, we might have replaced:
            
            ```(xml)
                <SPEECH>
                    <SPEAKER>BERTRAM</SPEAKER>

            ```(xml)
                <SPEECH SPEAKER="BERTRAM">
                
            Making a few changes like this in the markup would leave us with only the words actually spoken by the actors as the "text" of the play and everything else expressed as elements or attributes. 

            This actually makes quite a lot of sense, because all of the stage directions and attribution of speakers in a play is actually metadata annotating the speeches of the actors which are the only things the audience is actually supposed to hear. 

            So is the right way to markup a play to preserve the original printed text -- which includes all of the playwright's metadata -- or is it better to separate the playwrights metadata from the speeches which are the 'real' play?

            But while these question may be important for the scholarly study of text, they are not nearly so important for structured writing. Our concern is to partition the task of content creation, so we can simply choose the format that does that in the most functionally lucid way while ensuring that all the information required by the next partition is accurately captured. The fact that such question exist, however, help us to understand both why a markup language like XML is structured the way it is, and why so many texts are marked up the way they are -- and why so many markup languages are designed the way they are. 

            The way we, as practitioners of structured writing, settle these matters is by asking ourselves which approach best supports the structured writing algorithms that we want to implement, and always remembering that the reliability of every other algorithm depends on how well the conformance algorithms works, and that the conformance algorithm depends to a large extent on how the authoring algorithm designs for conformance and for functional lucidity. 

            In none of this are we in the least concerned about preserving the canonical nature of a preexisting text. There is no preexisting text. We are all about creating new texts. Because of this we have every reason to prefer to use sub-structures rather than annotations on existing structures, to express things like our vCard example. In fact, SAM, which is designed specifically for structured authoring, only supports this format:             
            
            ```(SAM)
                vcard:
                   fn: Joe Doe
                   org: The Example Company
                   tel: 604-555-1234
                   url: http://example.com/
            
            SAM only supports a very limited set of annotations on blocks, all of which have predefined meetings. You could, in fact, eliminate annotations on blocks altogether, and use child blocks for everything, but I have supported a limited set of common {management-domain} block annotations in SAM, mostly to improve functional lucidity. 
                   
            In summary, when defining the mechanical structure of your structured writing, don't get hung up on what is text and what is markup. In each domain, text and markup together form a body of constrained content which can be successfully created by an author and successfully processes by one or more algorithms. Only when you resolve the content all the way to the media domain do you finally have to sort our exactly which characters appear in which order and decoration to represent that content to a particular audience. When we choose to create content in the other domains it is precisely because we want to exercise more control over these things, and to use algorithms to help us create and manage them. Whether some idea or constraint is expressed by text of markup in those domains should be based solely on what works best in those domains. (Which is precisely why attempting to do structured writing using a WYSIWYG editor is so counter productive, and why it is so important to ensure the functional lucidity of your markup as markup.)
        
        
        
        
            

    